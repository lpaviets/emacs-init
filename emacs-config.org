#+title: Emacs Configuration
#+author: Léo Paviet Salomon
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Organization of this file

  This file contains a Emacs configuration, written in a Org Mode document. It is largely based on [[https://github.com/daviwil/emacs-from-scratch/][Emacs From Scratch]].

  It is able to automatically generate a init.el file, loaded by Emacs at startup.

  If this file is on the path "~/.emacs.d/emacs-config.org" then it will automatically generate an output. To modify this behaviour, see the "Org Mode/Auto-tangle configuration files" subsection and modify it as you need.

  If this file is named differently on your system, or simply located in another directory, you can still generate an output without changing anything by invoking the =org-babel-tangle= command (=C-c C-v t=).

  Because I use a version system on those files, I don't mind conflicts with the currently loaded configuration file, and so the the generated file is actually called  =init.el=. By default, Emacs reads (and loads) file such as "~/.emacs" or "~/.emacs.d/init.el" at startup, so the output of =org-babel-tangle= is automatically replacing the previous configuration file. If you want to avoid those conflicts, you might need to rename it.

  To modify the name of the output, you can change it in the second line of this document, after the =:tangle= keyword.

  Some commands have to be run manually whenever the generated =init.el= file is loaded for the first time.

  Whenever this is the case, it is explicitly signaled by the presence of the *MANUAL* keyword in front of those commands.

  If the init.el cannot be properly loaded at startup, try to search for such keywords in this file and execute the corresponding commands.

* Initialization
** Emacs performance

First, we set things up so that Emacs starts /fast/.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000) ; 1e8 = 100 MB (default: 800kB)
#+END_SRC

Another thing that might be of interest is to know how long it took for Emacs to start. Although there is already a built-in function to do this (try to call =emacs-init-time= in any Emacs session), we want it to be automatically displayed anytime we start Emacs

#+BEGIN_SRC emacs-lisp
(defun my-display-startup-time ()
  (message "Emacs started in %s seconds"
    (format "%.2f"
      (float-time
        (time-subtract after-init-time before-init-time)))))

(defun my-display-garbage-collection ()
  (message "Emacs performed %d garbage collection"
    gcs-done))

(add-hook 'emacs-startup-hook #'my-display-startup-time)
(add-hook 'emacs-startup-hook #'my-display-garbage-collection)

; After startup, we restore gc-cons-threshold to a more reasonable value
(setq gc-cons-threshold 2000000) ; 2e6 = 2 MB
#+END_SRC

** Package management

Then, we need to configure how we will install packages. We use another package manager that the default one: =use-package=.

It makes both installation and customization easier, and the code is also simpler to read.

*MANUAL* You might want to configure =use-package= differently, as it is the tool used everywhere else in this configuration file to install and setup other packages. For example, the line
=(setq use-package-always-ensure t)= is used to install all the packages mentioned in this file automatically if you do not already have them. Depending on your environment, you might want to consider another, more appropriate behaviour (/e.g./  if you lack space, time, if you use another OS, if you are already compiling some of those packages by yourself, and so on).

#+BEGIN_SRC emacs-lisp

;; Initialize package sources
(require 'package)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)

(unless package-archive-contents
 (package-refresh-contents))

;; Initialize use-package on non-Linux platforms
(unless (package-installed-p 'use-package)
   (package-install 'use-package))

;; Other packages
(add-to-list 'load-path "~/.emacs.d/extra-packages")

(require 'use-package)
;; Comment this line if you don't want to automatically install packages
(setq use-package-always-ensure t)

#+END_SRC

** Quick restart

In order to test things more rapidly and to be able to apply configuration changes without ever leaving Emacs, we also install another package to restart Emacs with a simple command.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands (restart-emacs restart-emacs-start-new-emacs))
#+END_SRC

* UI Configuration
** Comfort changes

We remove all the unnecessary elements from the interface, /e.g./ menus, scroll bar and so on.

You can remove or partially modify this block of code if you are a beginner and want to keep some of elements available, especially to be able to navigate with the mouse.

All the variable names are pretty explicit, so you should be able to customize this to your taste easily.

#+BEGIN_SRC emacs-lisp
  ;; Whenever a region is activated, inserting a symbol will first delete the region
  ; (delete-selection-mode 1)

  ;; Disable the annoying startup message and Emacs logo
  (setq inhibit-startup-message t)

  ;; Maximize the frame
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)          ; Disable the menu bar

  ;; Global line numbering mode, except in some major modes
  (add-hook 'prog-mode 'column-number-mode)
  (add-hook 'prog-mode 'display-line-numbers-mode)

  ;; Disable line numbering for some modes
  ;; (dolist (mode '(org-mode-hook
  ;;                 term-mode-hook
  ;;                 shell-mode-hook
  ;;                 eshell-mode-hook
  ;;                    doc-view-mode-hook
  ;;                    undo-tree-visualizer-hook
  ;;                    pdf-view-mode-hook
  ;;                    treemacs-mode-hook))
  ;;   (add-hook mode (lambda ()
  ;;      ((linum-mode 0)
  ;;       (column-number-mode 0)))))

  ;; Automatically reload a file if it has been modified
  (global-auto-revert-mode t)

  ;(setq-default kill-whole-line t) ; Kill the line and the final \n
#+END_SRC

Another very useful package is undo-tree, which allows you to visualize the previous "Undos" and navigate them.

It can act as a small, local version control system due to how Undos are managed by Emacs.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :config
  (setq undo-tree-visualizer-timestamps t)
  (global-undo-tree-mode)
  :diminish (undo-tree-mode))

#+END_SRC

** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] is a package that is used to group several related commands into a family of bindings, all starting with the same prefix (= "hydra"). Whenever this common prefix is entered in a suitable mode, a panel shows up, showing all the user-defined commands that can now be invoked with a single keystroke instead of repeatedly using the same long prefix.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :defer t)
#+END_SRC

All the hydras will now be defined after the package to which they correspond, or in the appropriate section. Most of them are modifications of hydras that can be found on the [[https://github.com/abo-abo/hydra/wiki][hydra wiki]].

Some hydras will be called less frequently and for other purposes than getting a "quick-and-dirty" access to commonly used functions. Hence, we will make them prettier (the compromise being that they are less minimalistic and take much more space visually)


*MANUAL* This is not a MELPA package. It can be found [[https://github.com/Ladicle/hydra-posframe][here]]. Install it and change the loading path according to your configuration.

#+BEGIN_SRC emacs-lisp
  (use-package posframe
    :defer t)

  ;; Manual load and config of Hydra Posframe
  ;; To fix: find a way to override parameters ...
  ;; (load-file "~/.emacs.d/extra-packages/hydra-posframe.el")
  ;; (setq hydra-posframe-border-width 5)

  ;Pretty Hydra
  (use-package pretty-hydra
    :defer t
    :after hydra)
#+END_SRC

** General appearance
*** Extra packages

Some packages are used lated in the configuration, and we want to be able to use those comfortable modes.

#+BEGIN_SRC emacs-lisp
;; Generic UI modes

(use-package beacon
  :init (beacon-mode))
(use-package rainbow-mode
  :defer t)
(use-package fill-column-indicator
  :defer t)
(use-package visual-fill-column
  :defer t)
#+END_SRC

*** Command log mode

This mode allows you to display a small panel on the right of the screen which shows which keys you are pressing, and what commands they are associated to, all of this in real time !

As of now, you need to enable the mode by using the =command-log-mode= command (or =global-command-log-mode= if you want to record everything, in all the buffers of the current session), and to use the =C-c o= keybinding (which calls the =clm/toggle-command-log-buffer= function) to open a new buffer in which you will see both the keybindings you are currently using and the commands to which they are bound.

If you want =command-log-mode= to be activated by default in certain minor (or even major) modes, simply add a hook. You will still need to explicitly open the buffer, but this could also be dealt with by using other, straightforward hooks.

#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
;; :hook (<your-favourite-mode> . command-log-mode) ; Add here modes in which you want to run the command-log-mode
  :commands command-log-mode
)
#+END_SRC

*** Theme

This is simply a way to change how Emacs looks. Some themes are more complete than other (they will modify how other packages look, like Magit, or even the minibuffer)

#+BEGIN_SRC emacs-lisp
;; Themes
(use-package doom-themes
  :init (load-theme 'doom-Iosvkem t))
#+END_SRC

We also install an extra package to cycle through all (or a predefined list) the themes.

#+BEGIN_SRC emacs-lisp
(use-package cycle-themes
  :defer t
;; :config
;; (setq cycle-themes-theme-list
;;        '(leuven monokai solarized-dark)) ; Your favourite themes list
)

#+END_SRC

*** Modeline and icons

This modifies how the [[https://www.emacswiki.org/emacs/ModeLine][modeline]] looks.

*MANUAL* If this is your first time running the init.el file, please run the following command:

=M-x all-the-icons-install-fonts=

#+BEGIN_SRC emacs-lisp
;; First time used: run M-x all-the-icons-install-fonts
(use-package all-the-icons
  :config
  ;; Avoid unnecessary warnings
  (declare-function all-the-icons-faicon 'all-the-icons)
  (declare-function all-the-icons-fileicon 'all-the-icons)
  (declare-function all-the-icons-material 'all-the-icons)
  (declare-function all-the-icons-octicon 'all-the-icons)

  ;;define an icon function with all-the-icons-faicon
  ;;to use filecon, etc, define same function with icon set
  (defun with-faicon (icon str &rest height v-adjust)
     (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))
  ;filecon
  (defun with-fileicon (icon str &rest height v-adjust)
     (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))
)

(use-package doom-modeline
  :after all-the-icons
  :init (doom-modeline-mode 1)
  :custom ((doom-modeline-height 15)))
#+END_SRC

*** Change parameters

This is one moment where a pretty hydra could help us change general UI parameters, such as the text size, some highlighting options and so on.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'hydra
;define a title function
  (defvar appearance-title (with-faicon "desktop" "Appearance"))

  ; Other idea:
  ; (defvar appearance-title (with-faicon "toggle-on" "Toggles" 1 -0.05))

  ;generate hydra
  
  (pretty-hydra-define hydra-appearance (:title appearance-title
                                         :quit-key "q"
					 ;:pre (hydra-posframe-mode t)
					 ;:post (hydra-posframe-mode 0) ; dirty hack
					 )
  ("Theme"
    (
;     ("o" olivetti-mode "Olivetti" :toggle t)
;     ("t" toggle-window-transparency "Transparency" :toggle t )
      ("c" cycle-themes "Cycle Themes" )
      ("+" text-scale-increase "Zoom In")
      ("-" text-scale-decrease "Zoom Out")
      ("x" toggle-frame-maximized "Maximize Frame" :toggle t )
      ("X" toggle-frame-fullscreen "Fullscreen Frame" :toggle t)
    )
    "Highlighting"
    (
      ("d" rainbow-delimiters-mode "Rainbow Delimiters" :toggle t )
      ("r" rainbow-mode "Show Hex Colours" :toggle t )
      ;    ("n" highlight-numbers-mode "Highlight Code Numbers" :toggle t )
      ("l" display-line-numbers-mode "Show Line Numbers" :toggle t )
      ("_" global-hl-line-mode "Highlight Current Line" :toggle t )
      ;    ("I" rainbow-identifiers-mode "Rainbow Identifiers" :toggle t )
      ("b" beacon-mode "Show Cursor Trailer" :toggle t )
      ("w" whitespace-mode "whitespace" :toggle t)
    )
    "Miscellaneous"
    (
      ("j" visual-line-mode "Wrap Line Window"  :toggle t)
      ("m" visual-fill-column-mode "Wrap Line Column"  :toggle t)
      ;    ("a" adaptive-wrap-prefix-mode "Indent Wrapped Lines" :toggle t )
      ;   ("i" highlight-indent-guides-mode  "Show Indent Guides" :toggle t )
      ("g" fci-mode "Show Fill Column" :toggle t )
      ("<SPC>" nil "Quit" :color blue )
  ))))

  (global-set-key (kbd "C-c a") 'hydra-appearance/body)

#+END_SRC
** Easier search and minibuffer use
Although emacs provides a number of commands to navigate within a file, to find documentation and so on, the following packages will make the general UI easier to use.

[[https://github.com/justbur/emacs-which-key][which-key]] is a package that shows all the available commands after having typed some prefix.

For example, if you press =C-c=, then a panel will appear at the bottom of the screen to show how you can currently continue this command.

#+BEGIN_SRC emacs-lisp
;; which-key. Shows all the available key sequences after a prefix
(use-package which-key
  :init (which-key-mode)
  :diminish
  :config
  (setq which-key-idle-delay 1))
#+END_SRC

[[https://github.com/abo-abo/swiper][Ivy and Counsel]] are completion frameworks that allow you to use the minibuffer more comfortably.

#+BEGIN_SRC emacs-lisp
;; Ivy
(use-package ivy
  :diminish 
  :bind (("C-s" . swiper)
	 :map ivy-minibuffer-map
	 ("TAB" . ivy-partial-or-done)
	 ("C-l" . my-ivy-alt-done-t) ; Small hack
	 :map ivy-switch-buffer-map
	 ("C-l" . ivy-done)
	 ("C-d" . ivy-switch-buffer-kill)
	 :map ivy-reverse-i-search-map
	 ("C-d" . ivy-reverse-i-search-kill))
  :config
  (defun my-ivy-alt-done-t ()
    (interactive)
    (ivy-alt-done t))

  (ivy-mode 1))

;; Adds things to Ivy
(use-package ivy-rich
  :hook (ivy . ivy-rich-mode))

;; Counsel. Adds things to Ivy
(use-package counsel
  :config (counsel-mode)
  :diminish
  :bind (("M-x" . counsel-M-x)
         ("C-x b" . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history)))

#+END_SRC

[[https://github.com/Wilfred/helpful][helpful]] makes things easier to remember and to use without having to search for documentation in multiple places.

It will condense all the available information about something within a single Help buffer, and will add some documentation to the commands you are currently typing.

#+BEGIN_SRC emacs-lisp
;; Helpful. Extra documentation when calling for help
(use-package helpful
  :after counsel
  :commands (helpful-callable helpful-variable helpful-command helpful-key)
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))

#+END_SRC
** Buffer management

Emacs is sometimes all over the place, opening buffers at seemingly random places, switching your focus only in some circumstances ... We will customize this behaviour so that we have a better control on what Emacs is doing when we open new buffers

#+BEGIN_SRC emacs-lisp
;;Buffer management
(setq display-buffer-base-action
  '((display-buffer-reuse-window)
    (display-buffer-reuse-mode-window)
    (display-buffer-same-window)
    (display-buffer-in-previous-window)))

;; Can even have further control with
;; display-buffer-alist, or using extra-parameters

#+END_SRC

** Window management

Because window management can be a bit tedious with the basic Emacs functionalities, we improve it a bit. First of all, we enable =winner-mode=, which allows us to "undo" and "redo" changes in the Windows' configuration.

#+BEGIN_SRC emacs-lisp
(winner-mode 1)

#+END_SRC

To facilitate window management, we use an hydra, binding most of the commands that we might ever need.

First of all, we use a few helper functions, defined in [[https://github.com/abo-abo/hydra/blob/master/hydra-examples.el][hydra-examples.el]]

#+BEGIN_SRC emacs-lisp
;;* Helpers
(use-package windmove
  :defer t)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))
#+END_SRC

Now, we wrap everything up into a nice hydra

#+BEGIN_SRC emacs-lisp
(global-set-key
(kbd "C-c w") ; w for window
(defhydra hydra-window (:color red
                        :hint nil)
"
^Focus^           ^Resize^       ^Split^                 ^Delete^          ^Other
^^^^^^^^^-------------------------------------------------------------------------------
_b_move left      _B_left        _V_split-vert-move      _o_del-other      _f_new-frame
_n_move down      _N_down        _H_split-horiz-move     _da_ace-del       _u_winner-undo
_p_move up        _P_up          _v_split-vert           _dw_del-window    _r_winner-redo
_f_move right     _F_right       _h_split-horiz          _df_del-frame
_q_uit
"
  ; Move the focus around
  ("b" windmove-left)
  ("n" windmove-down)
  ("p" windmove-up)
  ("f" windmove-right)
  ; Changes the size of the current window
  ("B" hydra-move-splitter-left)
  ("N" hydra-move-splitter-down)
  ("P" hydra-move-splitter-up)
  ("F" hydra-move-splitter-right)
  ; Split and move (or not)
  ("V" (lambda ()
         (interactive)
         (split-window-right)
         (windmove-right)))
  ("H" (lambda ()
         (interactive)
         (split-window-below)
         (windmove-down)))
  ("v" split-window-right)
  ("h" split-window-below)
  ;("t" transpose-frame "'")
  ;; winner-mode must be enabled
  ("u" winner-undo)
  ("r" winner-redo) ;;Fixme, not working?
  ; Delete windows
  ("o" delete-other-windows :exit t)
  ("da" ace-delete-window)
  ("dw" delete-window)
  ("db" kill-this-buffer)
  ("df" delete-frame :exit t)
  ; Other stuff
  ("a" ace-window :exit t)
  ("f" new-frame :exit t)
  ("s" ace-swap-window)
  ("q" nil)
  ;("i" ace-maximize-window "ace-one" :color blue)
  ;("b" ido-switch-buffer "buf")
  ("m" headlong-bookmark-jump)))
#+END_SRC

* Org Mode

   [[https://orgmode.org/][Org Mode]] is one of the best reasons to use Emacs.

   It acts as a markup language, can deal with planning, manage spreadsheets, do project planning, run code blocks to do literate programming ...

*** Font faces

     In order for Org Mode to feel like a document instead of code, we use a different font.

#+BEGIN_SRC emacs-lisp
(let ((my-temp-org-font "Cantarell"))
    (if (member my-temp-org-font (font-family-list))
        (setq my-org-mode-font my-temp-org-font)
      (setq my-org-mode-font "Ubuntu Mono")))

(defun my-org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; Set faces for heading levels
  ;; For non-headers: org-default

  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font my-org-mode-font :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+END_SRC
*** Basic configuration

     We change the general feel of Org Mode documents by using other indentation rules, by changing the headers appearance, and a few other minor changes.

#+BEGIN_SRC emacs-lisp
(defun my-org-mode-setup ()
  (my-org-font-setup)
  (org-indent-mode)
  (variable-pitch-mode 1)
  (visual-line-mode 1))
  

(use-package org
  :config
  (setq org-ellipsis " ▾")
  :hook (org-mode . my-org-mode-setup)
)

(use-package org-bullets
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+END_SRC

*** Org Babel

     Org babel is what allows us to write code and execute it, all within the same document.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (python . t))))

;; (setq org-confirm-babel-evaluate nil) ; Take care if executing someone
					; else code

#+END_SRC

*** Auto-tangle configuration files

     In order to concatenate all the code blocks that are written in this document to an external file, we need to "tangle" it.

     The following code makes it so that each time this file is saved, it generates the corresponding init.el file.

#+BEGIN_SRC emacs-lisp
;; Automatically tangles this emacs-config config file when we save it
(defun my-org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "~/.emacs.d/emacs-config.org"))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'my-org-babel-tangle-config)))
#+END_SRC

* Editing

   Emacs is fundamentally a text editor. It provides a lot of functions to deal with text, and a way to create macros, to automate things, to repeat something multiple times ... easily. However, because there are /so many/ available functions, we might need some help to navigate around and do fancy things.

** Multiple cursors

A first improvement is the addition of multiple cursors. The "rectangle region" already gives a way to insert text simultaneously at several places, and to perform some easy operations on a rectangular area, but the [[https://github.com/magnars/multiple-cursors.el][multiple cursor]] package really increases the possibilities.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :defer t) ; TODO: binds
#+END_SRC

The webpage specifies that the commands provided by this package are best invoked when bound to key sequence rather than by =M-x <mc/command-name>=, although some testing on my part seems to show that it still works relatively well most of the time.

** Movement

Because movement keys are the most frequently used ones, it might be useful to create an Hydra helping us navigate around a document.

#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-c m")
 (defhydra hydra-move ()
   "Movement" ; m as in movement
   ("n" next-line)
   ("p" previous-line)
   ("f" forward-char)
   ("b" backward-char)
   ("a" beginning-of-line)
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)))
#+END_SRC

** Rectangles

Manipulating rectangles is a cool Emacs feature. You can select a region with the shape of a rectangle, copy and yank it, insert strings at the beginning of each line of the selection, and several other features.

Because the functions operating on rectangles are not always the easier to remember, we simply define a new Hydra referencing the most useful ones.

#+BEGIN_SRC emacs-lisp
(global-set-key
(kbd "C-c r") ; r as rectangle
(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :hint nil
                                     :post (deactivate-mark))
  "
  ^_p_^       _w_ copy      _o_pen       _N_umber-lines                   |\\     -,,,--,,_
_b_   _f_     _y_ank        _t_ype       _e_xchange-point                 /,`.-'`'   ..  \-;;,_
  ^_n_^       _d_ kill      _c_lear      _r_eset-region-mark             |,4-  ) )_   .;.(  `'-'
^^^^          _u_ndo        _q_ quit     _i_nsert-string-rectangle      '---''(./..)-'(_\_)
"
  ("p" rectangle-previous-line)
  ("n" rectangle-next-line)
  ("b" rectangle-backward-char)
  ("f" rectangle-forward-char)
  ("d" kill-rectangle)                    ;; C-x r k
  ("y" yank-rectangle)                    ;; C-x r y
  ("w" copy-rectangle-as-kill)            ;; C-x r M-w
  ("o" open-rectangle)                    ;; C-x r o
  ("t" string-rectangle)                  ;; C-x r t
  ("c" clear-rectangle)                   ;; C-x r c
  ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
  ("N" rectangle-number-lines)            ;; C-x r N
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)))        ;; C-x SPC
  ("i" string-insert-rectangle)
  ("u" undo nil)
  ("q" nil)))
#+END_SRC

** Selection

A useful tool to manipulate text and even source code is the [[https://github.com/magnars/expand-region.el][expand-region]] package, as it allows us to increase the selected region to match larger and larger /semantic/ units. For example, by using it repeatedly, you could select in this order a character, a word, a string containing this word, a sexp containing this string, and the function in this sexp is used.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
:bind ("C-=" . er/expand-region))
#+END_SRC

* Programming
** Projectile

    [[https://projectile.mx/][Projectile]] is an Emacs package that makes project management easier. It allows us /e.g./ to navigate between files of the same project, search/replace within files of the same project, and integrates very well with other tools, such as =lsp-mode= or =counsel=.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish
  :init
  ;; NOTE: Set this to the folder where you keep your Git repos!
  ;; (when (file-directory-p "path/to/project/dir")
  ;; (setq projectile-project-search-path '("path/to/project/dir")))
  (setq projectile-switch-project-action #'projectile-dired)

  :config
  (projectile-mode)
  :custom ((projectile-completion-system 'ivy))
  :bind-keymap
  ("C-c p" . projectile-command-map))

(use-package counsel-projectile
  :after (counsel projectile)
  :config (counsel-projectile-mode))

#+END_SRC

** Magit

    [[https://magit.vc/][Magit]] is a serious contender for the first place in the long list of "Reasons you should use Emacs", along with Org Mode.

    It is a Text User Interface to Git, which integrates most of Git commands, even the most advanced ones, while making it easy to use even for beginners.

#+BEGIN_SRC emacs-lisp
(use-package magit
  ;; :custom (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)

  ;; uncomment previous line to have magit open itself within the same buffer
  ;; instead of in another buffer
  :bind ("C-x g" . magit-status)
  )

#+END_SRC

** Parenthesis

    To make it easy to deal with parenthesis in various programming languages, we also use the following packages, which colourize matching parenthesis accordingly and insert brackets pair whenever we insert the opening one - althoug they can do much more.

#+BEGIN_SRC emacs-lisp
  ;; rainbow-delimiters. Hightlights with the same colour matching parenthesis
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  ;; Smartparens is currently bugged
  (use-package smartparens
  :custom (sp-highlight-pair-overlay nil)
  :hook (smartparens-mode . show-smartparens-mode)
  :bind
  ("C-M-f" . sp-forward-sexp)
  ("C-M-b" . sp-backward-sexp)

  ;; Define those as in paredit
  ("C-M-n" . sp-up-sexp)
  ("C-M-d" . sp-down-sexp)
  ("C-M-u" . sp-backward-up-sexp)
  ("C-M-p" . sp-backward-down-sexp)

  ("C-S-a" . sp-beginning-of-sexp)
  ("C-S-e" . sp-end-of-sexp)

  ("C-M-t" . sp-transpose-sexp)

  ("C-M-k" . sp-kill-sexp)
  ("C-M-w" . sp-copy-sexp)

  ("M-<delete>" . sp-unwrap-sexp)
  ("M-<backspace>" . sp-backward-unwrap-sexp)

  ("C-<right>" . sp-forward-slurp-sexp)
  ("C-<left>" . sp-forward-barf-sexp)
  ("C-M-<left>" . sp-backward-slurp-sexp) ; kbd ghosting ?
  ("C-M-<right>" . sp-backward-barf-sexp) ; kbd ghosting ?

  ("M-s" . sp-splice-sexp) ; unbinds "occur"
  ;; ("C-M-<delete>" . sp-splice-sexp-killing-forward)
  ;; ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
  ;; ("C-S-<backspace>" . sp-splice-sexp-killing-around)

  ("M-F" . sp-forward-symbol)
  ("M-B" . sp-backward-symbol))
  

  (use-package paredit
  :hook ((mrepl-mode
          eshell-mode
          ielm-mode
          eval-expression-minibuffer-setup) . enable-paredit-mode))

  (defun paredit-or-smartparens ()
  "Enable paredit or smartparens depending on the major mode"
  (if (member major-mode '(emacs-lisp-mode
                         lisp-mode
                         lisp-interaction-mode))
    (paredit-mode)
  (smartparens-mode)))
;; Bug with strict-mode in cc-mode (Java, C/C++ ...)
;; Bindings are overriden by the cc-mode one, so sp-strict-mode does not
;; work properly (e.g. <DEL> is not bound to sp-backward-delete-char)

  (add-hook 'prog-mode-hook #'paredit-or-smartparens)
#+END_SRC

** Auto-completion
**** YASnippet

     A first useful package is YASnippet, which makes it easy to define and automatically insert snippets of code in various languages.

#+BEGIN_SRC emacs-lisp
;;YASnippet
(use-package yasnippet
  :diminish
  :init (yas-global-mode t))

#+END_SRC

**** Company

     Several packages are available to make auto-completion more efficient and intuitive than the built-in =completion-at-point= function. We use [[https://company-mode.github.io/][Company]] (stands for "comp[lete] any[thing]") as it integrates nicely with other packages that we use, is well-maintained and has a more modern interface than most of its counterparts such as =auto-complete=.

#+BEGIN_SRC emacs-lisp
  ;; Company. Auto-completion package
  (use-package company
    :diminish

    :init (global-company-mode t)

    :bind (
       :map company-active-map
          ("<tab>" . company-complete-selection)
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous)
          ("M-n" . nil)
          ("M-p" . nil)
       :map company-search-map
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous))

    :custom
       (company-minimum-prefix-length 3)
       (company-idle-delay 0.1)
       (company-echo-delay 0.1)
       (company-selection-wrap-around t)
    :hook
       ;; ((python-mode c++-mode c-mode) . (lambda ()
       ;;               (set (make-local-variable 'company-backends)
       ;;               '((company-capf
       ;;               company-semantic
       ;;               company-keywords
       ;;               company-yasnippet
       ;;               company-files
       ;;               ;;company-dabbrev
       ;;               )))))
        ((tex-mode latex-mode TeX-mode) . (lambda ()
                     (set (make-local-variable 'company-backends)
                     '((;company-auctex
                        company-capf
                        company-math-symbols-unicode
                        company-math-symbols-latex
                        company-latex-commands
                        company-keywords
                        company-yasnippet
                        company-files)))))
  )

#+END_SRC

To have a cleaner interface and also a bit of documentation added to the suggested completions, we use two extra packages.

#+BEGIN_SRC emacs-lisp
(use-package company-box
  :after company
  :hook (company-mode . company-box-mode)
  :diminish)

(use-package company-quickhelp
  :after company
  :hook (company-mode . company-quickhelp-mode)
  :diminish
  :custom (company-quickhelp-delay 0.2))

#+END_SRC

***** Company backends

Because we will be using LSP in several programming modes, we also use another backend for company.

#+BEGIN_SRC emacs-lisp
;;company-lsp is deprecated  
;; (use-package company-lsp
  ;;     :custom
  ;;     (company-lsp-cache-candidates t) ;; auto, t(always using a cache), or nil
  ;;     (company-lsp-async t)
  ;;     (company-lsp-enable-snippet t)
  ;;     (company-lsp-enable-recompletion t))

#+END_SRC

We install other backends specifically for LaTeX

#+BEGIN_SRC emacs-lisp
  ;; (use-package company-auctex
  ;; :init (company-auctex-init))
  (use-package company-math)
#+END_SRC

**** Auto-complete

     We still define a configuration for the auto-complete package, because we might want to use it in other buffers where company is a bit too much.

#+BEGIN_SRC emacs-lisp
;; Auto-complete
(use-package auto-complete
  :diminish
  :config
  (setq ac-use-quick-help t)
  (setq-default ac-sources '(;ac-source-yasnippet
			   ac-source-words-in-same-mode-buffers
			   ac-source-dictionary)) ; see auto-complete doc for other sources
)

#+END_SRC

** Language Server Protocol

    The [[https://en.wikipedia.org/wiki/Language_Server_Protocol][Language Server Protocol]] is a protocol which facilitates the use of several languages with various IDE. Instead of specifying a syntax, ..., for each pair "IDE/Language", it aims at abstracting the specifities of each language, so that each IDE will need to communicate with a server that will give back the information needed to do IDE-y things such as highlighting or auto-completion in an unified manner.

#+BEGIN_SRC emacs-lisp

;; LSP mode. Useful IDE-like features
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :config
  (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
  (lsp-enable-which-key-integration t)
  ;(setq lsp-signature-render-documentation nil)
  ;(setq lsp-signature-auto-activate nil)
  ;(setq lsp-enable-symbol-highlighting nil)
  (setq lsp-prefer-flymake nil)
  (setq lsp-diagnostics-provider :flycheck) ;:none if none wanted
  :hook
  ((python-mode c-mode c++-mode) . lsp)
)

(use-package lsp-ui
  :after lsp-mode
  :hook (lsp-mode . lsp-ui-mode)
  :custom
  (lsp-ui-doc-enable nil)
  (lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-delay 1)
  (lsp-ui-sideline-show-code-actions nil)
  ;(lsp-ui-sideline-enable nil)
 )

(use-package lsp-treemacs
  :after lsp-mode)

(use-package lsp-ivy
  :after (lsp-mode ivy))

#+END_SRC

** Real-time syntax checking

    [[https://www.flycheck.org/en/latest/][Flycheck]] is a modern on-the-fly syntax checking extension to Emacs, working for several languages, showing different level of errors (warnings, errors ...), and which has a natural integration to =lsp-mode=.

#+BEGIN_SRC emacs-lisp
;; Flycheck
(use-package flycheck
  :defer t
  :config
  ;(setq flycheck-relevant-error-other-file-show nil) ;might be useful
  (setq flycheck-indication-mode 'left-margin)
  :diminish
  ;; :hook (python-mode . flycheck-mode)
  ) ; Temporary to avoid noise ...

#+END_SRC

Another package doing more or less the same thing but in a different way:

#+BEGIN_SRC emacs-lisp
;; Semantic
(use-package semantic
;; (require 'semantic/ia)
;; (require 'semantic/bovine/gcc)

;; (defun my-semantic-hook ()
;;   (imenu-add-to-menubar "TAGS"))
;; (add-hook 'semantic-init-hooks 'my-semantic-hook)
  :defer t
  :config
  (semantic-mode t)
  (global-semanticdb-minor-mode t)
  (global-semantic-idle-scheduler-mode t))

#+END_SRC

** Programming languages

    In this section, we fine-tune our tools to specific programming languages.
*** Python

     We need to specify which server LSP will use. Several packages are available.

     *MANUAL* Before using LSP, use the following command to install a server:

     =pip install --user python-language-server[all]=

     The command =pyls= needs to be available on the =PATH= environment variable.

     #+BEGIN_SRC emacs-lisp

;; Python

;; Before using LPS, make sure that the server has been installed !
;; pip install --user python-language-server[all]
;; Should be able to use the pyls command

(use-package python-mode
  :defer t
  :custom
  ;(setq python-shell-interpreter "python3")
  (setq tab-width 4)
  (setq python-indent-offset 4))

     #+END_SRC

*** OCaml

For OCaml, we do not use LSP mode, and we instead choose to work with a specific minor mode called [[https://github.com/ocaml/tuareg][Tuareg]].

#+BEGIN_SRC emacs-lisp
;; Tuareg (for OCaml and ML like languages)
(use-package tuareg
  :defer t
  :config
  (setq tuareg-indent-align-with-first-arg t)
  (setq tuareg-match-patterns-aligned t))

#+END_SRC

*** C/C++

For C and C++ (and ObjectiveC), as for Python, we need to install a server for LSP to use. We use the one called [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]].

*MANUAL* To use the ccls server, follow the instruction [[https://github.com/MaskRay/ccls/][here]].

#+BEGIN_SRC emacs-lisp
;; C/C++
;; See https://github.com/MaskRay/ccls/wiki/lsp-mode
(use-package ccls
  :defer t
  :config
  (setq ccls-executable (executable-find "ccls")))
#+END_SRC
*** LISP
***** Emacs Lisp

Although Emacs comes with pretty good built-in functionalities, there is still room for improvement.

[[https://github.com/Fanael/highlight-defined][highlight defined]] highlights defined Emacs Lisp symbols (functions, variable names, macros ...) in source code.

#+BEGIN_SRC emacs-lisp
(use-package highlight-defined
:hook (emacs-lisp-mode . highlight-defined-mode))

#+END_SRC

[[https://github.com/Silex/elmacro][elmacro]] shows keyboard macros and interactive commands as Emacs Lisp, meaning that you know /how to do/ something using advanced keyboard shortcuts or interactive commands, you can get for free an elisp code snippet that does exactly the same thing that you can reuse /e.g./ in a configuration file or in another function.

Because it might be useful everywhere, we do not use it simply in =emacs-lisp-mode= and we activate it everywhere.

#+BEGIN_SRC emacs-lisp
(use-package elmacro
:init (elmacro-mode t))
#+END_SRC

***** Common Lisp

We could, of course, use LSP to write Common Lisp code. However, Emacs already provides nice editing functionalities for programming in Lisp-like languages, and CL is no exception. On top of the built-in Emacs functions, we use another minor mode, specifically designed to write Common Lisp: [[https://common-lisp.net/project/slime/][SLIME]]. More precisely, we use a /fork/ of SLIME, known as [[https://github.com/joaotavora/sly][SLY]]

#+BEGIN_SRC emacs-lisp
(use-package sly
  :commands sly
  :custom (inferior-lisp-program "/usr/bin/clisp") ; Might want to give SCBL a try
)
#+END_SRC

* LaTeX and PDF
*** PDF viewer

Rather than =doc-view=, we  use [[https://github.com/politza/pdf-tools][PDF Tools]].

*MANUAL* This package might require some external libraries to be installed. Please refer to the linked page to see exactly what you need to do on your system.

#+BEGIN_SRC emacs-lisp
;; Might require extra libs to work, see https://github.com/politza/pdf-tools

(use-package pdf-tools
 :defer t
 :config
   (pdf-tools-install)
   (setq TeX-view-program-selection '((output-pdf "pdf-tools")))
   (setq TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
   (setq TeX-source-correlate-start-server t))
#+END_SRC

*** LaTeX

We use a package to write LaTeX documents

#+BEGIN_SRC emacs-lisp
(use-package auctex
  :defer t)
#+END_SRC

And we add a few other utilities, for example we want the PDF to be reloaded whenever we make some change in the source code.

#+BEGIN_SRC emacs-lisp
   ;; Update PDF buffers after successful LaTeX runs
(add-hook 'TeX-after-compilation-finished-functions
	    #'TeX-revert-document-buffer)

;;(add-hook 'LaTeX-mode-hook 'ac-LaTeX-mode-setup) ; Remove: we keep Company for completion
#+END_SRC
* System
*** Eshell

Contrary to =term= and =shell= (respectively invoked by =M-x <term/shell>=), [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][eshell]] is not /emulating/ anything: it is, on its own, a shell-like command interpreter implemented in Emacs Lisp. As such, it provides (most of) the usual commands such as =grep=, =ls= and so on, as well as an extra binding to Emacs (for example, you can redirect the output of any command to an Emacs buffer). For this reason, you can use =eshell= on any system that is able to run Emacs, as there is no external dependency.

In fact, some of those commands are reimplemented in Emacs Lisp (/e.g./ =cat=), some of them are using the Emacs tools (for example =grep=), and unknown commands are passed to the /real/ commandline.

A more in-depth guide can be found [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][here]].

We install a few packages which make eshell easier to use.

#+BEGIN_SRC emacs-lisp
;; eshell

(setq eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t)

(use-package eshell-did-you-mean
  :commands eshell
  :config (eshell-did-you-mean-setup))

(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+END_SRC

* Additional resources

You might want to install some interesting new packages that are not already loaded in this configuration file.

Because there exist many Emacs packages, it might be frightening or even overwhelming to search for other packages that you could benefit from.

In order to solve this issue, [[https://github.com/emacs-tw/awesome-emacs][awesome-emacs]] is a place where you can start this research.

It references a lot of useful packages, some of which are already installed with this configuration file.

If you are a beginner, it also includes a list of tutorials or extra-sources for you to learn about Emacs and Emacs Lisp in general.

** Other configuration files

You can also take a look at other people [[https://github.com/grettke/every-emacs-initialization-file][configuration files]] to get an idea on how to write your own elisp code, what packages do other people use, and so much more.

Be careful though, some of these files are several thousands lines long !

Some other interesting ones:

- [[https://ladicle.com/post/config/][Ladicle's]] configuration file
  
* TODO
- [X] Hydra ! Install it, define some useful hydras (buffers, org-mode, dired ...), bind it to lsp-mode/ivy/projectile ...
  - [X] Install
  - [X] Modify hydras from the wiki
  - [X] Define some new hydras
- [ ] Do things for other popular languages (Java and C# come to mind).
  - [ ] Setup C# with LSP-mode
  - [ ] Setup Java with LSP-mode
  - [ ] Give a try to [[https://github.com/joaotavora/eglot][eglot]]
- [-] System stuff: =Tramp=, configure =eshell= or find an even better one, configure =dired= or upgrade it, etc
  - [X] =eshell= Basic improvements
  - [ ] Tramp explanation and configuration
  - [ ] Dired improvement
- [ ] Configure a Emacs-Lisp (and potentially Common Lisp ?) development environment.
  - [X ] Install and configure SLIME (Used SLY instead)
- [ ] Point to funny/absurd packages (/e.g./ =speed-type=, =key-quiz= ...)
- [ ] Regexp with [[https://github.com/joddie/pcre2el][pcre2el]] and may be other packages.
- [ ] Configure a web browser
