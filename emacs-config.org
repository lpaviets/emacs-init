#+title: Emacs Configuration
#+author: LÃ©o Paviet Salomon
#+STARTUP: content
#+PROPERTY: header-args:emacs-lisp :tangle (concat user-emacs-directory "init.el")

* Organization of this file

This file contains a Emacs configuration, written in a Org Mode document. It is largely based on [[https://github.com/daviwil/emacs-from-scratch/][Emacs From Scratch]].

It is able to automatically generate a init.el file, loaded by Emacs at startup.

If this file is on the path "~/.emacs.d/emacs-config.org" then it will automatically generate an output. To modify this behaviour, see the "Org Mode/Auto-tangle configuration files" subsection and modify it as you need.

If this file is named differently on your system, or simply located in another directory, you can still generate an output without changing anything by invoking the =org-babel-tangle= command (=C-c C-v t=).

Because I use a version system on those files, I don't mind conflicts with the currently loaded configuration file, and so the the generated file is actually called  =init.el=. By default, Emacs reads (and loads) file such as "~/.emacs" or "~/.emacs.d/init.el" at startup, so the output of =org-babel-tangle= is automatically replacing the previous configuration file. If you want to avoid those conflicts, you might need to rename it.

To modify the name of the output, you can change it in the second line of this document, after the =:tangle= keyword. In this case, I do not hardcode it in this file, and let Emacs decide what the /actual/ emacs-directory is. Indeed, you might want to have your configuration in a different location than =~/.emacs.d=, and as such, nothing is broken !

Some commands have to be run manually whenever the generated =init.el= file is loaded for the first time.

Whenever this is the case, it is explicitly signaled by the presence of the *MANUAL* keyword in front of those commands.

If the init.el cannot be properly loaded at startup, try to search for such keywords in this file and execute the corresponding commands.

* Initialization
** Emacs performance

First, we set things up so that Emacs starts /fast/ (and also with the frame maximized)

#+begin_src emacs-lisp
  (set-frame-parameter nil 'fullscreen 'maximized)
  (setq gc-cons-threshold 100000000) ; 1e8 = 100 MB (default: 800kB)
#+end_src

Another thing that might be of interest is to know how long it took for Emacs to start. Although there is already a built-in function to do this (try to call =emacs-init-time= in any Emacs session), we want it to be automatically displayed anytime we start Emacs

#+begin_src emacs-lisp
  (defun lps/display-startup-time ()
    (message "Emacs started in %s seconds"
             (format "%.2f"
                     (float-time
                      (time-subtract after-init-time before-init-time)))))

  (defun lps/display-garbage-collection ()
    (message "Emacs performed %d garbage collection"
             gcs-done))

  (defun lps/restore-gc-cons ()
    ;; After startup, we restore gc-cons-threshold to a more reasonable value
    (setq gc-cons-threshold 10000000)) ; 1e7 = 10 MB

  (setq read-process-output-max (* 8 1024 1024)) ;; 2mb

  (add-hook 'emacs-startup-hook #'lps/display-startup-time)
  (add-hook 'emacs-startup-hook #'lps/display-garbage-collection)
  (add-hook 'emacs-startup-hook #'lps/restore-gc-cons)

#+end_src

** Package management

Then, we need to configure how we will install packages. We use another package manager that the default one: =use-package=.

It makes both installation and customization easier, and the code is also simpler to read.

*MANUAL* You might want to configure =use-package= differently, as it is the tool used everywhere else in this configuration file to install and setup other packages. For example, the line
=(setq use-package-always-ensure t)= is used to install all the packages mentioned in this file automatically if you do not already have them. Depending on your environment, you might want to consider another, more appropriate behaviour (/e.g./  if you lack space, time, if you use another OS, if you are already compiling some of those packages by yourself, and so on).

#+begin_src emacs-lisp
  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/")))

  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))

  (setq package-native-compile t)

  ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; Symlink (or directly place) your personal packages in this directory.
  ;; Simple way to add personal packages
  ;; Need to use `update-file-autoloads' or `update-directory-autoloads' in this dir
  ;; regularly and place the autoloads in the personal-autoloads.el file
  (let* ((extra-package-dir (concat (expand-file-name user-emacs-directory)
                                   "extra-packages"))
         (extra-autoloads (concat extra-package-dir "/personal-autoloads.el")))
    (add-to-list 'load-path extra-package-dir)
    (when (file-exists-p extra-autoloads)
      (load extra-autoloads)))

  (require 'use-package)
  ;; Comment this line if you don't want to automatically install
  ;; all the packages that you are missing
  ;; (setq use-package-always-ensure t)
  ;; Uncomment the folllowing line to have a detailed startup log
  ;; (setq use-package-verbose t)

#+end_src

In order to benchmark the package loading, we use [[https://github.com/dholm/benchmark-init-el][benchmark-init.el]]

#+begin_src emacs-lisp
  (use-package benchmark-init
    :disabled t
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+end_src

Because we will customize bindings, functions and so on, some variables are defined there so they are available in the following sections of this file.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    (defvar lps/quick-edit-map (make-sparse-keymap))
    (defvar lps/system-tools-map (make-sparse-keymap))
    (defvar lps/all-hydras-map (make-sparse-keymap))
    (defvar lps/manipulate-lines-map (make-sparse-keymap)))
#+end_src

We finally add a few bindings to manage our packages more efficiently.

#+begin_src emacs-lisp
  (use-package package
    :ensure nil
    :bind-keymap
    ("C-c s" . lps/system-tools-map)
    :bind
    (:map lps/system-tools-map
          ("P i" . package-install)
          ("P l" . package-list-packages)))
#+end_src

** Security

Emacs is not very secure as such. We try to fix this as best as we can.

We explicitly fix how long passwords should be cached. A clever thing could be to distinguish between different environments, and use different values for /e.g./ the computer you use at work vs other computers. Another idea could be to ask the user if he wants his password to be cached for the current session, and if so, for how long.

*MANUAL* In order to allow GPG passwords to be asked in the minibuffer, you need to add the line =allow-emacs-pinentry= to your =gpg-agent.conf= file, usually located in the =~/.gnupg/= directory on Linux.

#+begin_src emacs-lisp
  (use-package password-cache
    :ensure nil
    :custom
    (password-cache t)
    (password-cache-expiry 300))

  (use-package pinentry
    :custom
    (epg-pinentry-mode 'loopback)
    :config
    (pinentry-start))

  (use-package auth-source
    :ensure nil
    :custom
    (auth-sources (remove "~/.authinfo" auth-sources))
    (auth-source-cache-expiry 86400);; All day

    :config
    (defvar lps/--auth-cache-expiry-setup-p nil)

    (defun lps/auth-source-define-cache-expiry ()
      (interactive)
      (unless lps/--auth-cache-expiry-setup-p
        (setq lps/--auth-cache-expiry-setup-p t)
        (when (y-or-n-p (concat "Change default auth-cache-expiry value "
                                "(default "
                                (number-to-string auth-source-cache-expiry)
                                ") ?"))
          (setq auth-source-cache-expiry (read-number "New cache expiry value in seconds: " auth-source-cache-expiry)))))

    (defun lps/force-forget-all-passwords ()
      (interactive)
      (auth-source-forget-all-cached)
      (shell-command "gpgconf --kill gpg-agent")
      ;; (shell-command "gpgconf -- reload gpg-agent")
      (setq lps/--auth-cache-expiry-setup-p nil))

    (add-hook 'kill-emacs-hook #'lps/force-forget-all-passwords))
#+end_src

** Quick restart

In order to test things more rapidly and to be able to apply configuration changes without ever leaving Emacs, we also install another package to restart Emacs with a simple command.

#+begin_src emacs-lisp
  (use-package restart-emacs
    :commands
    (restart-emacs restart-emacs-start-new-emacs)
    :bind
    (:map lps/system-tools-map
          ("r" . restart-emacs)))
#+end_src

** Custom file

We do not want Emacs to mess with our own =init.el= file, and so we tell it where to store all its precious customizations

#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom-file.el"))
  (load custom-file 'noerror)
#+end_src

** Byte- and native compilation

In this section, we configure how Emacs byte-compiles and/or natively compiles the source code of packages that we install.

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (native-comp-async-report-warnings-errors 'silent))
#+end_src

* UI Configuration
** Visual interface changes

We remove all the unnecessary elements from the interface, /e.g./ menus, scroll bar and so on.

You can remove or partially modify this block of code if you are a beginner and want to keep some of elements available, especially to be able to navigate with the mouse.

All the variable names are pretty explicit, so you should be able to customize this to your taste easily.

*** Startup

Who wants to be told the same thing over and over again each time they start Emacs ?
#+begin_src emacs-lisp
  ;; Disable the annoying startup message and Emacs logo
  (setq inhibit-startup-message t)

  ;; Disable the message on top of the Scratch buffer
  (setq initial-scratch-message nil)
#+end_src

However, we would like to see Emacs in full-screen if we are to use it

#+begin_src emacs-lisp
  ;; Maximize the Emacs frame at startup
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

We also don't want Emacs to be flashing and beeping at us whenver we do something wrong. Be quiet, please, error /messages/ are fine without VFX on top of them !

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
  (setq visible-bell nil)
#+end_src

*** Menus and toolbars

Emacs is very much keyboard-oriented. As such, we have little-to-no use of the various menus, toolbars and scrollbars that Emacs provides.

#+begin_src emacs-lisp
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)          ; Disable the menu bar
#+end_src

*** Lines and columns

Because we now have plenty of free space on our screen, we can sacrifice a bit of it to put useful information there, such as line numbers. We also want to see the current line and column in the modeline, and while we are at it, we also want Emacs to wrap our lines, so that we never have to scroll horizontally to see the end of a long line (besides, how would we do it, now that we don't have a scrollbar anymore ?!)

#+begin_src emacs-lisp
  ;; Line/column numbering modes

  (use-package emacs
    :init
    (column-number-mode t)
    (global-visual-line-mode 1)
    :hook
    ((prog-mode LaTeX-mode) . display-line-numbers-mode))
#+end_src

*** Theme

This is simply a way to change how Emacs looks. Some themes are more complete than other (they will modify how other packages look, like Magit, or even the minibuffer)

#+begin_src emacs-lisp
  ;; Themes
  (use-package solarized-theme)

  (use-package kaolin-themes
    :custom
    (kaolin-themes-comments-style 'alt)
    (kaolin-themes-distinct-parentheses t)
    (kaolin-themes-italic-comments t)
    (kaolin-themes-hl-line-colored t))

  (use-package modus-themes)

  (use-package doom-themes)

  (defvar lps/default-theme 'kaolin-ocean)
  (defvar lps/default-light-theme 'modus-operandi)
  (defvar lps/live-presentation-p nil)

  (load-theme lps/default-theme t)

  (let ((custom--inhibit-theme-enable nil))
    (custom-theme-set-faces
     lps/default-theme
     '(hl-line ((t (:background "#39424D"))) t)))

  (defun lps/toggle-live-code-presentation-settings ()
    "Various useful settings for live coding sessions
  Still very buggy, but this should not matter in a live presentation
  setting.
  Avoid toggling several times, just use it once if possible"
    (interactive)
    (if lps/live-presentation-p
        (progn
          (unless (equal custom-enabled-themes (list lps/default-theme))
            (disable-theme (car custom-enabled-themes))
            (load-theme lps/default-theme t))
          (global-hl-line-mode -1)
          (text-scale-set 0)
          (setq-default cursor-type 'box))

      (progn
        (unless (y-or-n-p "Keep current theme ?")
          (disable-theme custom-enabled-themes)
          (load-theme lps/default-light-theme t)
          (custom-theme-set-faces
           lps/default-light-theme
           '(hl-line ((t (:background "#DFD8EE"))) t)))
        (global-display-line-numbers-mode 1)
        (global-hl-line-mode 1)
        (text-scale-increase 2)
        (setq-default cursor-type 'bar)))

    (setq lps/live-presentation-p (not lps/live-presentation-p)))
#+end_src

There used to be a package called [[https://github.com/toroidal-code/cycle-themes.el][cycle-themes]] that would allow you to cycle through all (or a predefined list of) your themes, but it seems that it no longer works due to some other packages becoming deprecated. Here is a small function that does the same thing.

#+begin_src emacs-lisp
  ;; Use this to store your favourite themes
  ;; Save your usual, default theme in first position
  ;; so that you can easily switch back to it with
  (setq lps/rotate-themes-list
        '(doom-Iosvkem
          kaolin-ocean
          kaolin-aurora
          doom-palenight
          tsdh-dark
          solarized-dark
          modus-vivendi))

  ;; Try to save the current theme
  ;; Be careful ! Some visual changes are NOT stored in
  ;; a theme, and will not be retrieved by the restoring
  ;; functions. For example, any font configuration might
  ;; be "lost" for this session
  (setq lps/initial-enabled-themes custom-enabled-themes)

  (setq lps/rotate-theme-index 0)

  ;; Still a bit buggy: forgets all the customizations done to e.g. Org Mode
  (defun lps/rotate-through-themes ()
    "Cycles through the next theme in the `lps/rotate-themes-list'.
  If this list is empty or does not exist, cycle through all the
  installed themes instead."
    (interactive)
    (mapc #'disable-theme lps/initial-enabled-themes)
    (let* ((themes-list (or (and (boundp 'lps/rotate-themes-list) lps/rotate-themes-list)
                            (custom-available-themes)))
           (next-index (mod (+ lps/rotate-theme-index 1) (length themes-list)))
           (current-theme (nth lps/rotate-theme-index themes-list))
           (next-theme (nth next-index themes-list)))
      (setq lps/rotate-theme-index next-index)
      (disable-theme current-theme)
      (load-theme next-theme t)))

  (defun lps/restore-initial-themes ()
    (interactive)
    (mapc #'disable-theme custom-enabled-themes)
    (mapc (lambda (theme) (funcall #'load-theme theme t)) lps/initial-enabled-themes)
    (when (eq major-mode 'org-mode)
      (lps/org-mode-setup)
      (font-lock-update)))
#+end_src

*** Modeline and icons

This modifies how the [[https://www.emacswiki.org/emacs/ModeLine][modeline]] looks.

*MANUAL* If this is your first time running the init.el file, please run the following command:

=M-x all-the-icons-install-fonts=

#+begin_src emacs-lisp
  ;; First time used: run M-x all-the-icons-install-fonts
  (use-package all-the-icons
    :config
    ;; Avoid unnecessary warnings
    (declare-function all-the-icons-faicon 'all-the-icons)
    (declare-function all-the-icons-fileicon 'all-the-icons)
    (declare-function all-the-icons-material 'all-the-icons)
    (declare-function all-the-icons-octicon 'all-the-icons)

    ;;define an icon function with all-the-icons-faicon
    ;;to use filecon, etc, define same function with icon set
    (defun with-faicon (icon str &rest height v-adjust)
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))
    ;; filecon
    (defun with-fileicon (icon str &rest height v-adjust)
      (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))

  (use-package doom-modeline
    :after all-the-icons
    :init
    (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 15)
    (doom-modeline-project-detection 'project)
    (doom-modeline-unicode-fallback t)
    (doom-modeline-buffer-file-name-style 'buffer-name)
    (doom-modeline-mu4e t)
    (mode-line-compact 'long)
    :config
    ;; Hide encoding in modeline when UTF-8(-unix)
    (defun lps/hide-utf-8-encoding ()
      (setq-local doom-modeline-buffer-encoding
                  (not (or (eq buffer-file-coding-system 'utf-8-unix)
                           (eq buffer-file-coding-system 'utf-8)))))

    (add-hook 'after-change-major-mode-hook #'lps/hide-utf-8-encoding)

    ;; Add recursive-depth info to the mode line
    ;; Useful for e.g. Isearch sessions
    (let ((rec-depth-indicator '(:eval
                                 (let ((rec-depth (recursion-depth)))
                                   (unless (zerop rec-depth)
                                     (propertize (format "[%d] " rec-depth)
                                                 'face
                                                 '(:foreground "orange red")))))))
      (unless (and (listp global-mode-string)
                   (member rec-depth-indicator global-mode-string))
        (push rec-depth-indicator global-mode-string)))

    ;; Hack, as we disable minor modes in mode-line
    ;; Put this in global-mode-string, where it definitely does not belong ...
    (cl-pushnew '(:eval
                  (when (bound-and-true-p company-search-mode)
                    company-search-lighter))
                global-mode-string
                :test 'equal))
#+end_src

We also want to add some extra information on the modeline, of the kind that we could get in a status bar from a typical window manager

#+begin_src emacs-lisp
  (use-package battery
    :ensure nil
    :init
    (display-battery-mode 1))

  (use-package time
    :ensure nil
    :custom
    (display-time-24hr-format t)
    (display-time-format "[%H:%M]")
    :init
    (display-time-mode 1))
#+end_src

*** Extra packages

Some packages are used lated in the configuration, and we want to be able to use those comfortable modes.

#+begin_src emacs-lisp
  ;; Generic UI modes

  (use-package beacon
    :custom
    (beacon-blink-when-point-moves-vertically 30)
    (beacon-size 20)
    :init (beacon-mode))
  (use-package rainbow-mode
    :defer t)
  (use-package fill-column-indicator
    :defer t)
  (use-package visual-fill-column
    :defer t)
  (use-package highlight-numbers
    :hook (prog-mode . highlight-numbers-mode))
#+end_src

** Whitespaces

First of all, we never want ~TAB~ to insert actual tab characters. We also don't like trailing whitespaces, so we delete them automatically when we save a buffer.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :hook (before-save . delete-trailing-whitespace)
    :init
    ;; Tab behaviour and whitespaces
    (setq-default indent-tabs-mode nil)
    (setq-default tab-width 4)
    :bind
    (:map lps/quick-edit-map
          ("DEL" . cycle-spacing)
          ("<C-backspace>" . join-line)
          ("<C-S-backspace>" . join-next-line))
    :config
    (defun join-next-line (&optional beg end)
      (interactive
       (progn (barf-if-buffer-read-only)
              (and (use-region-p)
                   (list (region-beginning) (region-end)))))
      (join-line t beg end)))
#+end_src

Then, we do not want to repeatedly spam the ~DEL~ key in order to delete a long sequence of whitespaces.

#+begin_src emacs-lisp
  (use-package hungry-delete
    :defer t
    :init
    ;; (global-hungry-delete-mode 1)
    (setq hungry-delete-join-reluctantly t))
#+end_src

** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] is a package that is used to group several related commands into a family of bindings, all starting with the same prefix (= "hydra"). Whenever this common prefix is entered in a suitable mode, a panel shows up, showing all the user-defined commands that can now be invoked with a single keystroke instead of repeatedly using the same long prefix.

#+begin_src emacs-lisp
  (use-package hydra
    :defer t
    :bind-keymap ("C-c h" . lps/all-hydras-map))
#+end_src

All the hydras will now be defined after the package to which they correspond, or in the appropriate section. Most of them are modifications of hydras that can be found on the [[https://github.com/abo-abo/hydra/wiki][hydra wiki]].

Some hydras will be called less frequently and for other purposes than getting a "quick-and-dirty" access to commonly used functions. Hence, we will make them prettier (the compromise being that they are less minimalistic and take much more space visually)

*MANUAL* This is not a MELPA package. It can be found [[https://github.com/Ladicle/hydra-posframe][here]]. Install it and change the loading path according to your configuration.

#+begin_src emacs-lisp
  ;; Easier hydra definition
  (use-package pretty-hydra
    :after hydra)
#+end_src
** Interactively change the UI

This is one moment where a pretty hydra could help us change general UI parameters, such as the text size, some highlighting options and so on.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :after pretty-hydra
    :bind (:map lps/all-hydras-map
                ("a" . hydra-appearance/body))
    :config
    ;; define a title function
    (defvar appearance-title (with-faicon "desktop" "Appearance"))

    ;; generate hydra

    (pretty-hydra-define hydra-appearance (:title appearance-title
                                                  :quit-key "q")
      ("Theme"
       (
        ;;     ("o" olivetti-mode "Olivetti" :toggle t)
        ;;     ("t" toggle-window-transparency "Transparency" :toggle t )
        ("c" lps/rotate-through-themes "Cycle Themes" )
        ("t" lps/restore-initial-themes "Restore Theme")
        ("+" text-scale-increase "Zoom In")
        ("-" text-scale-decrease "Zoom Out")
        ("x" toggle-frame-maximized "Maximize Frame" :toggle t )
        ("X" toggle-frame-fullscreen "Fullscreen Frame" :toggle t))
       "Highlighting"
       (("d" rainbow-delimiters-mode "Rainbow Delimiters" :toggle t )
        ("r" rainbow-mode "Show Hex Colours" :toggle t )
        ("n" highlight-numbers-mode "Highlight Code Numbers" :toggle t )
        ("l" display-line-numbers-mode "Show Line Numbers" :toggle t )
        ("_" global-hl-line-mode "Highlight Current Line" :toggle t )
        ;;    ("I" rainbow-identifiers-mode "Rainbow Identifiers" :toggle t )
        ("b" beacon-mode "Show Cursor Trailer" :toggle t )
        ("w" whitespace-mode "Show Whitespaces" :toggle t))
       "Miscellaneous"
       (("j" visual-line-mode "Wrap Line Window"  :toggle t)
        ("m" visual-fill-column-mode "Wrap Line Column"  :toggle t)
        ;;    ("a" adaptive-wrap-prefix-mode "Indent Wrapped Lines" :toggle t )
        ;;   ("i" highlight-indent-guides-mode  "Show Indent Guides" :toggle t )
        ("g" fci-mode "Show Fill Column" :toggle t )
        ("<SPC>" nil "Quit" :color blue )))))
#+end_src

** Font and encoding

Even if most of the time, you should be working with UTF-8, we still want to make sure that this is the default and that Emacs assumes that we are using UTF-8

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-clipboard-coding-system 'utf-8)
  (set-file-name-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src

Another thing that is technically more a stylistic choice rather than a real encoding problem is how dates are formatted. I decide to use the European style

#+begin_src emacs-lisp
  (use-package calendar
    :ensure nil
    :config
    (calendar-set-date-style 'european))
#+end_src

Finally, as I am mostly using a French, AZERTY keyboard, some combinations are hard to input, /e.g./ everything of the form =C-^= or =M-~=. Indeed, those are dead keys, and cannot really be pressed at the same time than a modifier key. Hence, we simply "remap" (using translation maps, see the [[info:elisp#Translation Keymaps][manual]] !)

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (define-key key-translation-map (kbd "<C-dead-circumflex>") (kbd "C-^"))
    (define-key key-translation-map (kbd "<M-dead-circumflex>") (kbd "M-^")))
#+end_src

** Minibuffer
*** Generic tweaks
First of all, some configuration to make all the minibuffer sessions more pleasant, regardless of the completion or narrowing system used.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (enable-recursive-minibuffers t)
    :bind
    ("s-g" . exit-recursive-edit)
    :config
    (minibuffer-depth-indicate-mode 1))
#+end_src

*** Ivy/Swiper/Counsel

Although emacs provides a number of commands to navigate within a file, to find documentation and so on, the following packages will make the general UI easier to use.

[[https://github.com/abo-abo/swiper][Ivy and Counsel]] are completion and narrowing frameworks that allow you to use the minibuffer more comfortably.

#+begin_src emacs-lisp
  ;; Ivy
  (use-package ivy
    :diminish
    :disabled t
    :init
    (setq completing-read-function 'ivy-completing-read)
    :bind (("C-s" . swiper)
           :map swiper-map
           ("M-g" . swiper-avy)
           :map ivy-minibuffer-map
           ("TAB" . ivy-partial-or-done)
           ("C-l" . ivy-immediate-done)
           ("C-SPC" . lps/ivy-toggle-current-mark)
           ("<mouse-3>" . nil)
           ("<mouse-1>" . nil)
           ("<down-mouse-1>" . nil))
    :custom
    (ivy-count-format "(%d/%d)")
    (ivy-initial-inputs-alist nil)
    (ivy-extra-directories nil)

    :config
    (ivy-mode 1)

    (defun lps/ivy-toggle-current-mark ()
      (interactive)
      "Toggle mark for current candidate and move forwards."
      (if (ivy--marked-p)
          (ivy-unmark)
        (ivy-mark))))

  (use-package ivy-hydra
    :after ivy
    :defer t)

  ;; Adds things to Ivy
  (use-package ivy-rich
    :after ivy
    :init (ivy-rich-mode 1))

  ;; Counsel. Adds things to Ivy
  (use-package counsel
    :diminish
    :disabled t
    :after ivy
    :hook (ivy-mode . counsel-mode)
    :custom (counsel-find-file-at-point t)
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-switch-buffer) ;; counsel-ibuffer is a fancier option
           ("C-x C-f" . counsel-find-file)
           ("C-c i" . counsel-imenu)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history)))

#+end_src

*** Vertico/Marginalia
~ivy~ is a fantastic addition to Emacs, and it makes interacting with Emacs much more comfortable, be it for invoking commands or looking for function documentation, or quickly interacting with files without having to use a Dired buffer.
However, it is /bloated/, and can feel slow at times. Moreover, if you only really use some of its functionalities, it can feel a bit overwhelming, and not worth the trouble of configuring everything.

For this reason, we might want to take a look at some lightweight alternatives, built on top of the default completion/narrowing tools that Emacs provide, instead of using ~ivy~ or ~helm~ which use their own massive framework.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode)
    :bind
    (:map vertico-map
          ("<C-backspace>" . lps/minibuffer-go-up-directory))
    :config
    (defun lps/minibuffer-go-up-directory (arg)
      (interactive "p")
      (let* ((filename (minibuffer-contents))
             (directory-maybe (file-name-directory filename))
             (directory (if (and (string-suffix-p "/" filename)
                                 (equal filename directory-maybe))
                            (file-name-directory (substring filename 0 -1))
                          directory-maybe)))
        (if directory
            (progn
              (delete-minibuffer-contents)
              (insert directory))
          (backward-kill-word arg)))))
#+end_src

Emacs uses metadata to differentiate between several types of things for completion. For example, when using ~find-file~, Emacs attachs to each suggestion a bit of data to tell that they are actually files.

In order to add more information of this kind to those suggestions, and to interact with it more naturally, we use another package which integrates very well with ~vertico~

#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :config
    (marginalia-mode))
#+end_src

** Buffer and windows
*** Buffer management
Emacs is sometimes all over the place, opening buffers at seemingly random places, switching your focus only in some circumstances ... We will customize this behaviour so that we have a better control on what Emacs is doing when we open new buffers

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ("s-k" . kill-this-buffer)
    :init
    ;; Automatically reload a file if it has been modified
    (global-auto-revert-mode t)

    :custom
    (display-buffer-base-action
     '((display-buffer-reuse-window)
       (display-buffer-reuse-mode-window)
       (display-buffer-same-window)
       (display-buffer-in-previous-window)))

    :config

    ;; Display all the "help" buffers in the same window
    (defvar lps/help-modes '(helpful-mode
                             help-mode
                             Man-mode
                             apropos-mode
                             Info-mode))

    ;; Help buffers with special name
    (defvar lps/help-buffers nil)

    (defun lps/buffer-help-p (buffer action)
      "Return t if BUFFER is an help buffer, nil otherwise"
      (or (member (buffer-local-value 'major-mode (get-buffer buffer))
                  lps/help-modes)
          (member (if (stringp buffer)
                      buffer
                    (buffer-name buffer))
                  lps/help-buffers)))

    (add-to-list 'display-buffer-alist
                 `(lps/buffer-help-p
                   (display-buffer--maybe-same-window
                    display-buffer-reuse-window
                    display-buffer-reuse-mode-window)
                   (mode . ,lps/help-modes)
                   (inhibit-same-window . nil)
                   (quit-restore ('window 'window nil nil)))))
#+end_src

Another annoying thing is that we tend to have /a lot/ of open buffers at the same time, and there will invariably be some conflicts in their names. We want to be able to quickly distinguish which file is buffer is visiting.

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-after-kill-buffer-p t)
#+end_src

We also improve the appearance (and functionalities) of the buffer that we get when we want to list all the buffers that are currently opened.

#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :after ibuffer
    :init (all-the-icons-ibuffer-mode 1))

  (use-package ibuffer
    :defer t
    :bind ("C-x C-b" . ibuffer)
    :custom
    (ibuffer-saved-filter-groups
     '(("default"
        ("Dired" (mode . dired-mode))
        ("Emacs" (or
                  (name . "^\\*scratch\\*$")
                  (name . "^\\*Messages\\*$")))
        ("Help" (or
                 (mode . helpful-mode)
                 (mode . Info-mode)
                 (mode . help-mode)))
        ("Special" (or
                    (name . "^\\*.*\\*$")
                    (mode . special-mode)))
        ("Images/PDF" (or
                       (file-extension . "pdf")
                       (mode . image-mode)))
        ("Programming" (and
                        (derived-mode . prog-mode)
                        (not (mode . fundamental-mode)))))))
    :config
    (add-to-list 'ibuffer-help-buffer-modes 'helpful-mode)

    (defun lps/ibuffer-switch-to-default-filter ()
      (ibuffer-switch-to-saved-filter-groups "default"))

    (add-hook 'ibuffer-mode-hook #'lps/ibuffer-switch-to-default-filter))

#+end_src

A cool function to rename both a buffer and the file that it is visiting, while being careful e.g. not to override anything

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    ;; From Magnars, from emacsrocks.com
    (defun lps/rename-current-buffer-file ()
      "Renames current buffer and file it is visiting."
      (interactive)
      (let* ((name (buffer-name))
             (filename (buffer-file-name))
             (basename (file-name-nondirectory filename)))
        (if (not (and filename (file-exists-p filename)))
            (error "Buffer '%s' is not visiting a file!" name)
          (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
            (if (get-buffer new-name)
                (error "A buffer named '%s' already exists!" new-name)
              (rename-file filename new-name 1)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)
              (message "File '%s' successfully renamed to '%s'"
                       name (file-name-nondirectory new-name)))))))
    :bind
    (:map ctl-x-x-map
          ("R" . lps/rename-current-buffer-file)))
#+end_src

*** Window management

Because window management can be a bit tedious with the basic Emacs functionalities, we improve it a bit. First of all, we enable =winner-mode=, which allows us to "undo" and "redo" changes in the Windows' configuration.

#+begin_src emacs-lisp
  (use-package winner
    :commands (winner-undo winner-redo)
    :init
    (setq winner-boring-buffers '("*Completions*"
                                  "*Compile-Log*"
                                  "*Fuzzy Completions*"
                                  "*Apropos*"
                                  "*Help*"
                                  "*Buffer List*"
                                  "*Ibuffer*"))
    (winner-mode 1))

#+end_src

To facilitate window management, we use an hydra, binding most of the commands that we might ever need.

First of all, we use a few helper functions, defined in [[https://github.com/abo-abo/hydra/blob/master/hydra-examples.el][hydra-examples.el]]

#+begin_src emacs-lisp
  (use-package windmove
    ;; Make windmove work in Org mode:
    :hook
    (org-shiftup-final . windmove-up)
    (org-shiftleft-final . windmove-left)
    (org-shiftdown-final . windmove-down)
    (org-shiftright-final . windmove-right)

    :init
    (windmove-default-keybindings 'shift)
    (windmove-swap-states-default-keybindings '(ctrl shift))

    :config
    (defun hydra-move-splitter-left (arg)
      "Move window splitter left."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (shrink-window-horizontally arg)
        (enlarge-window-horizontally arg)))

    (defun hydra-move-splitter-right (arg)
      "Move window splitter right."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (enlarge-window-horizontally arg)
        (shrink-window-horizontally arg)))

    (defun hydra-move-splitter-up (arg)
      "Move window splitter up."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (enlarge-window arg)
        (shrink-window arg)))

    (defun hydra-move-splitter-down (arg)
      "Move window splitter down."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (shrink-window arg)
        (enlarge-window arg))))
#+end_src

Now, we wrap everything up into a nice hydra

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind (:map lps/all-hydras-map
                ("w" . hydra-window/body))

    :init
    (defhydra hydra-window (:color red
                                   :hint nil)
     "
      ^Focus^           ^Resize^       ^Split^                 ^Delete^          ^Other
      ^^^^^^^^^-------------------------------------------------------------------------------
      _b_move left      _B_left        _V_split-vert-move      _o_del-other      _c_new-frame
      _n_move down      _N_down        _H_split-horiz-move     _da_ace-del       _u_winner-undo
      _p_move up        _P_up          _v_split-vert           _dw_del-window    _r_winner-redo
      _f_move right     _F_right       _h_split-horiz          _df_del-frame
      _q_uit
      "
     ;; Move the focus around
     ("b" windmove-left)
     ("n" windmove-down)
     ("p" windmove-up)
     ("f" windmove-right)

     ;; Changes the size of the current window
     ("B" hydra-move-splitter-left)
     ("N" hydra-move-splitter-down)
     ("P" hydra-move-splitter-up)
     ("F" hydra-move-splitter-right)

     ;; Split and move (or not)
     ("V" (lambda ()
            (interactive)
            (split-window-right)
            (windmove-right)))
     ("H" (lambda ()
            (interactive)
            (split-window-below)
            (windmove-down)))
     ("v" split-window-right)
     ("h" split-window-below)

     ;; winner-mode must be enabled
     ("u" winner-undo)
     ("r" winner-redo) ;;Fixme, not working?

     ;; Delete windows
     ("o" delete-other-windows :exit t)
     ("da" ace-delete-window)
     ("dw" delete-window)
     ("db" kill-this-buffer)
     ("df" delete-frame :exit t)

     ;; Other stuff
     ("a" ace-window :exit t)
     ("c" make-frame :exit t)
     ("s" ace-swap-window)
     ("q" nil)))
#+end_src

Sometimes, we also want some very specific buffer to be associated to a certain window. As there is probably no general rule that would decide this for us, it is not possible to modify ~display-buffer-alist~ or other similar variables to get the desired behaviour. Hence, we will simply create a function that binds - or unbinds - the current buffer to the current window.

#+begin_src emacs-lisp
  ;; Taken from https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows

  (defun lps/toggle-window-dedicated ()
    "Control whether or not Emacs is allowed to display another
  buffer in current window."
    (interactive)
    (message
     (if (let (window (get-buffer-window (current-buffer)))
           (set-window-dedicated-p window (not (window-dedicated-p window))))
         "%s: Can't touch this!"
       "%s is up for grabs.")
     (current-buffer)))

  (global-set-key (kbd "C-c t") 'lps/toggle-window-dedicated)

#+end_src

** Outline and folding
Sometimes, when documents get bigger and bigger, it is useful to be able to temporarily hide stuff. The built-in ~narrow-to-\*~ commands can be useful to really focus on a part of the document, but we might want to be able to get a rough outline of the /whole/ document at any time, but in a less cluttered way.

#+begin_src emacs-lisp
  (use-package outline
    :ensure nil
    :defer t
    :custom
    (outline-minor-mode-prefix "\C-o")
    (outline-minor-mode-cycle t))
#+end_src

** Scroll
There are (obviously) many variables and functions controlling how scrolling works: amount of scroll, position of the point after a scroll, horizontal & vertical scrolls, and so on.
We use the keyboard even for scrolling, so we want to have the nicest possible experience for this. On the other hand, sometimes, the mouse wheel can still be pretty convenient, so it's good to have a way to customize its behaviour too.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (scroll-preserve-screen-position t)
    (mouse-wheel-tilt-scroll t))
#+end_src

** Help !
*** Improve default help
Emacs already has a /great/ documentation system, but it is still possible to improve it ! [[https://github.com/Wilfred/helpful][helpful]] makes things easier to remember and to use without having to search for documentation in multiple places.

It will condense all the available information about something within a single Help buffer, and will add some documentation to the commands you are currently typing.

#+begin_src emacs-lisp
  ;; Helpful. Extra documentation when calling for help
  (use-package helpful
    :custom
    (counsel-describe-symbol-function   #'helpful-symbol)
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-symbol]   . helpful-symbol)
    ([remap describe-key]      . helpful-key)
    ("C-h u"                   . helpful-at-point)) ;; Help "<u>nder" cursor

#+end_src

We can also improve some of the other help commands:

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (apropos-documentation-sort-by-scores t))
#+end_src
*** Which-key

Because there are a lot of similar commands, it is quite easy to get lost. [[https://github.com/justbur/emacs-which-key][which-key]] is a package that shows all the available commands after having typed some prefix, meaning that knowing the beginning of a key sequence is enough to get the rest of the information.

For example, if you press =C-c=, then a panel will appear at the bottom of the screen to show how you can currently continue this command, depending on which buffer you are in.


#+begin_src emacs-lisp
  ;; which-key. Shows all the available key sequences after a prefix
  (use-package which-key
    :init
    (which-key-mode 1)
    (which-key-setup-side-window-bottom) ;; default
    :diminish
    :custom
    (which-key-idle-delay 1)
    (which-key-idle-secondary-delay 0.05))
#+end_src

*** Help at point

By default, whenever you place your /mouse/ cursor over something - say, a hyperlink -, Emacs will display a help message in the echo area.
However, we tend not to use the mouse at all, and in particular having to use the mouse for help would feel a little bit "backwards" compared to Emacs' general philosophy.

#+begin_src emacs-lisp
  (use-package help-at-pt
    :ensure nil
    :custom
    (help-at-pt-display-when-idle t)
    (help-at-pt-timer-delay 0.5))
#+end_src

Finally, we use a custom function to look at the documentation of pretty much anything in a popup, rather than in a separate buffer.

#+begin_src emacs-lisp
  ;; Inspired from https://emacs.stackexchange.com/questions/2777/how-to-get-the-function-help-without-typing

  (use-package popup
    :init
    (defun lps/describe-thing-in-popup ()
      (interactive)
      (let* ((thing (symbol-at-point))
             (help-xref-following t)
             (description (save-window-excursion
                            (with-temp-buffer
                              (help-mode)
                              (help-xref-interned thing)
                              (buffer-string)))))
        (popup-tip description
                   :point (point)
                   :around t
                   :margin t
                   :height 20)))

    (global-set-key (kbd "C-&") #'lps/describe-thing-in-popup))
#+end_src

* Commands
** Disabled commands

We want to use the full Emacs power. However, if you find yourself using repeatedly a dangerous command by mistake, you might want to disable it

#+begin_src emacs-lisp
  ;; Don't disable any command
  ;; BE CAREFUL
  ;; If you are a new user, you might to comment out this line
  (setq disabled-command-function nil)

#+end_src

There is, however, one really annoying binding, especially for new users or people used to ... computers, calling the =suspend-frame= command. For people who are using it, do not worry, it is still available on =C-x C-z= anyway.

#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
#+end_src

** History
*** Prescient

There is a way to go even faster for completion. Indeed, when in doubt, why not suggest recent or popular completions ? That is exactly what ~prescient~ does, by sorting the suggestions according to their frequency or how recently we used them.

This goes beyond commands, but can also be used for any kind of documentation lookup, with =describe-function= or =describe-variable= for example.

#+begin_src emacs-lisp
  ;; Generic Prescient configuration
  (use-package prescient
    :custom
    (prescient-history-length 50)
    (prescient-sort-length-enable nil)
    :config
    (prescient-persist-mode 1))

  (use-package ivy-prescient
    :after ivy prescient
    :custom
    (ivy-prescient-retain-classic-highlighting t)
    :config
    (ivy-prescient-mode 1)
    (setq ivy-prescient-sort-commands
          (append ivy-prescient-sort-commands
                  '(counsel-minibuffer-history
                    counsel-shell-history
                    imenu
                    counsel-imenu))))
#+end_src

~prescient~ can also be used with completion frameworks such as ~company~

#+begin_src emacs-lisp
  (use-package company-prescient
    :after company
    :config
    (company-prescient-mode 1))
#+end_src

*** Other solutions

Another lighter and built-in solution is the simpler package ~savehist~. If you want to use a lighter Emacs version, or if for some reason you want to stay "as close to the original Emacs", this is a perfectly fine solution, and its major drawback is that it does not work for "in-buffer" auto-completions (although it might be possible with a lot of tuning ?)

#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))
#+end_src

** Command log mode

This mode allows you to display a small panel on the right of the screen which shows which keys you are pressing, and what commands they are associated to, all of this in real time !

As of now, you need to enable the mode by using the =command-log-mode= command (or =global-command-log-mode= if you want to record everything, in all the buffers of the current session), and to use the =C-c o= keybinding (which calls the =clm/toggle-command-log-buffer= function) to open a new buffer in which you will see both the keybindings you are currently using and the commands to which they are bound.

If you want =command-log-mode= to be activated by default in certain minor (or even major) modes, simply add a hook. You will still need to explicitly open the buffer, but this could also be dealt with by using other, straightforward hooks.

#+begin_src emacs-lisp
  (use-package command-log-mode
    :defer t)
#+end_src

** Confirmation

Typing "yes" and "no" might be a bit too tiring

#+begin_src emacs-lisp
  ;; Type "y" instead of "yes RET" for confirmation
  (if (version< emacs-version "28.0") ; ) parsing bug
      (defalias 'yes-or-no-p 'y-or-n-p)
    (setq use-short-answers t))
#+end_src

** Utilities
~consult~ provides a lot of useful commands that can be used during a minibuffer session to act on the selection. Moreover, it comes with various utilities, such as flavours of ~isearch~ or ~grep~.
#+begin_src emacs-lisp
  (use-package consult
    :defer t
    :bind
    ("C-S-s" . lps/consult-line-strict-match)
    ("C-c i" . lps/consult-imenu-or-org-heading)
    ("C-x b" . consult-buffer)
    :custom
    (consult-narrow-key "<")
    :config
    (defun lps/consult-imenu-or-org-heading ()
      (interactive)
      (if (equal major-mode 'org-mode)
          (consult-org-heading)
        (consult-imenu)))

    (defun lps/consult-line-strict-match (&optional initial start)
      (interactive (list nil (not (not current-prefix-arg))))
      (let ((orderless-matching-styles '(orderless-literal)))
        (consult-line initial start))))
#+end_src

Another package that tries to give contextual actions to act on "things" (files, buffers ...) is ~embark~. It also integrates very well with the default API, and is easily enhanced by packages such as ~marginalia~

#+begin_src emacs-lisp
  (use-package embark
    :defer t
    :bind
    ("C-," . embark-act)
    ("C-h b" . embark-bindings)
    (:map embark-file-map
          ("s" . lps/find-file-as-root))
    :custom
    (embark-action-indicator #'lps/embark-indicator-which-key)
    (embark-become-indicator embark-action-indicator)
    :config
    (defun lps/embark-indicator-which-key (map &rest _ignore)
      (which-key--show-keymap "Embark" map nil nil 'no-paging)
      #'which-key--hide-popup-ignore-command))

  (use-package embark-consult
    :after (consult embark))
#+end_src

** Some macros

In this section, we define some useful macros to write code in Emacs Lisp.

#+begin_src emacs-lisp
  ;; Macro to use "python-style" affectation in lexical bindings
  (defmacro multi-let (vars values body)
    "Binds each symbol of VARS to its corresponding expression in VALUES,
    in order.
    multi-let (a b) (e1 e2) body is thus equivalent to
    (let ((a e1)) (let ((b e2)) body))
    Expressions at position k in VALUES might depend on symbol from
    VARS at position strictly less than k, as with let*"
    (defun rec-expand-let (vars values body)
      (if (= (length vars) (length values))
          (if (and vars (symbolp (car vars)))
              `(let ((,(car vars) ,(car values)))
                 ,(rec-expand-let (cdr vars)
                                  (cdr values)
                                  body))
            body)
        (message
         (format "Trying to bind %d symbols to %d values"
                 (length vars)
                 (length values)))))

    (rec-expand-let vars values body))
#+end_src

** Some useful commands
*** Open file
We often want to visit links. If the point is on a file path, for example, it is often useful to be able to quicky navigate to this file.

#+begin_src emacs-lisp
  (use-package ffap
    :ensure nil
    :init
    (ffap-bindings)
    :custom
    (ffap-pass-wildcards-to-dired t)
    :config
    (defun lps/find-file-as-root (filename)
      "Switch to a buffer visiting the file FILENAME as root, creating one if none exists."
      (interactive "P")
      (find-file (concat "/sudo:root@localhost:" filename))))
#+end_src

*** Repeat commands
Some commands are usually invoked several times in succession. For example, if you wish to resize a window, you might need to invoke =shrink-window= several times.
If we need to define repeat maps, we will do it in the corresponding package rather than here.

#+begin_src emacs-lisp
  (when (version< "28.0" emacs-version)
    (use-package repeat
      :bind
      (:map lps/quick-edit-map
            ("z" . repeat))
      :init
      (repeat-mode 1)))
#+end_src

*** Remapping and better defaults
Several commands are, surprinsingly, bound by default to some binding, while there exists (arguably) simpler and more intuitive/DWIM-like versions of those same commands. Most of the time, we really want to use those simpler commands, and so we remap them to be invoked in place of their "strict" counterpart.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ([remap upcase-word] . upcase-dwim)
    ([remap downcase-word] . downcase-dwim)
    ([remap capitalize-word] . capitalize-dwim)
    ([remap count-words-region] . count-words)
    ([remap count-words-region] . count-words))
#+end_src

* Editing

   Emacs is fundamentally a text editor. It provides a lot of functions to deal with text, and a way to create macros, to automate things, to repeat something multiple times ... easily. However, because there are /so many/ available functions, we might need some help to navigate around and do fancy things.

** Multiple cursors

A first improvement is the addition of multiple cursors. The "rectangle region" already gives a way to insert text simultaneously at several places, and to perform some easy operations on a rectangular area, but the [[https://github.com/magnars/multiple-cursors.el][multiple cursor]] package really increases the possibilities.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :defer t
    :bind
    ("<C-S-mouse-1>" . mc/add-cursor-on-click)
    (:map lps/all-hydras-map
          ("M" . hydra-multiple-cursors/body))
    :config
    (pretty-hydra-define hydra-multiple-cursors (:title "Multiple cursors"
                                                        :quit-key "q")
      ("Add to region"
       (("l" mc/edit-lines "Edit lines in region" :exit t)
        ("b" mc/edit-beginnings-of-lines "Edit beginnings of lines in region" :exit t)
        ("e" mc/edit-ends-of-lines "Edit ends of lines in region" :exit t))
       "Mark same word (all)"
       (("a" mc/mark-all-like-this "Mark all like this" :exit t)
        ("S" mc/mark-all-symbols-like-this "Mark all symbols likes this" :exit t)
        ("w" mc/mark-all-words-like-this "Mark all words like this" :exit t)
        ("r" mc/mark-all-in-region "Mark all in region" :exit t)
        ("R" mc/mark-all-in-region-regexp "Mark all in region (regexp)" :exit t)
        ("d" mc/mark-all-dwim "Mark all dwim"))
       "Mark same word (next)"
       (("n" mc/mark-next-like-this "Mark next like this")
        ("N" mc/skip-to-next-like-this "Skip to next like this"))
       "Mark same word (previous)"
       (("p" mc/mark-previous-like-this "Mark previous like this")
        ("P" mc/skip-to-previous-like-this "Skip to previous like this"))
       "Unmark"
       (("M-n" mc/unmark-next-like-this "Unmark next like this")
        ("M-p" mc/unmark-previous-like-this "Unmark previous like this"))
       "More"
       (("M" mc/mark-more-like-this-extended "Mark like this interactively")
        ("C-n" mc/mark-next-lines "Mark next lines")
        ("C-p" mc/mark-previous-lines "Mark previous lines")))))
#+end_src

The webpage specifies that the commands provided by this package are best invoked when bound to key sequence rather than by =M-x <mc/command-name>=, although some testing on my part seems to show that it still works relatively well most of the time.
** Auto-completion

We fundamentally use Emacs to write text. What would writing be without some kind of auto-completion ? Hence, we use a few tools to make the general experience of /writing text/ better, whether it is source code, simple sentences or even commands in the minibuffer.

*** Completion styles

Emacs has a lot of built-in completions styles, telling it how to interpret the input: as a regexp, as initials, as a substring ... We add some other ones, and some possibilities to customize them or even change them on the fly. In order to separate how those styles work for in-buffer completion compared to their behaviour in minibuffer, we add hooks to the completion to change the completion styles on the fly.

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(basic partial-completion orderless))
    (completion-auto-help t)
    (orderless-component-separator #'orderless-escapable-split-on-space)
    (orderless-matching-styles '(orderless-literal orderless-regexp))
    (orderless-style-dispatchers '(lps/orderless-initialism-if-semicolon
                                   lps/orderless-substring-if-equal
                                   lps/orderless-flex-if-twiddle
                                   lps/orderless-without-if-bang))

    :config
    ;; From the Orderless package documentation
    (defun lps/orderless-flex-if-twiddle (pattern _index _total)
      "Use `orderless-flex' if the input starts with a ~"
      (if (string-prefix-p "~" pattern)
          `(orderless-flex . ,(substring pattern 1))

        (when (string-suffix-p "~" pattern)
          `(orderless-flex . ,(substring pattern 0 -1)))))

    (defun lps/orderless-substring-if-equal (pattern _index _total)
      "Use `orderless-literal' if the input starts with a ="
      (if (string-prefix-p "=" pattern)
          `(orderless-literal . ,(substring pattern 1))

        (when (string-suffix-p "=" pattern)
          `(orderless-literal . ,(substring pattern 0 -1)))))

    (defun lps/orderless-first-initialism (pattern index _total)
      "Use `orderless-initialism' for the first component"
      (if (= index 0) 'orderless-initialism))

    (defun lps/orderless-initialism-if-semicolon (pattern _index _total)
      "Use `orderless-initialism' if the input starts with a ;"
      (if (string-prefix-p ";" pattern)
          `(orderless-initialism . ,(substring pattern 1))

        (when (string-suffix-p ";" pattern)
          `(orderless-initialism . ,(substring pattern 0 -1)))))

    (defun lps/orderless-without-if-bang (pattern _index _total)
      (cond
       ((equal "!" pattern)
        '(orderless-literal . ""))
       ((string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))))
#+end_src

*** Company

     Several packages are available to make auto-completion more efficient and intuitive than the built-in =completion-at-point= function. We use [[https://company-mode.github.io/][Company]] (stands for "comp[lete] any[thing]") as it integrates nicely with other packages that we use, is well-maintained and has a more modern interface than most of its counterparts such as =auto-complete=.

#+begin_src emacs-lisp
  ;; Company. Auto-completion package
  (use-package company
    :diminish
    :init
    (global-company-mode t)
    :hook
    (prog-mode . lps/company-default-backends-prog)
    (text-mode . lps/company-default-backends-text)
    :bind
    (:map company-active-map
          ("<tab>" . company-complete)
          ("TAB" . company-complete)
          ("RET" . nil)
          ("<return>" . nil)
          ("<C-return>" . company-complete-selection)
          ("C-n" . nil)
          ("C-p" . nil)
          ("M-n" . company-select-next)
          ("M-p" . company-select-previous)
          ("C-s" . company-filter-candidates)
          ("M-s" . company-search-candidates))
    (:map company-search-map
          ("C-n" . nil)
          ("C-p" . nil)
          ("M-n" . company-select-next)
          ("M-p" . company-select-previous))
    (:map lps/quick-edit-map
          ("SPC" . company-manual-begin))

    :custom
    ;; Generic company settings
    (company-minimum-prefix-length 4)
    (company-idle-delay 0.0)
    (company-selection-wrap-around t)
    (company-show-numbers t)
    (company-tooltip-align-annotations t)
    (company-tooltip-flip-when-above t)
    (company-tooltip-limit 20)
    (company-require-match nil)
    (company-search-regexp-function 'company-search-words-regexp)

    :config
    ;; Don't use orderless for company
    (defun lps/company-set-completion-styles (fun &rest args)
      (let ((completion-styles '(basic partial-completion emacs22)))
        (apply fun args)))

    (advice-add 'company--perform :around #'lps/company-set-completion-styles)

    ;; Use our personal default backends
    (defun lps/company-default-backends-prog ()
      (setq-local company-backends '((company-capf company-files company-dabbrev company-yasnippet)
                                     (company-dabbrev-code company-gtags company-etags company-keywords company-clang)
                                     company-oddmuse)))

    (defun lps/company-default-backends-text ()
      (setq-local company-backends '((company-capf company-files company-dabbrev company-ispell company-yasnippet)
                                     company-oddmuse)))

    ;; AZERTY-friendly company number selection
    ;; Might lead to company-box being a bit broken ? Long function names are cut-off
    (dolist (map (list company-active-map company-search-map))
      (dolist (key-char '((10 . ?Ã )
                          (1 . ?&)
                          (2 . ?Ã©)
                          (3 . ?\")
                          (4 . ?')
                          (5 . ?\()
                          (6 . ?-)
                          (7 . ?Ã¨)
                          (8 . ?_)
                          (9 . ?Ã§)))
        (define-key map (kbd (format "M-%c" (cdr key-char)))
          `(lambda () (interactive) (company-complete-number ,(car key-char))))))

    ;; Experimental support for multi-backend 'keep-prefix behaviour
    ;; I simply deleted a test from the original function, which
    ;; used to set to t a value when I wanted it to be keep-prefix
    ;; If something breaks, just delete this from the config
    (defun company--multi-backend-adapter (backends command &rest args)
      (let ((backends (cl-loop for b in backends
                               when (or (keywordp b)
                                        (company--maybe-init-backend b))
                               collect b))
            (separate (memq :separate backends)))

        (when (eq command 'prefix)
          (setq backends (butlast backends (length (member :with backends)))))

        (setq backends (cl-delete-if #'keywordp backends))

        (pcase command
          (`candidates
           (company--multi-backend-adapter-candidates backends (car args) separate))
          (`sorted separate)
          (`duplicates (not separate))
          ((or `prefix `ignore-case `no-cache `require-match)
           (let (value)
             (cl-dolist (backend backends)
               (when (setq value (company--force-sync
                                  backend (cons command args) backend))
                 (cl-return value)))))
          (_
           (let ((arg (car args)))
             (when (> (length arg) 0)
               (let ((backend (or (get-text-property 0 'company-backend arg)
                                  (car backends))))
                 (apply backend command args)))))))))
#+end_src

To have a cleaner interface and also a bit of documentation added to the suggested completions, we use two extra packages.

#+begin_src emacs-lisp
  (use-package company-box
    :after company
    :diminish
    :hook (company-mode . company-box-mode)
    :custom
    (company-box-show-single-candidate 'never)
    :config
    (setq company-box-backends-colors '((company-yasnippet :all "dark turquoise"
                                                           :selected (:background "slate blue"
                                                                                  :foreground "white")))))

  (use-package company-quickhelp
    :after company
    :hook (company-mode . company-quickhelp-mode)
    :diminish
    :custom
    (company-quickhelp-delay 0.2))

#+end_src

** Navigation
*** Structure based
Because movement keys are the most frequently used ones, it might be useful to create an Hydra helping us navigate around a document.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind (:map lps/all-hydras-map
                ("m" . hydra-move/body))
    :init
    (defhydra hydra-move ()
      "Movement" ; m as in movement
      ("n" next-line)
      ("p" previous-line)
      ("f" forward-char)
      ("b" backward-char)
      ("a" beginning-of-line)
      ("e" move-end-of-line)
      ("v" scroll-up-command)
      ;; Converting M-v to V here by analogy.
      ("V" scroll-down-command)
      ("l" recenter-top-bottom)))
#+end_src

Furthermore, we change a variable that makes sense for American writers, but not so much according to French conventions. The Emacs Manual recommends against it, as we are no longer able to distinguish a sentence ending from an abbreviation, but I do not use this type of abbreviation very often anyway (notable counterexamples nonetheless: /i.e./ and /e.g./).

We also add more convenient bindings to move paragraph by paragraph.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ("M-n" . forward-paragraph)
    ("M-p" . backward-paragraph)
    :custom
    (sentence-end-double-space nil))
#+end_src

*** Text-search
Final touch: we often use the "search" functions to move the point around, because it is often easier than mashing the ~C-f~ and ~C-n~ keys. In a previous section we bound ~C-s~ to ~Swiper~, which provides a fancy UI but can be slow for simply moving the point to a nearby location.

Hence, we add a few bindings to an already existing keymap, to make them easily accessible again.

#+begin_src emacs-lisp
  (use-package isearch
    :ensure nil
    :bind
    (:map search-map
          ("s" . isearch-forward)
          ("M-s" . isearch-forward) ;; avoids early/late release of Meta
          ("r" . isearch-backward)
          ("x" . isearch-forward-regexp))
    :custom
    ;; Interpret whitespaces as "anything but a newline"
    (search-whitespace-regexp "[-\\/_ \\t.]+")
    (isearch-regexp-lax-whitespace t)
    (isearch-yank-on-move t)
    (isearch-allow-motion t)
    (isearch-allow-scroll t))

  (use-package replace
    :ensure nil
    :bind
    (:map query-replace-map
          ("RET" . act)
          ("<return>" . act))
    (:map lps/quick-edit-map
          ("%" . replace-string)
          ("C-%" . replace-regexp)))
#+end_src

The previously defined commands, along with ~Swiper~, are great to navigate in a buffer if you roughly know where you want to end. However, we sometimes want to move the point to a nearby, visible location, and instead of using and ~isearch~ and repeatedly use the forward and backward bindings, we want to be able to quickly jump there without thinking much, regardless of the current point position in the buffer.

#+begin_src emacs-lisp
  (use-package avy
    :defer t
    :bind ("C-Ã¹" . avy-goto-char-timer)
    :custom
    ;; Using an AZERTY keyboard home row
    (avy-keys '(?q ?s ?d ?f ?g ?h ?j ?k ?l ?m))
    (avy-all-windows nil)
    (avy-single-candidate-jump nil )
    (avy-timeout-seconds 0.5)
    (avy-translate-char-function '(lambda (c) (if (= c 32) ?q c))))
#+end_src

** Rectangles

Manipulating rectangles is a cool Emacs feature. You can select a region with the shape of a rectangle, copy and yank it, insert strings at the beginning of each line of the selection, and several other features.

Because the functions operating on rectangles are not always the easier to remember, we simply define a new Hydra referencing the most useful ones.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind (:map lps/all-hydras-map
                ("r" . hydra-rectangle/body))
    :init
    (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                         :color pink
                                         :hint nil
                                         :post (deactivate-mark))
      "
        ^_p_^       _w_ copy      _o_pen       _N_umber-lines                   |\\     -,,,--,,_
      _b_   _f_     _y_ank        _t_ype       _e_xchange-point                 /,`.-'`'   ..  \-;;,_
        ^_n_^       _d_ kill      _c_lear      _r_eset-region-mark             |,4-  ) )_   .;.(  `'-'
      ^^^^          _u_ndo        _q_ quit     _i_nsert-string-rectangle      '---''(./..)-'(_\_)
      "
      ("p" rectangle-previous-line)
      ("n" rectangle-next-line)
      ("b" rectangle-backward-char)
      ("f" rectangle-forward-char)
      ("d" kill-rectangle)                    ;; C-x r k
      ("y" yank-rectangle)                    ;; C-x r y
      ("w" copy-rectangle-as-kill)            ;; C-x r M-w
      ("o" open-rectangle)                    ;; C-x r o
      ("t" string-rectangle)                  ;; C-x r t
      ("c" clear-rectangle)                   ;; C-x r c
      ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
      ("N" rectangle-number-lines)            ;; C-x r N
      ("r" (if (region-active-p)
               (deactivate-mark)
             (rectangle-mark-mode 1)))        ;; C-x SPC
      ("i" string-insert-rectangle)
      ("u" undo nil)
      ("q" nil)))
#+end_src

** Selection

A useful tool to manipulate text and even source code is the [[https://github.com/magnars/expand-region.el][expand-region]] package, as it allows us to increase the selected region to match larger and larger /semantic/ units. For example, by using it repeatedly, you could select in this order a character, a word, a string containing this word, a sexp containing this string, and the function in this sexp is used.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

We also define functions that Emacs is surprinsingly lacking.

The first one is used to copy without deleting the current line (internally, it uses =kill-ring-save=, and so it can be used in a read-only context, unlike a sequence like =C-a C-k C-y=). It is also much quicker than variations on the sequence  =C-e C-SPC C-a M-w=.

The next one is used to select the current line. Once a line is marked, we can move it, delete it, copy it and so on easily. Having it on a single key binding is quicker than having to do something like =C-a C-SPC C-e=

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ("M-k" . lps/copy-line-at-point)
    ("M-Ã " . lps/select-line)
    :custom
    (kill-read-only-ok t)
    :config
    (defun lps/copy-line-at-point (arg)
      "Copy lines in the kill ring, starting from the line at point.
  If ARG is not specified or equalt to 1, do not copy the indentation.
  If ARG > 1, copy subsequent lines and indentation."
      (interactive "p")
      (let ((beg (if (equal 1 arg)
                     (save-excursion
                       (back-to-indentation)
                       (point))
                   (line-beginning-position)))
            (end (line-end-position arg)))
        (copy-region-as-kill beg end)))

    (defun lps/select-line ()
      "Select the current line. If the region is already active, extends the current selection by line."
      (interactive)
      (if (region-active-p)
          (progn
            (forward-line 1)
            (end-of-line))
        (progn
          (end-of-line)
          (set-mark (line-beginning-position))))))
#+end_src

** Mark management

The mark is a key concept of Emacs. It is used to navigate, make selections, cycle through the jump history ... Because we use ~transient-mark-mode~ (the default, and frankly, the most modern and natural way for a lot of people), one command in particular needs to be improved

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ([remap exchange-point-and-mark] . lps/exchange-point-and-mark)
    :custom
    (set-mark-command-repeat-pop t)
    :init
    ;;Taken from https://spwhitton.name/blog/entry/transient-mark-mode/
    (defun lps/exchange-point-and-mark (arg)
      "Exchange point and mark, but reactivate mark a bit less often.

    Specifically, invert the meaning of ARG in the case where
    Transient Mark mode is on but the region is inactive."
      (interactive "P")
      (exchange-point-and-mark
       (if (and transient-mark-mode (not mark-active))
           (not arg)
         arg))))
#+end_src

** Moving stuff around

A big part of editing text consists in moving already written lines, words or paragraphs around. Emacs provides a set of basic functions to do, with ~transpose-<chars/lines/sexps>~ and so on, but they are not very intuitive and a bit clumsy to use. This is why we use another package, which will allow us to move entire blocks of text much more naturally

#+begin_src emacs-lisp
  (use-package drag-stuff
    :init
    (drag-stuff-global-mode 1)
    (add-to-list 'drag-stuff-except-modes 'org-mode)
    (drag-stuff-define-keys))
#+end_src

Because we added other, more "Emacs-y" bindings to move by paragraphs, we are free to use the original bindings to do more useful stuff. Instead of simply /moving/ things here, we are duplicating them.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ("<C-down>" . lps/duplicate-line-or-region-down)
    ("<C-up>" . lps/collapse-line-up)
    :config
    (defun lps/duplicate-line-or-region-down (arg)
      "Duplicate current line or region if active.
  Move point in the last duplicated string (line or region)."
      (interactive "*p")
      (if (region-active-p)
          (progn
            (save-excursion
              (let* ((bor (region-beginning))
                    (eor (region-end))
                    (content (buffer-substring bor eor)))
                (goto-char eor)
                (end-of-line) ; necessary if region is inside longer line
                (dotimes (i arg)
                  (newline)
                  (insert content))))
            (next-line (* arg (count-lines-region (region-beginning) (region-end)))))

        (save-excursion
          ;; local variables for start and end of line
          (let* ((bol (progn (beginning-of-line) (point)))
                 (eol (progn (end-of-line) (point)))
                 (line (buffer-substring bol eol)))
            (dotimes (i arg)
              (newline)
              (insert line))))
        (next-logical-line arg)))

    (defun lps/collapse-line-up (arg)
      "Delete the current line and move point on the previous line"
      (interactive "*p")
      (save-excursion
        (previous-logical-line arg)
        (setq final (point)))
      (kill-whole-line (- arg))
      (goto-char final)))
#+end_src

** Undo

Another very useful package is undo-tree, which allows you to visualize the previous "Undos" and navigate them.

It can act as a small, local version control system due to how Undos are managed by Emacs.

#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish
    :custom
    (undo-tree-visualizer-timestamps t)
    (undo-tree-enable-undo-in-region t)
    (undo-tree-visualizer-diff t)
    :config
    (global-undo-tree-mode))

#+end_src

** Regexp

#+begin_src emacs-lisp
  (defun lps/find-delete-forward-all-regexp (re &optional beg)
    "Searches for all the matches of the regexp RE after the point, or after the optional position BEG.
    Returns a list of strings containing the matches in order, or nil if none was found.
    Deletes (rather than kill) those matches from the buffer"
    (save-excursion
      (let (matches)
        (goto-char (or beg (point)))
        (while (re-search-forward re nil t)
          (push (match-string 0) matches)
          (delete-region (match-beginning 0) (match-end 0)))
        matches)))

  (defun lps/move-all-regexp-pos-buffer (re &optional beg move split)
    "Moves all the string matching the regexp RE after the point (or after BEG) to the end of the buffer
  (or to the position MOVE if provided)
    If SPLIT is provided, it will be inserted before each match, including the first one.
    The initial strings are destroyed, and the kill-ring is not modified"
    (save-excursion
      (let ((matches (lps/find-delete-forward-all-regexp re beg)))
        (prin1 matches)
        (goto-char (or move (point-max)))
        (while matches
          (insert (or split ""))
          (insert (pop matches))))))
#+end_src

** Align
A very useful and yet relatively unknown Emacs built-in package is ~align~, which provides a few functions to align things according to several criteria, and acting on various parts of the buffer (region, section ...)

#+begin_src emacs-lisp
  (use-package align
    :ensure nil
    :bind
    (:map lps/quick-edit-map
          ("C-a a" . align)
          ("C-a e" . align-entire)
          ("C-a x" . align-regexp)
          ("C-a c" . align-current)))
#+end_src

** Blank lines and lines manipulation
We often want to insert, delete, in a word, /manipulate/ blank lines.
Hence, we will define and rebind a few commands for that.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind-keymap ("C-o" . lps/manipulate-lines-map)
    :bind
    (:map lps/manipulate-lines-map
          ("o" . open-line)
          ("p" . lps/insert-line-above)
          ("n" . lps/insert-line-below)
          ("l" . list-matching-lines)
          ("s" . sort-lines)
          ("r b" . delete-blank-lines)
          ("r d" . delete-matching-lines)
          ("r k" . keep-lines))
    :config
    (defun lps/insert-line-above (N)
      (interactive "P")
      (save-excursion
        (beginning-of-line)
        (newline-and-indent N)))

    (defun lps/insert-line-below (N)
      (interactive "P")
      (save-excursion
        (end-of-line)
        (newline-and-indent N))))
#+end_src

** Personal commands

We also define a bunch of functions and commands related to editing text that are not provided in Emacs by default, and would be too specific to find in a package.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind-keymap
    ("C-z" . lps/quick-edit-map)
    :bind
    (:map lps/quick-edit-map
          ("C-u" . lps/underline-or-frame-dwim)
          ("k" . zap-up-to-char))

    :config

    (defun lps/--fill-width-repeat-string (width str)
      "Insert STR as many times as necessary to fill WIDTH,
  potentially using only a prefix of STR for the final iteration"
      (let* ((len (length str))
             (k (/ width len))
             (rem (% width len)))
        (dotimes (i k)
          (insert str))
        (insert (substring str 0 rem))))

    (defun lps/underline-or-frame-dwim (str &optional arg)
      "Underlines the current line with the string STR or with \"-\"
  if none is provided.
  If called interactively, prompt for STR.
  With a prefix argument, frame the line using STR instead.
  Breaks if region or line spans multiple visual lines"
      (interactive (list (let ((default "-"))
                           (read-string (concat "Use string (default " default " ): ") nil nil "-"))
                         current-prefix-arg))
      (save-excursion
        (let* ((len (length str))
               (from (if (region-active-p)
                         (region-beginning)
                       (line-beginning-position)))
               (to (if (region-active-p)
                       (region-end)
                     (line-end-position)))
               (col (- from (line-beginning-position)))
               (width (if arg
                          (+ (* 2 len) (- to from))
                        (- to from))))
          (if arg
              (progn
                (goto-char from)
                (insert str)
                (goto-char (+ len to))
                (insert str)
                (beginning-of-line)
                (insert "\n")
                (forward-line -1)
                (indent-to col)
                (lps/--fill-width-repeat-string width str)
                (forward-line 1)
                (end-of-line)
                (insert "\n")
                (indent-to col)
                (lps/--fill-width-repeat-string width str))
            (progn
              (end-of-line)
              (insert "\n")
              (indent-to col)
              (lps/--fill-width-repeat-string width str)))))))
#+end_src

* Programming
** Project management
*** Projectile
    [[https://projectile.mx/][Projectile]] is an Emacs package that makes project management easier. It allows us /e.g./ to navigate between files of the same project, search/replace within files of the same project, and integrates very well with other tools, such as =lsp-mode= or ~counsel~.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish
    :disabled t ;; try Project.el instead
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :custom
    (projectile-switch-project-action #'projectile-dired)
    (projectile-completion-system 'ivy)
    :config
    (let ((path-project "~/Documents/Projects"))
      (when (file-directory-p path-project)
        (setq projectile-project-search-path (list path-project))))
    (projectile-mode))

  (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode))

#+end_src

** Git
*** Magit
[[https://magit.vc/][Magit]] is a serious contender for the first place in the long list of "Reasons you should use Emacs", along with Org Mode.

It is a Text User Interface to Git, which integrates most of Git commands, even the most advanced ones, while making it easy to use even for beginners.

#+begin_src emacs-lisp
  (use-package magit
    :defer t
    ;; :custom (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    ;; uncomment previous line to have magit open itself within the same buffer
    ;; instead of in another buffer
    :bind
    ("C-x g" . magit-status)
    (:map magit-section-mode-map
          ("M-^" . magit-section-up))
    :config
    (dolist (action '(stage-all-changes unstage-all-changes))
      (add-to-list 'magit-no-confirm action)))
#+end_src

*** Git-timemachine

Another useful package is [[https://github.com/emacsmirror/git-timemachine][git-timemachine]], which allows to easily navigate the history of a git-controlled file with a few key presses.

Although Magit is more or less able to do the same thing, the interface there is cleaner and you are less likely to get lost than in the fully-featured super-package that Magit is.

#+begin_src emacs-lisp
  (use-package git-timemachine
    :defer t)
#+end_src

*** Forge
We will probably want to work with distant repositories, /e.g./ stored on a distant GitHub or GitLab host.

In order to integrate more tightly with those tools, and have access to more complex features than the basic ones provided by Git itself, we use a package called [[https://magit.vc/manual/forge/][Forge]]. For example, it will allow us to do pull-requests, or edit issues, directly from Emacs, rather than having to connect to the online GitHub website or to use another API provided by some other software.

*MANUAL* In order to use this package, you need to have a personal "token", so that the server knows who you are ! To setup everything, follow the instructions in the Forge manual.

#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :custom
    (forge-bug-reference-hooks nil))
#+end_src

*** Diff and merge conflicts
Whenever we use version control, merge conflicts will unavoidably arise. Hence, we need to be able to solve them as efficiently and clearly as possible, and Emacs provides a few tools for this.

#+begin_src emacs-lisp
  (use-package smerge-mode
    :defer t
    :hook
    (find-file . lps/smerge-maybe-start)
    :bind
    (:map lps/all-hydras-map
          ("s" . hydra-smerge/body))
    :bind-keymap
    ("C-c m" . smerge-basic-map)
    :init
    (defun lps/smerge-maybe-start ()
      (when (and buffer-file-name (vc-backend buffer-file-name))
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^<<<<<< " nil t)
            (message "Smerge-mode automatically enabled: there seem to be conflicts !")
            (smerge-mode 1)))))

    :config
    (pretty-hydra-define hydra-smerge (:title "Smerge Hydra"
                                              :post (smerge-auto-leave)
                                              :color pink
                                              :hint nil
                                              :quit-key "q")
      ("Move"
       (("n" smerge-next "Next")
        ("p" smerge-prev "Prev"))
       "Keep"
       (("b" smerge-keep-base "Base")
        ("u" smerge-keep-upper "Upper")
        ("m" smerge-keep-upper "Upper")
        ("l" smerge-keep-lower "Lower")
        ("o" smerge-keep-lower "Lower")
        ("a" smerge-keep-all "All")
        ("RET" smerge-keep-current "Current")
        ("\C-m" smerge-keep-current "Current"))
       "Diff"
       (("<" smerge-diff-base-upper "Upper/Base")
        ("=" smerge-diff-upper-lower "Upper/Lower")
        (">" smerge-diff-base-lower "Lower/Base")
        ("R" smerge-refine "Refine")
        ("E" smerge-ediff "Ediff"))
       "Other"
       (("C" smerge-combine-with-next "Combine")
        ("r" smerge-resolve "Resolve")
        ("k" smerge-kill-current "Kill current")
        ("ZZ" (lambda ()
                (interactive)
                (save-buffer)
                (bury-buffer))
         "Save and bury buffer" :color blue)
        ("q" nil "Cancel" :color blue)))))
#+end_src

** Parenthesis

First of all, we want to easily be able to tell with a quick glance which parenthesis are matching

#+begin_src emacs-lisp
  ;; Always highlight matching parenthesis
  (use-package paren
    :ensure nil
    :init
    (show-paren-mode t)
    :custom
    ;; (show-paren-style 'mixed) ; Too invasive
    (show-paren-when-point-inside-paren t)
    (show-paren-when-point-in-periphery t))

  ;; rainbow-delimiters. Hightlights with the same colour matching parenthesis
  (use-package rainbow-delimiters
    :hook ((prog-mode comint-mode fundamental-mode) . rainbow-delimiters-mode))
#+end_src

Now, in order to work with structured text, such as source code, we want to be able to directly manipulate "expressions" rather than lines or words. This is why we use the following packages, as they provide a lot of functionalities to navigate and edit those expressions.

#+begin_src emacs-lisp
  (use-package paredit
    :init
    (defun lps/paredit-enable-electric-pair-disable ()
      (paredit-mode 1)
      (electric-pair-local-mode -1))

    :hook ((sly-mrepl-mode
            eshell-mode
            ielm-mode
            eval-expression-minibuffer-setup
            lisp-data-mode
            cider-mode
            cider-repl-mode)
           . lps/paredit-enable-electric-pair-disable)

    :bind
    (:map paredit-mode-map
          ("M-?" . nil)
          ("C-S-w" . paredit-copy-as-kill)
          ("M-s" . nil) ;; To get isearch-mode-map
          ("M-s M-s" . paredit-splice-sexp)
          ("C-M-," . paredit-convolute-sexp)
          ("C-S-t" . transpose-sexps)
          ("M-j" . eval-print-last-sexp)
          ([remap newline] . paredit-newline)
          ("<C-backspace>" . paredit-delete-region)))

  (use-package elec-pair
    :hook ((prog-mode
            org-mode
            inferior-python-mode)
           . electric-pair-local-mode)) ;; needed for org-babel
#+end_src

Finally, we also remap one built-in command to a (usually) more useful variant, which has the same behaviour as the paredit one.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    (defun lps/insert-parentheses (&optional arg)
      "Same as `insert-parentheses' but if no ARG is provided, it wraps
  the next s-expression in parentheses rather than inserting () at point"
      (interactive "P")
      (if arg
          (insert-parentheses arg)
        (insert-parentheses 1)))
    :bind
    ([remap insert-parentheses] . lps/insert-parentheses))
#+end_src

** Better auto-completion

The previous Auto-completion section was about the general editing experience. Here, we add extra tools that will be particularly interesting when editing some kind of source code, which is by nature much more repetitive and rigid.

*** YASnippet

     A first useful package is YASnippet, which makes it easy to define and automatically insert snippets of code in various languages.

#+begin_src emacs-lisp
  ;;YASnippet
  (use-package yasnippet
    :diminish
    :config
    (setq yas-verbosity 1)
    :hook ((prog-mode LaTeX-mode) . yas-minor-mode)
    :bind (:map yas-minor-mode-map
                ("TAB" . nil)
                ("<tab>" . nil)
                ("<C-tab>" . yas-expand)))
#+end_src

It is even possible to define your own snippets. The following package contains a lot of useful snippets for various programming languages or tools, such a C++, Clojure, various Makefiles, Emacs' Org-Mode ...

#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :after yasnippet)
#+end_src

**** Extra snippets
#+begin_src emacs-lisp
  (use-package common-lisp-snippets
    :after yasnippet)
#+end_src

*** Company backends

A first backend that we want to consider is the one using snippets provided by ~yasnippet~

#+begin_src emacs-lisp
  (use-package company-yasnippet
    :ensure nil
    :after company)
#+end_src

Most of the time, when writing text, we are going to use words over and over again in the same buffer. ~company-dabbrev~ will return completion candidates based on this content.

#+begin_src emacs-lisp
  (use-package company-dabbrev
    :ensure nil
    :after company
    :custom
    (company-dabbrev-other-buffers t)
    (company-dabbrev-ignore-case 'keep-prefix)
    (company-dabbrev-downcase 'case-replace))
#+end_src

  We install another backend specifically for LaTeX

#+begin_src emacs-lisp
  (use-package company-math
    :after company)
#+end_src

We add another backend to support completion in shell and terminal-modes
#+begin_src emacs-lisp
  (use-package company-shell
    :disabled t
    :after eshell
    :hook (eshell-mode . lps/company-shell-modes)
    :config
    (defun lps/company-shell-modes ()
      ;; Not satisfying: duplicates from company-capf and company-shell, so we disable the 2nd one but we lose some documentation ...
      (setq-local company-backends '((company-shell-env company-fish-shell company-capf company-files company-dabbrev company-shell)))
      (push 'elisp-completion-at-point completion-at-point-functions)))
#+end_src

** Language Server Protocol
*** LSP-mode

    The [[https://en.wikipedia.org/wiki/Language_Server_Protocol][Language Server Protocol]] is a protocol which facilitates the use of several languages with various IDE. Instead of specifying a syntax, ..., for each pair "IDE/Language", it aims at abstracting the specifities of each language, so that each IDE will need to communicate with a server that will give back the information needed to do IDE-y things such as highlighting or auto-completion in an unified manner.

#+begin_src emacs-lisp

  ;; LSP mode. Useful IDE-like features
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :init
    ;; Sometimes, we don't want to start a full server just to check a file
    ;; or make a few edits to it. In my use, this mostly depends on the session:
    ;; In a quick session, I might not want to start a server for one or two files,
    ;; however, once I start using LSP, there is no reason not to assume that I
    ;; also want to use it by default for other files in the same session
    (defvar lps/--default-lsp-mode 0)
    (defun lps/lsp-by-default-in-session ()
      (if (> lps/--default-lsp-mode 0)
          (lsp-deferred)
        (if (and (= lps/--default-lsp-mode 0)
                 (y-or-n-p "Automatically use lsp-mode in the current session ?"))
            (progn
              (setq lps/--default-lsp-mode 1)
              (lsp))
          (setq lps/--default-lsp-mode -1))))

    (defun lps/--no-lsp-here (fun &rest args)
      (let ((lps/--default-lsp-mode -1))
        (apply fun args)))

    (advice-add 'helpful-update :around 'lps/--no-lsp-here)

    :custom
    (lsp-diagnostics-provider :flycheck)  ;:none if none wanted

    :config
    (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
    (lsp-enable-which-key-integration t)
    (setq lsp-prefer-flymake nil)
    (setq lsp-enable-on-type-formatting nil)

    (defun lps/toggle-lsp-by-default-in-session ()
      (interactive)
      (setq lps/--default-lsp-mode (not lps/--default-lsp-mode)))

    :hook ((python-mode c-mode c++-mode) . lps/lsp-by-default-in-session))

  (use-package lsp-ui
    :after lsp-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-delay 1)
    (lsp-ui-sideline-show-code-actions nil))

  (use-package lsp-treemacs
    :after lsp-mode
    :config (lsp-treemacs-sync-mode 1))

  (use-package lsp-ivy
    :after (lsp-mode ivy))
#+end_src

*** Eglot

There exists another implementation of the Language Server Protocol in Emacs, called [[https://github.com/joaotavora/eglot][eglot]]. It is much more integrated within "core" Emacs, as it only uses built-in packages, such as =project.el= instead of ~projectile~, or ~flymake~ rather than ~flycheck~.

#+begin_src emacs-lisp
  ;; Might not work, recommended to use package-install instead
  ;; Dependencies might not be the correct ones

  (use-package eglot
    ;;:hook ((python-mode c-mode c++-mode) . eglot-ensure)
    :ensure nil
    :bind-keymap ("C-c l" . eglot-mode-map)
    :bind (:map eglot-mode-map
                ("r" . eglot-rename)
                ("g g" . xref-find-definitions)
                ("g r" . xref-find-references)
                ("h" . eldoc)))
#+end_src

** Real-time syntax checking

    [[https://www.flycheck.org/en/latest/][Flycheck]] is a modern on-the-fly syntax checking extension to Emacs, working for several languages, showing different level of errors (warnings, errors ...), and which has a natural integration to =lsp-mode=.

#+begin_src emacs-lisp
  ;; Flycheck
  (use-package flycheck
    :defer t
    :custom
    ;; (setq flycheck-relevant-error-other-file-show nil) ;might be useful
    (flycheck-indication-mode 'left-margin)
    (flycheck-display-errors-delay 0.3))

#+end_src

** Compilation
In several programming languages, it is useful to have a way to compile the current program easily.
We will use the built-in ~compile~ command for this, and tune it as we need.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    (:map prog-mode-map
          ("<f5>" . compile)))
#+end_src

** REPL and CLI

Many programming languages have, in one way or another, a REPL or a command-line interface. Although some modes will be configured independently, there are some tweaks that we want everywhere, regardless of the mode.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (comint-scroll-to-bottom-on-input t)
    (comint-prompt-read-only t))
#+end_src

** Programming languages
In this section, we fine-tune our editing tools for various programming languages.
*** Python

     We need to specify which server LSP will use. Several packages are available.

     *MANUAL* Before using LSP, use the following command to install a server:

     =pip install --user python-language-server[all]=

     The command ~pyls~ needs to be available on the ~PATH~ environment variable.

#+begin_src emacs-lisp
  (use-package python
    :ensure nil
    :defer t
;;    :hook (python-mode . lps/run-python)
    :custom
    (python-shell-interpreter "python3")
    :config
    (require 'lsp-pyright)
    (defun lps/run-python ()
      (save-excursion
        (call-interactively 'run-python))))
#+end_src

I will use another server, based on [[https://github.com/microsoft/pyright][Pyright]]

#+begin_src emacs-lisp
  (use-package lsp-pyright
    :defer t)
#+end_src

*** OCaml

For OCaml, we do not use LSP mode, and we instead choose to work with a specific minor mode called [[https://github.com/ocaml/tuareg][Tuareg]].

#+begin_src emacs-lisp
  ;; Tuareg (for OCaml and ML like languages)
  (use-package tuareg
    :defer t
    :config
    (setq tuareg-indent-align-with-first-arg t)
    (setq tuareg-match-patterns-aligned t))
#+end_src

*** C/C++

For C and C++ (and ObjectiveC), as for Python, we need to install a server for LSP to use. We use the one called [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]].

*MANUAL* To use the ccls server, follow the instruction [[https://github.com/MaskRay/ccls/][here]], or simply install the available version from your distribution standard repositories.

#+begin_src emacs-lisp
  ;; C/C++
  ;; See https://github.com/MaskRay/ccls/wiki/lsp-mode
  (use-package ccls
    :defer t
    :config
    (setq ccls-executable (executable-find "ccls")))
#+end_src

We also use custom compilation commands.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :hook
    ((c-mode c++-mode) . lps/c-c++-mode-basic-compile-command)
    :config
    (defun lps/c-c++-mode-basic-compile-command ()
      (let* ((buf (file-name-nondirectory (or (buffer-file-name) (buffer-name))))
             (buf-no-ext (file-name-sans-extension buf))
             (c-mode-p (eq major-mode 'c-mode))
             (compiler (if c-mode-p "gcc " "g++ ")))
        (setq-local compile-command (concat compiler
                                            buf
                                            " -o "
                                            buf-no-ext)))))
#+end_src

*** Lisp
**** Emacs Lisp

Although Emacs comes with pretty good built-in functionalities, there is still room for improvement.

[[https://github.com/Fanael/highlight-defined][highlight defined]] highlights defined Emacs Lisp symbols (functions, variable names, macros ...) in source code.

#+begin_src emacs-lisp
  (use-package highlight-defined
    :hook (emacs-lisp-mode . highlight-defined-mode))

#+end_src

[[https://github.com/Silex/elmacro][elmacro]] shows keyboard macros and interactive commands as Emacs Lisp, meaning that if you know /how/ to do something using advanced keyboard shortcuts or interactive commands, you can get for free an elisp code snippet that does exactly the same thing that you can reuse /e.g./ in a configuration file or in another function.

Because it might be useful everywhere, we do not use it simply in =emacs-lisp-mode= and we activate it everywhere.

#+begin_src emacs-lisp
  (use-package elmacro
    :defer t)
#+end_src

We define a useful function to evaluate an expression, and replace it with the result. This, in conjunction with macros and multiple cursors, is a great tool to automate otherwise boring tasks.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind
    ("C-c C-e" . lps/eval-and-replace-last-sexp)
    (:map lps/quick-edit-map
          ("x" . emacs-lisp-macroexpand)
          ("C-r" . lps/print-eval-region)
          ("C-e" . lps/eval-and-replace-last-sexp))

    :config
    (defun lps/eval-and-replace-last-sexp ()
      "Evaluate the last s-expression, and replace it with the result"
      (interactive)
      (let ((value (eval (preceding-sexp))))
        (kill-sexp -1)
        (insert (format "%S" value))))

    (defun lps/print-eval-region (start end)
      (interactive "r")
      (eval-region start end t)))
#+end_src

**** Common Lisp

We could, of course, use LSP to write Common Lisp code. However, Emacs already provides nice editing functionalities for programming in Lisp-like languages, and CL is no exception. On top of the built-in Emacs functions, we use another minor mode, specifically designed to write Common Lisp: [[https://common-lisp.net/project/slime/][SLIME]]. More precisely, we use a /fork/ of SLIME, known as [[https://github.com/joaotavora/sly][SLY]].

*MANUAL* It is likely that ~sbcl~ is not already installed. Hence, in order to run the following code, you will need to install it. If you install it manuallyby compiling the source code, make sure that the ~sbcl~ command is available on the PATH, or modify  =:custom (inferior-lisp-program "<path/to/sbcl>")= accordingly in the following block.
Moreover, if  you want to access the CL HyperSpec offline, you need to download it, and have ~common-lisp-hyperspec-root~ point towards it.

#+begin_src emacs-lisp
  ;; Make sure that sbcl is available on PATH
  (use-package sly
    :hook (lisp-mode . sly-editing-mode)
    :bind
    (:map sly-mode-map
          ("M-_" . nil))
    (:map sly-doc-map
          ("C-g" . nil)
          ("C-h" . nil)
          ("g" . common-lisp-hyperspec-glossary-term)
          ("h" . sly-documentation-lookup))
    (:map sly-prefix-map
          ("C-p" . nil)
          ("M-p" . sly-pprint-eval-last-expression)
          ("C-i" . consult-imenu))
    :custom
    ;; Clisp makes SLY crash ?!
    (inferior-lisp-program "sbcl")
    (sly-net-coding-system 'utf-8-unix)
    (sly-complete-symbol-function 'sly-flex-completions)
    :config
    (setq common-lisp-hyperspec-root (concat "file://" (expand-file-name "~/Documents/Other/HyperSpec/")))

    (define-key sly-prefix-map (kbd "C-v") sly-selector-map)

    (defun lps/sly-company-setup ()
      (setq-local company-prescient-sort-length-enable nil)
      (setq-local company-backends '(company-capf)))

    (defun lps/sly-start-repl ()
      (unless (sly-connected-p)
        (save-excursion (sly))))

    (add-hook 'sly-mode-hook #'lps/sly-start-repl)
    (add-hook 'sly-mode-hook #'lps/sly-company-setup)

    (add-hook 'sly-minibuffer-setup-hook #'paredit-mode)

    ;; Don't use Ido, just use our default
    (defalias 'sly-completing-read completing-read-function)

    ;; View HyperSpec within Emacs using EWW
    (setq browse-url-handlers
      '(("hyperspec" . eww-browse-url)
        ("." . browse-url-default-browser))))

  (use-package sly-mrepl
    :ensure nil
    :after sly
    :hook
    (sly-mrepl-mode . lps/sly-setup)
    :bind
    (:map sly-mrepl-mode-map
          ("C-c C-n" . sly-mrepl-next-prompt)
          ("C-c C-p" . sly-mrepl-previous-prompt)
          ("C-c C-k" . sly-quit-lisp)
          ("<C-return>" . end-of-buffer))
    (:map sly-selector-map
          ("C-v" . lps/sly-mrepl-other-window))
    :config
    (defun lps/sly-mrepl-other-window ()
      (interactive)
      (sly-mrepl #'pop-to-buffer))

    ;; Allow paredit to scroll to bottom on input when insert a parenthesis
    (defun lps/sly-mrepl-paredit-open-scroll-to-bottom (&rest args)
      "Fix to also scroll to the bottom of the SLY REPL when inserting a parenthesis.
  This is needed, as `comint-preinput-scroll-to-bottom' does not
  recognize `paredit-open-round' as a command susceptible to
  trigger the scrolling."
      (if (and (derived-mode-p major-mode 'comint-mode)
               comint-scroll-to-bottom-on-input)
          (let* ((current (current-buffer))
                 (process (get-buffer-process current))
                 (scroll comint-scroll-to-bottom-on-input))
            (when (and process (< (point) (process-mark process)))
              (if (eq scroll 'this)
                  (goto-char (point-max))
                (walk-windows
                 (lambda (window)
                   (if (and (eq (window-buffer window) current)
                            (or (eq scroll t) (eq scroll 'all)))
                       (with-selected-window window
                         (goto-char (point-max)))))
                 nil t))))))

    (advice-add 'paredit-open-round :before 'lps/sly-mrepl-paredit-open-scroll-to-bottom)

    ;; Setup various variables
    (defun lps/sly-setup ()
      (lps/sly-company-setup)
      ;; Why does SLY disable it ???
      (setq-local comint-scroll-to-bottom-on-input t)))

  (use-package sly-stickers
    :ensure nil
    :after sly
    :bind
    (:map sly-stickers-mode-map
          ("C-c C-s C-t" . sly-stickers-toggle-break-on-stickers)))
#+end_src

On top of this environment and compiler, we also need an access to external libraries and packages. A popular option is to use Quicklisp, for which there is a SLY integration.

We also add extra-packages to facilitate some usual operations.

#+begin_src emacs-lisp
  (use-package sly-quicklisp
    :after sly
    :hook (sly . sly-quicklisp-mode))

  (use-package sly-macrostep
    :after sly)

  (use-package sly-asdf
    :after sly)
#+end_src

****  Clojure
Finally, another recent and promising Lisp, which is much more opinionated than Common Lisp and runs on the JVM. It is a functional language, with a strong emphasis on immutable data structure, and has various tools that make concurrent programming easy.

#+begin_src emacs-lisp
  (use-package cider
    :defer t)
#+end_src

*** Web development
**** Javascript
The built-in ~js-mode~ is good, but as it is often the case with Emacs and popular languages, it has been improved in community packages.

#+begin_src emacs-lisp
  (use-package js2-mode
    :defer t
    :mode
    (("\\.js\\'" . js2-mode))
    :custom
    (js2-include-node-externs t))
#+end_src

We also a language server to help us with refactoring, completion and other fancy IDE-like features.

#+begin_src emacs-lisp
  (use-package tide
    :hook
    (js2-mode . lps/setup-tide-mode)
    (tide . lps/add-tide-hooks)
    :config
    (defun lps/setup-tide-mode ()
      "Set up Tide mode."
      (interactive)
      (tide-setup)
      (flycheck-mode)
      (tide-hl-identifier-mode 1)
      (if (and tide-completion-setup-company-backend
               (not (or (eq 'company-tide (car company-backends))
                        (member 'company-tide (car company-backends)))))
          (setq-local company-backends (list (cons 'company-tide
                                                   (car company-backends))))))

    (defun lps/add-tide-hooks ()
      (add-hook 'before-save-hook #'tide-format-before-save nil t)))
#+end_src

**** HTML/CSS
For HTML/CSS, we use another featureful package called =web-mode=. It can also be used to deal with Javascript or PHP code, but in my opinion, there are better alternatives for those specifically, so I only use =web-mode= for HTML/CSS (and their numerous variants ...).
#+begin_src emacs-lisp
  (use-package web-mode
    :defer t
    :mode
    (("\\.html?" . web-mode)
     ("\\.css" . web-mode))
    :hook
    (web-mode . rainbow-mode))
#+end_src

Because HTML tends to be very verbose, we also want to be able to quickly type the usual boilerplate. We use =emmet-mode=, which implement a way to quickly expand (many) abbreviations into templates. It is somewhat similar to =Yasnippet=, with some differences nonetheless, and the two can be used at the same time so why would we have to choose ?

#+begin_src emacs-lisp
  (use-package emmmet-mode
    :defer t
    :hook
    ((sgml-mode css-mode web-mode) . emmet-mode)
    (emmet-mode . emmet-preview-mode)
    :custom
    (emmet-move-cursor-between-quotes t))
#+end_src

** Debug
*** GUD
Emacs already provides a large number of debuggers, under the name "Grand Unified Debugger".

#+begin_src emacs-lisp
  (use-package gdb-mi
    :ensure nil
    :defer t
    :hook (gdb-mode . gdb-many-windows))
#+end_src

*** TODO Dap-mode

** Other tools
*** ANTLR
[[https://fr.wikipedia.org/wiki/ANTLR][ANTLR]] is a tool that is used to write compilers and interpreters, by producing a lexer and a parser (and potentially several other things) from a grammar.

#+begin_src emacs-lisp
  (use-package antlr-mode
    :mode ("\\.g4\\'" . antlr-mode))

#+end_src

*** SageMath

[[https://www.sagemath.org/][SageMath]] (or simply ~Sage~) is a general-purpose mathematics system, built-on top of many other open-source softwares, that are combined and made accessible from a common Python interface.

#+begin_src emacs-lisp
  (use-package sage-shell-mode
    :hook
    ((sage-shell-mode sage-shell:sage-mode) . lps/sage-shell-hooks)
    :config
    ;; Be careful: if you use the (now somewhat obsolete) `sage-mode',
    ;; this might break things and call the wrong functions
    (sage-shell:define-alias)
    ;; Sage is its own shell, no need to open a Python shell too !
    (defun lps/sage-shell-hooks ()
      (eldoc-mode 1)
      (setq-local python-mode-hook (remove 'lps/run-python python-mode-hook))))
#+end_src

* Org Mode

   [[https://orgmode.org/][Org Mode]] is one of the best reasons to use Emacs.

   It acts as a markup language, can deal with planning, manage spreadsheets, do project planning, run code blocks to do literate programming ...

** Basic configuration

     We change the general feel of Org Mode documents by using other indentation rules, by changing the headers appearance, and a few other minor changes.

#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("â" "â" "â" "â" "â" "â" "â")))

  (use-package org
    :commands org-capture
    ;; :init
    ;; (global-set-key (kbd "C-c o") #'org-capture)
    :hook (org-mode . lps/org-mode-setup)
    :bind
    ("C-c o" . org-capture)
    ("C-c a" . org-agenda)
    (:map org-mode-map
          ("<C-S-return>" . org-insert-subheading)
          ("<C-S-left>" . nil)
          ("<C-S-right>" . nil)
          ("<C-S-up>" . nil)
          ("<C-S-down>" . nil)
          ("C-," . nil)
          ("C-a" . org-beginning-of-line)
          ("C-e" . org-end-of-line))
    (:map org-src-mode-map
          ("C-c C-c" . org-edit-src-exit))

    :custom
    ;; Coding in blocks
    (org-src-fontify-natively t)
    (org-src-tab-acts-natively t)
    (org-use-speed-commands t)
    (org-directory "~/Documents/OrgFiles/")
    (org-special-ctrl-a/e t) ;; Not enough with visual-line-mode, need to bind C-a/C-e too
    :config
    (defun lps/org-mode-setup ()
      (lps/org-font-setup)
      (org-indent-mode 1)
      (variable-pitch-mode 1)
      (visual-line-mode 1))

    (setq org-imenu-depth 4)

    (setq org-ellipsis " â¾")

#+end_src

Take care when copying this block of code: the ~use-package~ declaration continues.

** Font faces

     In order for Org Mode to feel like a document instead of code, we use a different font.

#+begin_src emacs-lisp
  ;; Use the right font according to what is installed on the system

  (let ((my-temp-org-font "Cantarell"))
    (if (member my-temp-org-font (font-family-list))
        (setq my-org-mode-font my-temp-org-font)
      (setq my-org-mode-font "Ubuntu Mono")))

  (defun lps/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â¢"))))))

    ;; Set faces for heading levels
    ;; For non-headers: org-default

    (dolist (face '((org-level-1 . 1.3)
                    (org-level-2 . 1.2)
                    (org-level-3 . 1.15)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.05)
                    (org-level-6 . 1.0)
                    (org-level-7 . 1.0)
                    (org-level-8 . 1.0)))
      (set-face-attribute (car face) nil :font my-org-mode-font :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch :extend t)
    (set-face-attribute 'org-block-begin-line nil :slant 'italic :foreground "dark gray" :background "#1d1d2b" :inherit 'variable-pitch :height 1.0)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-link nil :inherit '(link fixed-pitch)))

#+end_src

** Org Babel

Org babel is what allows us to write code and execute it, all within the same document.

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)
     (latex . t)))

  ;; (setq org-confirm-babel-evaluate nil) ; Take care if executing someone
                                           ; else code

#+end_src

We also add templates to insert code blocks with a few key presses

#+begin_src emacs-lisp

  (if (version<= "9.2" org-version) ; ) parsing bug
      ;; This is needed as of Org 9.2
      (progn
        (require 'org-tempo)

        (let ((bound-key-templates
               (mapcar #'car org-structure-template-alist)))
          (dolist (key-template '(("sh" . "src shell")
                                  ("el" . "src emacs-lisp")
                                  ("py" . "src python")
                                  ("latex" . "src latex")))

            (unless
                (member (car key-template) bound-key-templates)
              (push key-template org-structure-template-alist))))))

#+end_src

** Auto-tangle configuration files

     In order to concatenate all the code blocks that are written in this document to an external file, we need to "tangle" it.

     The following code makes it so that each time this file is saved, it generates the corresponding init.el file.

#+begin_src emacs-lisp
  ;; Automatically tangles this emacs-config config file when we save it
  (defun lps/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name (concat user-emacs-directory "emacs-config.org")))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'lps/org-babel-tangle-config)))
#+end_src

Moreover, while we are configuring how Emacs treats this very file, we also want to be able to use a good Elisp completion system, as this file is mainly composed of Elisp code.

#+begin_src emacs-lisp
  (defun lps/elisp-completion-in-user-init ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name (concat user-emacs-directory "emacs-config.org")))
      (setq-local completion-at-point-functions '(pcomplete-completions-at-point elisp-completion-at-point t))))

  (add-hook 'org-mode-hook #'lps/elisp-completion-in-user-init)
#+end_src

** Org Agenda

Not only is Org Mode great to write structured documents that can be exported to pretty much anything we want - including tangled to produce source code using literate programming -, it is also a powerful to ... *org*anize things. A built-in functionality is the agenda, where you can schedule tasks, set deadlines, configure reminders, the frequency at which you will need to repeat a given task, and so on.

#+begin_src emacs-lisp
  (setq org-agenda-files (list (concat org-directory "agenda/")))
  (setq org-log-into-drawer t)
  (setq org-log-done 'time)
  (setq org-agenda-start-with-log-mode t)

  (setq org-tag-alist
        '((:startgroup)
          ;; Put mutually exclusive tags here
          (:endgroup)
          ("@home" . ?H)
          ("@work" . ?W)
          ("agenda" . ?a)
          ("plan" . ?p)
          ("note" . ?n)
          ("idea" . ?i)
          ("read" . ?r)))

#+end_src

** Org Capture
#+begin_src emacs-lisp
  ;; From https://stackoverflow.com/questions/9005843/interactively-enter-headline-under-which-to-place-an-entry-using-capture
  (defun lps/org-ask-location ()
    (let* ((org-refile-targets '((nil :maxlevel . 2)))
           (hd (condition-case nil
                   (car (org-refile-get-location nil nil t))
                 (error (car org-refile-history)))))
      (goto-char (point-min))
      (outline-next-heading)
      (if (re-search-forward
           (format org-complex-heading-regexp-format (regexp-quote hd))
           nil t)
          (goto-char (point-at-bol))
        (goto-char (point-max))
        (or (bolp) (insert "\n"))
        (insert "* " hd "\n")))
    (end-of-line))

  (setq org-capture-templates
        `(("t" "Tasks / Projects")
          ("tt" "Task" entry
           (file+olp ,(concat org-directory "agenda/Tasks.org") "Inbox")
           "* TODO %?\n  %U\n  %a\n  %i"
           :empty-lines 1)

          ("m" "Meeting" entry
           (file+olp+datetree ,(concat org-directory "agenda/Meetings.org"))
           "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
           :empty-lines 1)

          ("w" "Workflows")
          ("we" "Checking Email" entry
           (file+olp+datetree ,(concat org-directory "agenda/Tasks.org"))
           "* Checking Email :email:\n\n%?"
           :empty-lines 1)

          ("a" "Agenda (others)" entry
           (file ,(concat org-directory "agenda/Others.org"))
           "* %(call-interactively #'org-time-stamp) %? :agenda:\n"
           :empty-lines 1)

          ("r" "Random")
          ("rr" "Random" plain
           (file+headline "everything.org"
                          "A trier")
           "%x%?\n%i"
           :empty-lines-after 1)

          ("rm" "Movie" checkitem
           (file+function "movies.org" lps/org-ask-location))

          ("rb" "Book" checkitem
             (file+function "books.org" lps/org-ask-location))

          ("rR" "Restaurant" checkitem
           (file+function "restaurants.org" lps/org-ask-location))))

  (setq org-capture-bookmark nil))
#+end_src

* LaTeX and PDF
*** PDF viewer

Rather than =doc-view=, we  use [[https://github.com/politza/pdf-tools][PDF Tools]].

*MANUAL* This package might require some external libraries to be installed. Please refer to the linked page to see exactly what you need to do on your system.

#+begin_src emacs-lisp
  ;; Might require extra libs to work, see https://github.com/politza/pdf-tools

  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward)
                ("C-c ?" . lps/pdf-maybe-goto-index))
    :custom
    (pdf-links-read-link-convert-commands '("-font" "FreeMono"
                                            "-pointsize" "%P"
                                            "-undercolor" "%f"
                                            "-fill" "%b"
                                            "-draw" "text %X,%Y '%c'"))
    (pdf-links-convert-pointsize-scale 0.015) ;; Slightly bigger than default
    :config
    (pdf-tools-install :no-query)
    ;;(add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode)
    (add-hook 'pdf-view-mode-hook 'pdf-history-minor-mode)

    (defun lps/pdf-maybe-goto-index ()
      "Tries to guess where the index of the document is,
  and ask for a keyword to find from there. If no Index is found,
  move to the end of the document, and search backward instead."
      (interactive)
      (if (ignore-errors (pdf-outline (current-buffer)))
          (progn
            (goto-char (point-max))
            (let ((case-fold-search t))
              (if (search-backward "Index" nil t)
                  (pdf-outline-follow-link-and-quit)
                (pdf-outline-quit)))
            (isearch-forward))
        (pdf-view-goto-page (pdf-cache-number-of-pages))
        (isearch-backward))))
#+end_src

We also add the (generally useful) feature of remembering where we left a PDF when we last closed it. This is especially useful for longer documents, such as manuals, books, or especially long articles.

#+begin_src emacs-lisp
  (use-package pdf-view-restore
    :custom
    (pdf-view-restore-filename (concat user-emacs-directory ".pdf-view-restore"))
    (use-file-base-name-flag nil)
    :hook (pdf-view-mode . pdf-view-restore-mode))
#+end_src

*** LaTeX

It is also possible to configure Emacs to comfortably write and edit LaTeX documents, using the famous tool AUCTeX.

**** General configuration

#+begin_src emacs-lisp
  ;; AUCTeX initialization
  (use-package tex-site
    :ensure auctex) ;; Don't defer, buggy ?

  (use-package tex
    :ensure auctex
    :defer t
    :bind
    (:map TeX-mode-map
          ("C-c '" . TeX-error-overview)
          ("TAB" . lps/cdlatex-tab))
    :hook
    (LaTeX-mode . outline-minor-mode)
    (LaTeX-mode . lps/latex-fontification)
    (LaTeX-mode . lps/latex-add-environments)
    (LaTeX-mode . lps/latex-company-setup)
    (LaTeX-mode . LaTeX-math-mode)
    (LaTeX-mode . TeX-fold-mode)

    :custom
    ;; Automatically insert closing brackets
    (LaTeX-electric-left-right-brace t)
    ;; Parse documents to provide completion
    (TeX-parse-self t)
    ;; Automatically save style information
    (TeX-auto-save t)
    ;; Ask for the master file & don't assume anything
    (TeX-master nil)
    ;; Don't ask permission to save before compiling
    (TeX-save-query nil)
    ;; Automatically insert braces after sub- and superscripts in math mode
    (TeX-electric-sub-and-superscript t)
    ;; Don't insert magic quotes right away.
    (TeX-quote-after-quote t)
    ;; But do insert closing $ when inserting the first one
    (TeX-electric-math '("$" . "$"))
    ;; Also change the key to access LaTeX-math-mode
    (LaTeX-math-abbrev-prefix "Â°")
    ;; Don't ask for confirmation when cleaning
    (TeX-clean-confirm nil)
    ;; AucTeX doesn't search subdirectories for input/include ...
    (TeX-arg-input-file-search 'ask)

    (TeX-source-correlate-method 'synctex)
    (TeX-source-correlate-start-server t)
    (TeX-view-program-selection '((output-pdf "PDF tools")))

    ;; Compilation
    (TeX-debug-bad-boxes t)

    :config
    ;; Improve fontification

    (defun lps/latex-fontification ()
      (set-face-attribute 'font-latex-sedate-face nil :foreground "#aab5b8")
      (font-latex-add-keywords '(("newenvironment" "*{[[")
                                 ("renewenvironment" "*{[[")
                                 ("newcommand" "*|{\\[[")
                                 ("renewcommand" "*|{\\[[")
                                 ("providecommand" "*|{\\[[")
                                 ("fbox" "")
                                 ("mbox" "")
                                 ("sbox" ""))
                               'function))

    ;; SyncTeX forward and inverse search
    (setq TeX-source-correlate-mode t
          ;; Produce a PDF by default
          TeX-PDF-mode t)

    (unless (assoc "PDF tools" TeX-view-program-list-builtin)
      (push '("PDF tools" TeX-pdf-tools-sync-view) TeX-view-program-list))

    ;; Update PDF buffers after successful LaTeX runs
    (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

    ;; Redefine TeX-documentation-texdoc to open the doc in Emacs
    (defun TeX-documentation-texdoc (&optional arg)
      "Run texdoc to read documentation.

  Prompt for selection of the package of which to show the
  documentation.

  If called with a prefix argument ARG, after selecting the
  package, prompt for selection of the manual of that package to
  show."
      (interactive "P")
      (let ((pkg (thing-at-point 'symbol))
            buffer list doc)
        ;; Strip off properties.  XXX: XEmacs doesn't have
        ;; `substring-no-properties'.
        (set-text-properties 0 (length pkg) nil pkg)
        (setq pkg (TeX-read-string "View documentation for: " pkg))
        (unless (zerop (length pkg))
          (progn
            ;; Create the buffer, insert the result of the command, and
            ;; accumulate the list of manuals.
            (with-current-buffer (get-buffer-create
                                  (setq buffer (format "*texdoc: %s*" pkg)))
              (erase-buffer)
              (insert (shell-command-to-string
                       (concat "texdoc --list --nointeract " pkg)))
              (goto-char 1)           ; No need to use `point-min' here.
              (save-excursion
                (while (re-search-forward
                        ;; XXX: XEmacs doesn't support character classes in
                        ;; regexps, like "[:alnum:]".
                        "^ *\\([0-9]+\\) +\\([-~/a-zA-Z0-9_.${}#%,:\\ ()]+\\)" nil t)
                  (push (cons (match-string 1) (match-string 2)) list))))
            (unwind-protect
                (cond
                 ((null (executable-find "texdoc"))
                  ;; Note: `shell-command-to-string' uses shell, only
                  ;; `call-process' looks at `exec-path', thus only here makes
                  ;; sense to use `executable-find' to test whether texdoc is
                  ;; available.
                  (message "texdoc not found"))
                 (list
                  ;; Go on if there are manuals listed: show the buffer, prompt
                  ;; for the number of the manual, then run
                  ;;     texdoc --just-view <doc>
                  (TeX-pop-to-buffer (get-buffer buffer))
                  (condition-case nil
                      (when (setq doc
                                  (cdr (assoc
                                        (if arg (TeX-read-string "Please enter \
  the number of the file to view, anything else to skip: ") "1") list)))
                        (find-file doc))
                    ;; Exit gently if a `quit' signal is thrown.
                    (quit nil)))
                 (t (message "No documentation found for %s" pkg)))
              ;; In any case quit-and-kill the window.
              (kill-buffer buffer))))))

    ;; Redefine TeX-completing-read-multiple
    ;; Might be a bit buggy (return value is not expected to be nil,
    ;; or something along those lines ...) but I prefer having a
    ;; consistent interface, regardless of minor bugs
    (defalias 'TeX-completing-read-multiple 'completing-read-multiple)

    ;; Redefine multi-prompt-value to use completing-read-multiple
    ;; rather than read-from-minibuffer
    ;; This allows Vertico to do its job
    (with-eval-after-load 'multi-prompt
      (defun multi-prompt-key-value
          (prompt table &optional predicate require-match initial-input
                  hist def inherit-input-method)
        "Read multiple strings, with completion and key=value support.
  PROMPT is a string to prompt with, usually ending with a colon
  and a space.  TABLE is an alist.  The car of each element should
  be a string representing a key and the optional cdr should be a
  list with strings to be used as values for the key.

  See the documentation for `completing-read' for details on the
  other arguments: PREDICATE, REQUIRE-MATCH, INITIAL-INPUT, HIST,
  DEF, and INHERIT-INPUT-METHOD.

  The return value is the string as entered in the minibuffer."
        (let* ((minibuffer-completion-table #'multi-prompt-key-value-collection-fn)
               (minibuffer-completion-predicate predicate)
               (minibuffer-completion-confirm
                (unless (eq require-match t) require-match))
               (multi-prompt-completion-table
                ;; Expand the table here because completion would otherwise
                ;; interpret symbols in the table as functions.  However, it
                ;; would be nicer if this could be done during the actual
                ;; completion in order to avoid walking through the whole
                ;; table.
                (multi-prompt-expand-completion-table table))
               (map (if require-match
                        crm-local-must-match-map
                      crm-local-completion-map))
               ;; (input (read-from-minibuffer
               ;;         prompt initial-input map
               ;;         nil hist def inherit-input-method))
               (input (or (completing-read-multiple
                           prompt minibuffer-completion-table
                           predicate require-match initial-input
                           hist def inherit-input-method)
                          "")))
          (and def (string-equal input "") (setq input def))
          input)))

    ;; Function to make TAB more useful !
    ;; Almost taken directly from CDLaTeX, with some parts removed as I don't use them
    (defun lps/cdlatex-tab ()
      "This function is intended to do many cursor movements.
  It is bound to the tab key since tab does nothing useful in a TeX file.

  It jumps to the next point in a LaTeX text where one would reasonably
  expect that more input can be put in.
  To do that, the cursor is moved according to the following rules:

  The cursor stops...
  - before closing brackets if preceding-char is any of -({[]})
  - after  closing brackets, but not if following-char is any of ({[_^
  - just after $, if the cursor was before that $.
  - at end of non-empty lines
  - at the beginning of empty lines
  - before a SPACE at beginning of line
  - after first of several SPACE

  Sounds strange?  Try it out!"
      (interactive)
      (catch 'stop
        (cond
         ((looking-at "}\\|\\]\\|)")
          (forward-char 1)
          (if (looking-at "[^_^({[]")
              ;; stop after closing bracket, unless ^_[{( follow
              (throw 'stop t)))
         ((= (following-char) ?$)
          (while (= (following-char) ?$) (forward-char 1))
          (throw 'stop t))
         ((= (following-char) ?\ )
          ;; stop after first of many spaces
          (forward-char 1)
          (re-search-forward "[^ ]")
          (if (/= (preceding-char) ?\n) (forward-char -1)))
         (t
          (forward-char 1)))

        ;; move to next possible stopping site and check out the place
        (while (re-search-forward "[ )}\n]\\|\\]" (point-max) t)
          (forward-char -1)
          (cond
           ((= (following-char) ?\ )
            ;; stop at first space or b-o-l
            (if (not (bolp)) (forward-char 1)) (throw 'stop t))
           ((= (following-char) ?\n)
            ;; stop at line end, but not after \\
            (if (and (bolp) (not (eobp)))
                (throw 'stop t)
              (if (equal "\\\\" (buffer-substring-no-properties
                                 (- (point) 2) (point)))
                  (forward-char 1)
                (throw 'stop t))))
           (t
            ;; Stop before )}] if preceding-char is any parenthesis
            (if (or (= (char-syntax (preceding-char)) ?\()
                    (= (char-syntax (preceding-char)) ?\))
                    (= (preceding-char) ?-))
                (throw 'stop t)
              (forward-char 1)
              (if (looking-at "[^_\\^({\\[]")
                  ;; stop after closing bracket, unless ^_[{( follow
                  (throw 'stop t))))))))

    ;; Add environment for auto. insertion with C-c C-e
    (defun lps/latex-add-environments ()
      ;;(LaTeX-add-environments '("tikzpicture" LaTeX-env-label)) ; Should be done by auctex's tikz.el file
      )

    ;; Better completion functions
    (defun lps/latex-company-setup () ;; TO FIX !
      (setq-local company-backends '((company-math-symbols-unicode company-math-symbols-latex company-latex-commands company-capf company-dabbrev company-ispell company-yasnippet)))))
#+end_src

**** References

We also configure BibTeX and other packages that allow us to insert quickly bibliography, labels, and various kinds of references in our documents.

#+begin_src emacs-lisp
  (use-package bibtex
    :defer t
    :bind
    (:map bibtex-mode-map
          ("C-c C-?" . bibtex-print-help-message))
    :config
    ;; Use a modern BibTeX dialect
                                          ; (bibtex-set-dialect 'biblatex) ; Useful esp. in social sci.
    )
#+end_src

Another useful package to deal with references, bibliography, citations and so on, is [[https://www.gnu.org/software/emacs/manual/html_mono/reftex.html][RefTeX]].

#+begin_src emacs-lisp
  (use-package reftex
    :diminish
    :hook (LaTeX-mode . reftex-mode)
    :config
    ;; Plug into AUCTeX
    (setq reftex-plug-into-AUCTeX t
          ;; Provide basic RefTeX support for biblatex
          ;; (unless (assq 'biblatex reftex-cite-format-builtin)
          ;;   (add-to-list 'reftex-cite-format-builtin
          ;;                '(biblatex "The biblatex package"
          ;;                           ((?\C-m . "\\cite[]{%l}")
          ;;                            (?t . "\\textcite{%l}")
          ;;                            (?a . "\\autocite[]{%l}")
          ;;                            (?p . "\\parencite{%l}")
          ;;                            (?f . "\\footcite[][]{%l}")
          ;;                            (?F . "\\fullcite[]{%l}")
          ;;                            (?x . "[]{%l}")
          ;;                            (?X . "{%l}"))))
          ;;   (setq reftex-cite-format 'biblatex))
          ))

  (use-package reftex-cite
    :diminish
    :after reftex
    :config
    ;; From https://stackoverflow.com/questions/9682592/setting-up-reftex-tab-completion-in-emacs
    (defun lps/get-bibtex-keys (file)
      (with-current-buffer (find-file-noselect file)
        (mapcar 'car (bibtex-parse-keys))))

    (defun lps/LaTeX-add-all-bibitems-from-bibtex ()
      (interactive)
      (mapc 'LaTeX-add-bibitems
            (apply 'append
                   (mapcar 'lps/get-bibtex-keys (reftex-get-bibfile-list)))))

    ;; Override this function to have a better completion
    (defun reftex--query-search-regexps (default)
      "Query for regexps for searching entries using DEFAULT as default.
  Return a list of regular expressions."
      (split-string
       (let ((orderless-component-separator "[ \t]*&&[ \t]*"))
         (completing-read
          (concat
           "Regex { && Regex...}: "
           "[" default "]: ")
          ;; Ensure default is always in the completion list.
          (let ((def (when default (list default)))
                (coll (if reftex-mode
                          (if (fboundp 'LaTeX-bibitem-list)
                              (progn
                                ;; FIXME: don't do it every time ?
                                (lps/LaTeX-add-all-bibitems-from-bibtex)
                                (LaTeX-bibitem-list))
                            (cdr (assoc 'bibview-cache
                                        (symbol-value reftex-docstruct-symbol))))
                        nil)))
            (if (and def (member def coll))
                coll
              (cons def coll)))
          nil nil nil 'reftex-cite-regexp-hist))
       "[ \t]*&&[ \t]*")))
#+end_src

Finally, we also want a way to do everything from Emacs, and it starts with /finding/ the BibTeX entry that we want to put in our =.bib= file. Hence, we use a package that will look on the Internet for us, and automatically insert the BibTex entries where we need them.

#+begin_src emacs-lisp
  (use-package biblio-core
    :defer t
    :config
    ;; We just override this function, to use our own completion
    ;; system.
    ;; We don't want packages to mess up our config !
    (defun biblio--completing-read-function ()
      completing-read-function))

  (use-package biblio
    :defer t
    :bind
    (:map bibtex-mode-map
          ("C-c ?" . biblio-lookup))
    :custom
    (biblio-arxiv-bibtex-header "article")
    (biblio-download-directory "~/Documents/Other/articles/"))
#+end_src

**** Preview

Instead of recompiling the source code to generate a complete PDF to visualize /e..g/ our mathematical formulas, AUCTeX also gives us the possibility to preview them inlines (as well as other - configurables - constructs, such as figures, matrices, and so on).

#+begin_src emacs-lisp
  (use-package preview
    :ensure nil ;; Comes with AUCTeX
    :defer t
    :config
    (setq preview-auto-reveal t)
    (setq preview-auto-cache-preamble t)
    (add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))
#+end_src

* System
** Eshell
*** General configuration

Contrary to ~term~ and ~shell~ (respectively invoked by =M-x <term/shell>=), [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][eshell]] is not /emulating/ anything: it is, on its own, a shell-like command interpreter implemented in Emacs Lisp. As such, it provides (most of) the usual commands such as ~grep~, ~ls~ and so on, as well as an extra binding to Emacs (for example, you can redirect the output of any command to an Emacs buffer). For this reason, you can use ~eshell~ on any system that is able to run Emacs, as there is no external dependency.

In fact, some of those commands are reimplemented in Emacs Lisp (/e.g./ ~cat~), some of them are using the Emacs tools (for example ~grep~), and unknown commands are passed to the /real/ commandline.

A more in-depth guide can be found [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][here]].

We install a few packages which make eshell easier to use.

#+begin_src emacs-lisp
  ;; eshell
  (use-package eshell-did-you-mean
    :hook (eshell-mode . eshell-did-you-mean-setup))

  (use-package eshell-syntax-highlighting
    :hook (eshell-mode . eshell-syntax-highlighting-mode))

  (use-package eshell
    :ensure nil
    :defer t
    :custom
    (eshell-prefer-lisp-variables t)
    (eshell-prefer-lisp-functions t)
    (eshell-hist-ignoredups t)
    (eshell-scroll-to-bottom-on-input t)
    (eshell-highlight-prompt t)
    (eshell-prompt-function #'lps/eshell-prompt-function)
    (eshell-prompt-regexp "^[^#$\n]* [#$] ")

    :hook (eshell-mode . (lambda ()
                           (bind-key "C-l" 'eshell/clear eshell-mode-map)))

    :bind
    (:map lps/system-tools-map
          ("e" . eshell))

    :config
    ;; From https://blog.liangzan.net/blog/2012/12/12/customizing-your-emacs-eshell-prompt/
    (defun lps/pwd-repl-home (pwd)
      (interactive)
      (let* ((home (expand-file-name (getenv "HOME")))
             (home-len (length home)))
        (if (and
             (>= (length pwd) home-len)
             (equal home (substring pwd 0 home-len)))
            (concat "~" (substring pwd home-len))
          pwd)))

    ;; See the possible colours: M-x list-colors-display
    (defun lps/curr-dir-git-branch-string (pwd)
      "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
      (interactive)
      (when (and (eshell-search-path "git")
                 (locate-dominating-file pwd ".git"))
        (let ((git-output (shell-command-to-string (concat "cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
          (propertize (concat "["
                              (if (> (length git-output) 0)
                                  (substring git-output 0 -1)
                                "(no branch)")
                              "]")
                      'face `(:foreground "green3")))))

    (defun lps/eshell-prompt-function ()
      (concat
       (propertize ((lambda (p-lst)
                      (if (> (length p-lst) 3)
                          (concat
                           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                                      (substring elm 0 1)))
                                      (butlast p-lst 3)
                                      "/")
                           "/"
                           (mapconcat (lambda (elm) elm)
                                      (last p-lst 3)
                                      "/"))
                        (mapconcat (lambda (elm) elm)
                                   p-lst
                                   "/")))
                    (split-string (lps/pwd-repl-home (eshell/pwd)) "/"))
                   'face `(:foreground "DeepSkyBlue1"))
       (or (lps/curr-dir-git-branch-string (eshell/pwd)))
       (propertize " # " 'face 'default))))

  ;; (use-package eshell-git-prompt
  ;;   :config (eshell-git-prompt-use-theme 'powerline)) ;; Visually buggy
#+end_src

*** Bash/Fish completion
We use two packages to have a more powerful completion system in ~eshell~. The UI is akin to the one used by vanilla Emacs - it opens another buffer whenever you try to complete and there are more than one candidates - but it is still usable.

*MANUAL*  The second package, =fish-completion=, needs ~fish~ to be installed on the system (and that a ~fish~ executable can be found on the path).
#+begin_src emacs-lisp
  (use-package bash-completion
    :disabled t
    :hook (eshell-mode . bash-completion-setup))

  (use-package fish-completion
    :defer t
    :hook (eshell-mode . lps/start-fish-completion)
    :config
    (defun lps/start-fish-completion ()
      (when (executable-find "fish")
        (setq-local company-backends '(company-capf))
        (define-key eshell-mode-map (kbd "TAB") 'company-manual-begin)
        (fish-completion-mode 1)
        (setq fish-completion-fallback-on-bash-p t))))
#+end_src

Another method, which tries to simulate the completion mechanism of ~fish~ shells, and which also provides suggestions based on history:

#+begin_src emacs-lisp
  ;; Straight from Centaur Emacs
  (use-package esh-autosuggest
    :disabled t
    :defer t
    :hook (eshell-mode . esh-autosuggest-mode)
    :custom
    (esh-autosuggest-use-company-map t))
#+end_src

*** Aliases and commands
**** Aliases from .bashrc
*MANUAL* One thing that we might want to do is to be able to use aliases defined in =.bashrc= in ~eshell~. There are [[https://www.emacswiki.org/emacs/EshellAlias][several solutions]] to this problem, and the one I use only allows us to use bash aliases in ~eshell~ and not the contrary, for example.

We can do this by adding the following line at the end of the =.bashrc= file:

#+begin_src sh
  alias | sed -E "s/^alias ([^=]+)='(.*)'$/alias \1 \2 \$*/g; s/'\\\''/'/g;" >~/.emacs.d/eshell/alias
#+end_src

It will simply go through the =.bashrc= file whenever you open a bash terminal, and each time it sees a line starting with ~alias~, it will generate the corresponding alias in an appropriate syntax and put it in the =eshell/alias= file where ~eshell~ reads its aliases. This is not a very convincing solution for a few reasons, the main ones being that this process is executed "from the bash side" (and so requires us to start a bash shell or to at least execute the =.bashrc= file), and that it overrides the =eshell/alias= file each time.

Another solution is to parse the aliases each time we start ~eshell~. We do this by reading the =.bashrc= file and extracting the aliases.

#+begin_src emacs-lisp
  ;; Inspired from https://github.com/daviderestivo/load-bash-alias/blob/master/load-bash-alias.el
  ;; WARNING: it is not very robust, and might mess up if bash aliases involve
  ;; complex nested single or double quotes !
  (defun lps/eshell-load-bash-aliases ()
    "Reads bash aliases from ~/.bashrc and inserts
        them into the list of eshell aliases."
    (interactive)
    (let ((bashfile "~/.bashrc"))
      (if (file-exists-p bashfile)
          (with-temp-buffer
            (progn
              (insert-file-contents bashfile)
              ;; Merge continuation lines into single line. The below regexp
              ;; matches a '\' at the end of a line followed by one or
              ;; multiple TAB or spaces.
              (while (re-search-forward "\\\\[ \t]*\n" nil t)
                (replace-match ""))
              ;; Return a list of lines
              (let* ((bashfile-lines (split-string (buffer-string) "\n" t))
                     (bashfile-aliases (cl-remove-if-not (lambda (str)
                                                           (string-match-p "^alias" str))
                                                         bashfile-lines)))
                (dolist (line bashfile-aliases)
                  (let* ((trimmed (replace-regexp-in-string "=\\|[ \t]+" " " line))
                         (alias-def (string-trim-left trimmed "^alias "))
                         (first-split (string-search " " alias-def))
                         (alias-name (substring alias-def 0 first-split))
                         (alias-definition-1 (substring alias-def (1+ first-split)))
                         (rem-quotes-regexp "['\"]")
                         (alias-definition-trimmed (string-trim alias-definition-1
                                                                rem-quotes-regexp
                                                                rem-quotes-regexp)))
                    (eshell/alias alias-name (eshell-flatten-and-stringify alias-definition-trimmed)))))))
        (message "File ~/.bashrc not found, no aliases were loaded"))))

  (add-hook 'eshell-mode-hook 'lps/eshell-load-bash-aliases)
#+end_src

**** Specific to Eshell
Some of our aliases will come from =.bashrc=. However, we still want to add aliases that make sense in ~eshell~.
#+begin_src emacs-lisp
  (use-package em-alias
    :ensure nil
    :hook (eshell-mode . lps/eshell-add-aliases)
    :config
    (defun lps/eshell-add-aliases ()
      (eshell/alias "f" "find-file $1")
      (eshell/alias "fo" "find-file-other-window $1")
      (eshell/alias "d" "dired $1")
      ;; Used for sudo and some other commands
      (require 'em-tramp)
      (eshell/alias "sudo" "eshell/sudo $*")))
#+end_src

** Dired

Now, we try to add things on top of the built-in file manager, Dired.

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :defer t
    :init
    (setq delete-by-moving-to-trash t)
    ;; Prevents dired from opening thousands of buffers
    :bind
    (:map dired-mode-map
          ("RET" . dired-find-alternate-file)
          ("^" . lps/dired-up-directory-same-buffer)
          ("F" . find-name-dired))
    :custom
    ;; Delete and copy directories recursively
    (dired-recursive-deletes 'top)
    (dired-recursive-copies 'always)
    (dired-auto-revert-buffer t)
    (dired-listing-switches "-alFh")

    :config
    (defun lps/dired-up-directory-same-buffer ()
      (interactive)
      (find-alternate-file "..")))

  ;; Make things prettier
  (use-package all-the-icons-dired
    :diminish
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-x
    :ensure nil
    :after dired)
#+end_src

Dired can also be used to search for files, using their names or their content.
Because those are useful functions, we bind them globally.

#+begin_src emacs-lisp
  (use-package find-dired
    :ensure nil
    :bind
    (:map lps/system-tools-map
          ("f f" . find-name-dired)
          ("f g" . find-grep-dired)
          ("f l" . locate)
          ("f L" . locate-with-filter)))
#+end_src

** Tools
*** Disk usage
Although ~Dired~ is a powerful tool, it still lacks a neat feature, namely, it doesn't show the /recursive/ size of the folders. We can usually do one of two things: either write a lot of Elisp to include this into ~Dired~ (and risk breaking things), or use a shell and functions such as ~du~. We choose a third way, which consists in using a standalone package doing exactly what we want, with extra functionalities, such as interactive sorting and filtering, deletion of files, and so on, all within the same buffer.

#+begin_src emacs-lisp
  (use-package disk-usage
    :defer t
    :bind
    (:map lps/system-tools-map
          ("d" . disk-usage)))
#+end_src

*** Processes

There are two usual ways to interact with processes via Emacs. The first one is ~proced~, which lists all the processes running on the system, and the other is ~list-processes~, which only lists subprocesses ran by Emacs (such as a PDF server, a mail indexer, and so on)

#+begin_src emacs-lisp
    (use-package proced
      :ensure nil
      :bind
      (:map lps/system-tools-map
            ("p p" . proced))
      (:map proced-mode-map
            ("a" . proced-toggle-auto-update)))

    (use-package emacs
      :ensure nil
      :bind
      (:map lps/system-tools-map
            ("p l" . list-processes)))
#+end_src

* Email
** mbsync

We already configured Emacs to be our main Git client, and to be a PDF Viewer. We can go one step further, and use Emacs as a mail client.

There are already built-in tools to do this, for example [[https://www.gnus.org/][Gnus]]. However, they tend to be slow, and there are better alternatives. The one we use is combines several tools.

First of all, ~mbsync~. It synchronizes a local database to a distant one. It can be configured using the =~/.mbsyncrc= file. It is an alternative to ~offlineimap~, which is apparently slower and tends to crash a bit more.

*MANUAL* ~mbsync~ needs to be installed separately. It might be available in the ~isync~ package.

** mu4e

The actual mail client that we use is a frontend to =mu=, called [[https://github.com/djcb/mu/tree/master/mu4e][mu4e]]. Depending on your Linux distribution, you might encounter some troubles with the following code, as the syntax might have changed between the versions =1.2= and =1.3=.

*MANUAL* You need to install ~mu4e~ separately, either from the standard repositories of your distribution or directly from source. Once installed, you will need to execute a few commands to initialize everything, so please refer to the package documentation.

#+begin_src emacs-lisp
  (use-package smtpmail
    :ensure nil
    :after mu4e
    :config
    (setq message-send-mail-function 'smtpmail-send-it)
    ;; Default SMTP configuration
    (setq smtpmail-debug-info t)
    (setq smtpmail-smtp-user "lpaviets")
    (setq smtpmail-smtp-server "smtp.ens-lyon.fr")
    (setq smtpmail-smtp-service 587)
    (setq smtpmail-stream-type 'starttls))

  (use-package mu4e
    :ensure nil
    :load-path "/usr/local/share/emacs/site-lisp/mu4e" ;; Might be needed.
    :commands mu4e
    :bind (("C-c e" . mu4e)
           :map mu4e-compose-mode-map
           ("C-c h" . lps/org-mime-htmlize-preserve-secure-and-attach)
           (:map mu4e-main-mode-map
                 ("q" . lps/mu4e-kill-buffers)
                 ("Q" . mu4e-quit)))
    :init
    (setq mail-user-agent 'mu4e-user-agent)
    (set-variable 'read-mail-command 'mu4e)
    :config
    (defvar lps/safe-mail-send t "If non-nil, ask for a signature, an encryption, and ask confirmation when sending a non-multipart MIME mail")

    (setq mu4e-completing-read-function 'completing-read)

    ;; Security issues
    (add-hook 'mu4e-main-mode-hook #'lps/auth-source-define-cache-expiry)

    ;; Might avoid unwanted drafts
    (add-hook 'mu4e-compose-mode-hook #'(lambda () (auto-save-mode -1)))

    ;; Convenience functions
    (setq mu4e-compose-context-policy 'always-ask)
    (setq mu4e-context-policy 'pick-first)
    (setq message-kill-buffer-on-exit t)
    (setq mu4e-confirm-quit nil)

    ;; View images
    (setq mu4e-view-show-images t)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    ;; ASCII-only time is over
    (setq mu4e-use-fancy-chars t)

    ;; Unless we want to send mail to very old clients
    (setq mu4e-compose-format-flowed t)

    ;; Avoid mail syncing issues with mbsync
    (setq mu4e-change-filenames-when-moving t)

    ;; Refresh mail every 5 minutes
    (setq mu4e-update-interval (* 5 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-index-update-in-background t)
    (setq mu4e-hide-index-messages t)

    ;; Always show full date and time
    (setq mu4e-headers-date-format "%d-%m-%Y %H:%M")

    ;; Less redundant information
    (setq mu4e-headers-include-related nil)
    (setq mu4e-headers-show-threads nil)

    ;; Keep one mail per line
    ;; Todo: fix so that it updates when window is resized
    (setq mu4e-headers-fields '((:human-date . 20)
                                (:flags . 6)
                                (:mailing-list . 10)
                                (:from-or-to . 22)
                                (:subject . 100)))

    (defun lps/resize-headers-fields ()
      (if (eq major-mode 'mu4e-headers-mode)
          (let ((width (window-body-width)))
            (setq-local mu4e-headers-fields `((:human-date . 20)
                                              (:flags . 6)
                                              (:mailing-list . 10)
                                              (:from-or-to . 22)
                                              (:subject . ,(- width (+ 20 6 10 22 15))))))))

    (add-hook 'mu4e-headers-mode-hook #'lps/resize-headers-fields)

    ;; Change: obsolete variable
    (setq mu4e-maildir "~/Mail")

    ;; Adapted from https://jherrlin.github.io/posts/emacs-mu4e/
    ;; See also https://etienne.depar.is/emacs.d/mu4e.html
    (setq mml-secure-cache-passphrase nil)
    ;;(setq mml-secure-openpgp-sign-with-sender t)
    (setq mml-secure-openpgp-encrypt-to-self t)
    ;;(setq mml-secure-smime-sign-with-sender t)
    (setq mml-smime-encrypt-to-self t) ;; encryption is not ready yet

    (setq mm-sign-option 'guided)

    (defun lps/sign-or-encrypt-message ()
      (when lps/safe-mail-send
        (let ((answer (read-from-minibuffer (concat "Sign or encrypt?\n"
                                                    "Empty to do nothing.\n[s/e]: "))))
          (cond
           ((string-equal answer "s") (progn
                                        (message "Sign this message.")
                                        ;; Why doesn't mml-secure-message-sign-pgpmime work ... ?
                                        (mml-secure-message-sign-pgpmime) ;;Works but only signs a part of the message.
                                        (message "Done trying to sign the message")))
           ((string-equal answer "e") (progn
                                        (message "Encrypt and sign this message.")
                                        (mml-secure-message-encrypt-pgpmime)
                                        (message "Done trying to encrypt the message")))
           (t (progn
                (message "Not signing or encrypting this message.")
                nil))))))

    (add-hook 'message-send-hook 'lps/sign-or-encrypt-message)


    ;; Before making a new context:
    ;; - Make sure that the [sent/trash/drafts] folders are correctly named, to avoid duplicates
    ;; - Don't forget to modify .mbsyncrc and .authinfo.gpg to correctly authenticate against
    ;; the IMAP and SMTP servers
    ;; - Make sure that your smpt-user ID, the port (smtp-service), etc, are the right ones; different
    ;; SMTP servers have different expectations, and there is no universal configuration
    (setq mu4e-contexts
          (list
           ;; School account
           (make-mu4e-context
            :name "Unicaen"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/Unicaen" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address  . "leo.paviet-salomon@unicaen.fr")
                    (user-full-name     . "Leo Paviet Salomon")
                    (mu4e-drafts-folder . "/Unicaen/Drafts")
                    (mu4e-sent-folder   . "/Unicaen/Sent")
                    (mu4e-refile-folder . "/Unicaen/Archive")
                    (mu4e-trash-folder  . "/Unicaen/Trash")
                    (smtpmail-smtp-user    . "paviets201")
                    (smtpmail-smtp-server  . "smtp.unicaen.fr")
                    (smtpmail-smtp-service . 465)
                    (smtpmail-stream-type  . ssl)))

           (make-mu4e-context
            :name "Orange"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/Orange" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address  . "leo.paviet.salomon@orange.fr")
                    (user-full-name     . "Leo Paviet Salomon")
                    (mu4e-drafts-folder . "/Orange/DRAFT")
                    (mu4e-sent-folder   . "/Orange/OUTBOX")
                    (mu4e-refile-folder . "/Orange/Archive")
                    (mu4e-trash-folder  . "/Orange/TRASH")
                    (smtpmail-smtp-user    . "leo.paviet.salomon@orange.fr")
                    (smtpmail-smtp-server  . "smtp.orange.fr")
                    (smtpmail-smtp-service . 465)
                    (smtpmail-stream-type  . ssl)))

           (make-mu4e-context
            :name "ENS_Lyon"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/ENS_Lyon" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address  . "leo.paviet-salomon@ens-lyon.fr")
                    (user-full-name     . "Leo Paviet Salomon")
                    (mu4e-drafts-folder . "/ENS_Lyon/Brouillons")
                    (mu4e-sent-folder   . "/ENS_Lyon/Elements_envoyes")
                    ;;(mu4e-sent-messages-behavior . 'delete) ;; Not sure yet, better be safe
                    (mu4e-refile-folder . "/ENS_Lyon/Archive")
                    (mu4e-trash-folder  . "/ENS_Lyon/Corbeille")
                    (smtpmail-smtp-user    . "lpaviets")
                    (smtpmail-smtp-server  . "smtp.ens-lyon.fr")
                    (smtpmail-smtp-service . 587)
                    (smtpmail-stream-type  . starttls)))))

    ;; Bookmarks
    (add-to-list 'mu4e-bookmarks `(:name
                                   "Important"
                                   :query ,(concat "maildir:/Orange/Important"
                                                   " OR "
                                                   "maildir:/Unicaen/Important"
                                                   " OR "
                                                   "maildir:/ENS_Lyon/Important")
                                   :key   ?i)
                 t)

    ;; Taken from mu4e~stop in mu4e-utils.el
    ;; Do not kill mu process
    (defun lps/mu4e-kill-buffers ()
      "Kill all mu4e buffers"
      (interactive)
      ;; kill all mu4e buffers
      (mapc
       (lambda (buf)
         ;; When using the Gnus-based viewer, the view buffer has the
         ;; kill-buffer-hook function mu4e~view-kill-buffer-hook-fn which kills the
         ;; mm-* buffers created by Gnus' article mode.  Those have been returned by
         ;; `buffer-list' but might already be deleted in case the view buffer has
         ;; been killed first.  So we need a `buffer-live-p' check here.
         (when (buffer-live-p buf)
           (with-current-buffer buf
             (when (member major-mode
                           '(mu4e-headers-mode mu4e-view-mode mu4e-main-mode))
               (kill-buffer)))))
       (buffer-list))

      ;; Update mail and index when leaving
      (unless (and (buffer-live-p mu4e--update-buffer)
                   (process-live-p (get-buffer-process mu4e--update-buffer)))
        (mu4e-update-mail-and-index t))))
#+end_src

Because it might be a bit tedious to constantly open and quit the ~mu4e~ buffers to check for incoming messages, we use another package to get notifications informing us when we receive a new message.
This package might also be used to generate desktop notifications, although I do not use this functionality.

#+begin_src emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :config
    ;; Temporary fix: mu4e and mu4e-alert are out of sync
    ;; while mu4e changes its naming conventions from the
    ;; old mu4e~<stuff> to mu4e--<stuff>

    (defadvice mu4e-context-switch (around mu4e-alert-update-mail-count-modeline disable)
      "Advice `mu4e-context-switch' to update mode-line after changing the context."
      (let ((context mu4e--context-current))
        ad-do-it
        (unless (equal context mu4e--context-current)
          (mu4e-alert-update-mail-count-modeline))))

    (mu4e-alert-enable-mode-line-display))
#+end_src

  One point that is a bit infuriating with the current state of ~mu4e~ is how you are supposed to manage attachments. In particular, you have to navigate in a whole filetree, everytime you want to attach a file. To my knowledge, there is no "easy and immediate" way to /e.g./ attach several files at once.

  To patch this, we use a few tricks, with ~ivy~ and ~gnus-dired~

#+begin_src emacs-lisp
  ;; From https://github.com/iqbalansari/dotEmacs/blob/master/config/mail.org
  (use-package gnus-dired
      :ensure nil
      :after mu4e
      :hook (dired-mode . turn-on-gnus-dired-mode)
      :config
      ;; This overrides a function !
      (defun gnus-dired-mail-buffers ()
        "Return a list of active message buffers."
        (let (buffers)
          (save-current-buffer
            (dolist (buffer (buffer-list t))
              (set-buffer buffer)
              (when (and (derived-mode-p 'message-mode)
                         (null message-sent-message-via))
                (push (buffer-name buffer) buffers))))
          (nreverse buffers)))

      (setq gnus-dired-mail-mode 'mu4e-user-agent))


  (use-package dired
      :ensure nil
      :after gnus-dired
      :bind (:map dired-mode-map
                  ("E" . lps/mu4e-file-attach-marked-files))
      :config
      (defun lps/mu4e-file-attach-marked-files ()
        (interactive)
        (gnus-dired-attach (dired-map-over-marks (dired-get-file-for-visit) nil))))
#+end_src

** Org MIME

~mu4e~ in itself is not really able to send HTML e-mails. However, it is nowadays a given that people you are sending e-mails too are going to be able to visualize HTML-ized content, and they might even /assume/ that this is the case - meaning that a plain text e-mail will loo strange and/or unprofessional.

To deal with this problem, we use a ~org~ package, called [[https://github.com/org-mime/org-mime][Org MIME]], which uses the MIME protocol to encode the content of our email. Moreover, it allows us to write e-mails with the full power of ~org-mode~'s syntax and editing tools, and directly export them in HTML.

#+begin_src emacs-lisp
  (use-package org-mime
    :after mu4e
    :config
    (defun lps/safe-org-mime-confirm-when-no-multipart ()
      (when lps/safe-mail-send
        (org-mime-confirm-when-no-multipart)))

    ;; Make sure that this hook is added AFTER lps/sign-or-encrypt-message
    ;; so that it is executed BEFORE it.
    ;; We want to htmlize, then sign/encrypt, not the other way around !
    (add-hook 'message-send-hook 'lps/safe-org-mime-confirm-when-no-multipart)
    (setq org-mime-export-options'(:section-numbers nil
                                                    :with-author nil
                                                    :with-toc nil))

    ;; Hacky function to avoid big formatting problems when calling org-mime-htmlize
    ;; after having linked attachments, or signing/encrypting the message
    (defun lps/org-mime-htmlize-preserve-secure-and-attach ()
      (interactive)
      (let ((re-secure "<#secure method=[a-z]+ mode=[a-z]+>\n?")
            (re-attachment "<#part type=.* disposition=attachment.*>\n?<#/part>\n?")) ;; make sure that \n needs no escaping/formatting
        (let ((secure (lps/find-delete-forward-all-regexp re-secure (point-min)))
              (attachments (lps/find-delete-forward-all-regexp re-attachment (point-min))))
          (org-mime-htmlize)
          (save-excursion
            (goto-char (point-max))
            (while attachments
              (insert (pop attachments)))
            (message-goto-body)
            (while secure
              (insert (pop secure))))))))
#+end_src

* Web
** Gemini
An alternative to the traditional HTTP-world wide web, using a simpler protocol. See what [[https://drewdevault.com/][Drew DeVault]] has to say about it on his blog !
#+begin_src emacs-lisp
  (use-package elpher)
#+end_src

* Reading and writing

Emacs is, obviously, quite good at dealing with text. Hence, it is natural to wonder whether there are packages conceived to make reading (or writing !) books or long articles more pleasant. Indeed, there are !

#+begin_src emacs-lisp
  (use-package olivetti
    :defer t
    :custom
    (olivetti-body-width 90))
#+end_src

In fact, we can even read EPUB files with Emacs.

#+begin_src emacs-lisp
  (use-package nov
    :defer t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    :custom
    (nov-variable-pitch t)
    (nov-text-width t)
    :config
    (defun lps/nov-mode-comfort-settings ()
      (setq visual-fill-column-width 90)
      (setq visual-fill-column-center-text t)
      (visual-line-mode 1)
      (visual-fill-column-mode 1))
    (add-hook 'nov-mode-hook #'lps/nov-mode-comfort-settings))
#+end_src

** Spelling

Emacs comes with a few ways to do spell checking and does a good job at highlighting mistakes with /e.g./ =flyspell-mode=. For that reason, we mainly add a few wrappers around this built-in functionality, mostly for convenience.

#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :bind
    (:map flyspell-mode-map
          ("C-$" . flyspell-correct-wrapper)))
#+end_src

#+begin_src emacs-lisp
  (use-package ispell
    :defer t
    :bind
    ("<f8>" . ispell)
    ("S-<f8>" . ispell-change-dictionary)
    ("C-S-<f8>" . lps/flyspell-toggle)
    :config
    (add-to-list 'ispell-skip-region-alist '("^#+BEGIN_SRC" . "^#+END_SRC"))

    ;; From https://www.emacswiki.org/emacs/FlySpell
    (defun lps/flyspell-on-for-buffer-type ()
      "Enable Flyspell appropriately for the major mode of the current
  buffer. Uses `flyspell-prog-mode' for modes derived from `prog-mode', so
  only strings and comments get checked. All other buffers get `flyspell-mode'
  to check all text. If flyspell is already enabled, does nothing."
      (interactive)
      (when flyspell-mode ; if not already on
        (if (derived-mode-p 'prog-mode)
            (progn
              (message "Flyspell on (code)")
              (flyspell-prog-mode 1))
          (progn
            (message "Flyspell on (text)")
            (flyspell-mode 1)))))

      (defun lps/flyspell-toggle ()
        "Turn Flyspell on if it is off, or off if it is on.
  When turning on, it uses `lps/flyspell-on-for-buffer-type' so code-vs-text
  is handled appropriately."
        (interactive)
        (if flyspell-mode
            (progn
              (message "Flyspell off")
              (flyspell-mode -1))
          (lps/flyspell-on-for-buffer-type))))
#+end_src

Depending on the context, we tend to write in different languages. It might be useful to try and automatically guess which one !

#+begin_src emacs-lisp
  (use-package guess-language
    ;;:hook (text-mode . guess-language-mode)
    :custom
    (guess-language-languages '(en fr))
    (guess-language-after-detection-functions '(guess-language-switch-flyspell-function)))
#+end_src

* Fun
As we tend to spend a lot of time in Emacs, isn't it natural to install fun and distracting packages ?
** XKCD
We /love/ [[https://xkcd.com][XKCD]], and so do most of Emacs users. Hence, someone has written a package to read his favourite web-comic directly within Emacs !

#+begin_src emacs-lisp
  (use-package xkcd
    :defer t)
#+end_src

** Keyboard games
*** Speed-typing
This package can help you benchmark how fast you are able to write text within Emacs, by using random text samples that you have to copy. It is even possible to add some other books from which to generate those samples.

#+begin_src emacs-lisp
  (use-package speed-type
    :defer t
    :custom (speed-type-default-lang 'French)) ; Todo: fix bad behaviour !
#+end_src

*** Key Quiz

Another cool thing to do if you want to learn keybindings in a very inefficient way is to simply pick a command at random and try to remember the associated keybinding ! This is exactly what the following package tries to do

#+begin_src emacs-lisp
  (use-package key-quiz
    :defer t)
#+end_src

* News and RSS feed
** Elfeed
Because it is text-oriented, Emacs is a completely viable option to be a RSS feed reader. Indeed, it can display, search, filter ... all the different information that you can expect when using RSS feeds, but you also have the whole power of Emacs to configure everything according to your need, /e.g./ infinite flexibility for search filters, bookmarks and so on.

#+begin_src emacs-lisp
  (use-package elfeed
    :defer t
    :bind
    ("C-c f" . elfeed)
    :custom
    (elfeed-db-directory (concat user-emacs-directory ".elfeed"))
    (elfeed-search-title-max-width 110)
    :config
    (setq-default elfeed-search-filter "@1-week-ago +unread "))
#+end_src

As the default syntax to manage and organize the various RSS feeds is a bit tedious, we use another package which this whole process painless.

#+begin_src emacs-lisp
  (use-package elfeed-org
    :after elfeed
    :config
    (setq rmh-elfeed-org-files '("~/Documents/OrgFiles/elfeed.org"))
    (elfeed-org))
#+end_src

* TODO Small things to do or to fix
** Elfeed
Find a neat way to have bookmarks/pre-configured filters.
