#+title: Emacs Configuration
#+author: Léo Paviet Salomon
#+STARTUP: content
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Organization of this file

  This file contains a Emacs configuration, written in a Org Mode document. It is largely based on [[https://github.com/daviwil/emacs-from-scratch/][Emacs From Scratch]].

  It is able to automatically generate a init.el file, loaded by Emacs at startup.

  If this file is on the path "~/.emacs.d/emacs-config.org" then it will automatically generate an output. To modify this behaviour, see the "Org Mode/Auto-tangle configuration files" subsection and modify it as you need.

  If this file is named differently on your system, or simply located in another directory, you can still generate an output without changing anything by invoking the =org-babel-tangle= command (=C-c C-v t=).

  Because I use a version system on those files, I don't mind conflicts with the currently loaded configuration file, and so the the generated file is actually called  =init.el=. By default, Emacs reads (and loads) file such as "~/.emacs" or "~/.emacs.d/init.el" at startup, so the output of =org-babel-tangle= is automatically replacing the previous configuration file. If you want to avoid those conflicts, you might need to rename it.

  To modify the name of the output, you can change it in the second line of this document, after the =:tangle= keyword.

  Some commands have to be run manually whenever the generated =init.el= file is loaded for the first time.

  Whenever this is the case, it is explicitly signaled by the presence of the *MANUAL* keyword in front of those commands.

  If the init.el cannot be properly loaded at startup, try to search for such keywords in this file and execute the corresponding commands.

* Initialization
** Emacs performance

First, we set things up so that Emacs starts /fast/.

#+begin_src emacs-lisp
(setq gc-cons-threshold 100000000) ; 1e8 = 100 MB (default: 800kB)
#+end_src

Another thing that might be of interest is to know how long it took for Emacs to start. Although there is already a built-in function to do this (try to call =emacs-init-time= in any Emacs session), we want it to be automatically displayed anytime we start Emacs

#+begin_src emacs-lisp
  (defun lps/display-startup-time ()
    (message "Emacs started in %s seconds"
             (format "%.2f"
                     (float-time
                      (time-subtract after-init-time before-init-time)))))

  (defun lps/display-garbage-collection ()
    (message "Emacs performed %d garbage collection"
             gcs-done))

  (defun lps/restore-gc-cons ()
    ;; After startup, we restore gc-cons-threshold to a more reasonable value
    (setq gc-cons-threshold 10000000)) ; 1e7 = 10 MB

  (setq read-process-output-max (* 8 1024 1024)) ;; 2mb

  (add-hook 'emacs-startup-hook #'lps/display-startup-time)
  (add-hook 'emacs-startup-hook #'lps/display-garbage-collection)
  (add-hook 'emacs-startup-hook #'lps/restore-gc-cons)

#+end_src

** Package management

Then, we need to configure how we will install packages. We use another package manager that the default one: =use-package=.

It makes both installation and customization easier, and the code is also simpler to read.

*MANUAL* You might want to configure =use-package= differently, as it is the tool used everywhere else in this configuration file to install and setup other packages. For example, the line
=(setq use-package-always-ensure t)= is used to install all the packages mentioned in this file automatically if you do not already have them. Depending on your environment, you might want to consider another, more appropriate behaviour (/e.g./  if you lack space, time, if you use another OS, if you are already compiling some of those packages by yourself, and so on).

#+begin_src emacs-lisp
  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))

  ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; Other packages
  (add-to-list 'load-path "~/.emacs.d/extra-packages")

  (require 'use-package)
  ;; Comment this line if you don't want to automatically install
  ;; all the packages that you are missing
  (setq use-package-always-ensure t)
  ;; Uncomment the folllowing line to have a detailed startup log
  ;; (setq use-package-verbose t)

#+end_src

In order to benchmark the package loading, we use [[https://github.com/dholm/benchmark-init-el][benchmark-init.el]]

#+begin_src emacs-lisp
  (use-package benchmark-init
    :disabled t
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+end_src

** Security

Emacs is not very secure as such. We try to fix this as best as we can.

First, we don't want data to be saved across Emacs session.
#+begin_src emacs-lisp
  (add-hook 'kill-emacs-hook #'auth-source-forget-all-cached)
#+end_src
** Quick restart

In order to test things more rapidly and to be able to apply configuration changes without ever leaving Emacs, we also install another package to restart Emacs with a simple command.

#+begin_src emacs-lisp
  (use-package restart-emacs
    :commands (restart-emacs restart-emacs-start-new-emacs))
#+end_src

** Custom file

We do not want Emacs to mess with our own =init.el= file, and so we tell it where to store all its precious customizations

#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom-file.el"))
  (load custom-file 'noerror)
#+end_src

* UI Configuration
** Visual interface changes

We remove all the unnecessary elements from the interface, /e.g./ menus, scroll bar and so on.

You can remove or partially modify this block of code if you are a beginner and want to keep some of elements available, especially to be able to navigate with the mouse.

All the variable names are pretty explicit, so you should be able to customize this to your taste easily.

*** Startup

Who wants to be told the same thing over and over again each time they start Emacs ?
#+begin_src emacs-lisp
  ;; Disable the annoying startup message and Emacs logo
  (setq inhibit-startup-message t)

  ;; Disable the message on top of the Scratch buffer
  (setq initial-scratch-message nil)
#+end_src

However, we would like to see Emacs in full-screen if we are to use it

#+begin_src emacs-lisp
  ;; Maximize the Emacs frame at startup
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Because we tend to use ~eshell~ for everything that is shell-related (see the Eshell section later in this file), we also start it whenever we start Emacs.
#+begin_src emacs-lisp
  ;; No need to slow down the startup
  ;; (add-hook 'emacs-startup-hook (lambda () (eshell) (previous-buffer)))
#+end_src

*** Menus and toolbars

Emacs is very much keyboard-oriented. As such, we have little-to-no use of the various menus, toolbars and scrollbars that Emacs provides.

#+begin_src emacs-lisp
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)          ; Disable the menu bar
#+end_src

*** Lines and columns

Because we now have plenty of free space on our screen, we can sacrifice a bit of it to put useful information there, such as line numbers. We also want to see the current line and column in the modeline.

#+begin_src emacs-lisp
  ;; Global line/column numbering mode
  ;; Modes in which we might want to disable it:

  (column-number-mode t)
  (global-display-line-numbers-mode t)

  (defun my-disable-line-numbers ()
    (display-line-numbers-mode 0))

  (dolist (mode '(org-mode-hook
                 ; Term & Shells
                  eshell-mode-hook
                  comint-mode-hook
                  ; PDF viewers
                  pdf-view-mode-hook
                  doc-view-mode-hook
                  ; Help modes
                  helpful-mode-hook
                  help-mode-hook
                  apropos-mode-hook
                  ; Extra modes
                  undo-tree-visualizer-mode-hook
                  treemacs-mode-hook
                  dired-mode-hook))

  (add-hook mode #'my-disable-line-numbers))
#+end_src

While we are at it, we also want Emacs to wrap our lines, so that we never have to scroll horizontally to see the end of a long line (besides, how would we do it, now that we don't have a scrollbar anymore ?!)

#+begin_src emacs-lisp
(global-visual-line-mode 1)
#+end_src

*** Theme

This is simply a way to change how Emacs looks. Some themes are more complete than other (they will modify how other packages look, like Magit, or even the minibuffer)

#+begin_src emacs-lisp
    ;; Themes
  (use-package solarized-theme)
  (use-package kaolin-themes)
  (use-package modus-themes)
  (use-package doom-themes)

  (setq lps/default-theme 'kaolin-ocean)
  (load-theme lps/default-theme t)
#+end_src

There used to be a package called [[https://github.com/toroidal-code/cycle-themes.el][cycle-themes]] that would allow you to cycle through all (or a predefined list of) your themes, but it seems that it no longer works due to some other packages becoming deprecated. Here is a small function that does the same thing.

#+begin_src emacs-lisp
  ;; Use this to store your favourite themes
  ;; Save your usual, default theme in first position
  ;; so that you can easily switch back to it with
  (setq lps/rotate-themes-list
        '(doom-Iosvkem
          kaolin-ocean
          kaolin-aurora
          doom-palenight
          tsdh-dark
          solarized-dark
          modus-vivendi))

  ;; Try to save the current theme
  ;; Be careful ! Some visual changes are NOT stored in
  ;; a theme, and will not be retrieved by the restoring
  ;; functions. For example, any font configuration might
  ;; be "lost" for this session
  (setq lps/initial-enabled-themes custom-enabled-themes)

  (setq lps/rotate-theme-index 0)

  ;; Still a bit buggy: forgets all the customizations done to e.g. Org Mode
  (defun lps/rotate-through-themes ()
    "Cycles through the next theme in the `lps/rotate-themes-list'.
  If this list is empty or does not exist, cycle through all the
  installed themes instead."
    (interactive)
    (mapc #'disable-theme lps/initial-enabled-themes)
    (let* ((themes-list (or (and (boundp 'lps/rotate-themes-list) lps/rotate-themes-list)
                            (custom-available-themes)))
           (next-index (mod (+ lps/rotate-theme-index 1) (length themes-list)))
           (current-theme (nth lps/rotate-theme-index themes-list))
           (next-theme (nth next-index themes-list)))
      (setq lps/rotate-theme-index next-index)
      (disable-theme current-theme)
      (load-theme next-theme t)))

  (defun lps/restore-initial-themes ()
    (interactive)
    (mapc #'disable-theme custom-enabled-themes)
    (mapc (lambda (theme) (funcall #'load-theme theme t)) lps/initial-enabled-themes)
    (my-org-mode-setup))
#+end_src

*** Modeline and icons

This modifies how the [[https://www.emacswiki.org/emacs/ModeLine][modeline]] looks.

*MANUAL* If this is your first time running the init.el file, please run the following command:

=M-x all-the-icons-install-fonts=

#+begin_src emacs-lisp
  ;; First time used: run M-x all-the-icons-install-fonts
  (use-package all-the-icons
    :config
    ;; Avoid unnecessary warnings
    (declare-function all-the-icons-faicon 'all-the-icons)
    (declare-function all-the-icons-fileicon 'all-the-icons)
    (declare-function all-the-icons-material 'all-the-icons)
    (declare-function all-the-icons-octicon 'all-the-icons)

    ;;define an icon function with all-the-icons-faicon
    ;;to use filecon, etc, define same function with icon set
    (defun with-faicon (icon str &rest height v-adjust)
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))
    ;; filecon
    (defun with-fileicon (icon str &rest height v-adjust)
      (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))

  (use-package doom-modeline
    :after all-the-icons
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15))
    :config
    (setq display-time-format "[%d/%m - %H:%M]")
    (display-time-mode 1))
#+end_src

*** Interactively change the UI

This is one moment where a pretty hydra could help us change general UI parameters, such as the text size, some highlighting options and so on.

#+begin_src emacs-lisp
  (with-eval-after-load 'hydra
    ;; define a title function
    (defvar appearance-title (with-faicon "desktop" "Appearance"))

    ;; Other idea:
    ;; (defvar appearance-title (with-faicon "toggle-on" "Toggles" 1 -0.05))

    ;; generate hydra

    (pretty-hydra-define hydra-appearance (:title appearance-title
                                           :quit-key "q"
                                          ;:pre (hydra-posframe-mode t)
                                          ;:post (hydra-posframe-mode 0) ; dirty hack
                                                  )
      ("Theme"
       (
        ;;     ("o" olivetti-mode "Olivetti" :toggle t)
        ;;     ("t" toggle-window-transparency "Transparency" :toggle t )
        ("c" lps/rotate-through-themes "Cycle Themes" )
        ("t" lps/restore-initial-themes "Restore Theme")
        ("+" text-scale-increase "Zoom In")
        ("-" text-scale-decrease "Zoom Out")
        ("x" toggle-frame-maximized "Maximize Frame" :toggle t )
        ("X" toggle-frame-fullscreen "Fullscreen Frame" :toggle t))
       "Highlighting"
       (("d" rainbow-delimiters-mode "Rainbow Delimiters" :toggle t )
        ("r" rainbow-mode "Show Hex Colours" :toggle t )
        ("n" highlight-numbers-mode "Highlight Code Numbers" :toggle t )
        ("l" display-line-numbers-mode "Show Line Numbers" :toggle t )
        ("_" global-hl-line-mode "Highlight Current Line" :toggle t )
        ;;    ("I" rainbow-identifiers-mode "Rainbow Identifiers" :toggle t )
        ("b" beacon-mode "Show Cursor Trailer" :toggle t )
        ("w" whitespace-mode "Show Whitespaces" :toggle t))
      "Miscellaneous"
      (("j" visual-line-mode "Wrap Line Window"  :toggle t)
       ("m" visual-fill-column-mode "Wrap Line Column"  :toggle t)
       ;;    ("a" adaptive-wrap-prefix-mode "Indent Wrapped Lines" :toggle t )
       ;;   ("i" highlight-indent-guides-mode  "Show Indent Guides" :toggle t )
       ("g" fci-mode "Show Fill Column" :toggle t )
       ("<SPC>" nil "Quit" :color blue )))))

  (global-set-key (kbd "C-c h a") 'hydra-appearance/body)

#+end_src
*** Extra packages

Some packages are used lated in the configuration, and we want to be able to use those comfortable modes.

#+begin_src emacs-lisp
  ;; Generic UI modes

  (use-package beacon
    :init (beacon-mode))
  (use-package rainbow-mode
    :defer t)
  (use-package fill-column-indicator
    :defer t)
  (use-package visual-fill-column
    :defer t)
  (use-package highlight-numbers
    :hook (prog-mode . highlight-numbers-mode))
#+end_src

** Whitespaces

First of all, we never want ~TAB~ to insert actual tab characters.

#+begin_src emacs-lisp
  ;; Tab behaviour and whitespaces
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+end_src

Then, we do not want to repeatedly spam the ~DEL~ key in order to delete a long sequence of whitespaces.

#+begin_src emacs-lisp
(use-package hungry-delete
  :ensure t
  :defer t
  :init
  (global-hungry-delete-mode 1)
  (setq hungry-delete-join-reluctantly t))
#+end_src

And we also don't like trailing whitespaces, so we delete them automatically when we save a buffer

#+begin_src emacs-lisp
  (use-package emacs
    :hook (before-save . delete-trailing-whitespace))
#+end_src

** Font and encoding

Even if most of the time, you should be working with UTF-8, we still want to make sure that this is the default and that Emacs assumes that we are using UTF-8

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-clipboard-coding-system 'utf-8)
  (set-file-name-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src

Another thing that is technically more a stylistic choice rather than a real encoding problem is how dates are formatted. I decide to use the European style

#+begin_src emacs-lisp
  (use-package calendar
    :ensure nil
    :defer t
    :config
    (calendar-set-date-style 'european))
#+end_src

** Minibuffer completion

Although emacs provides a number of commands to navigate within a file, to find documentation and so on, the following packages will make the general UI easier to use.

[[https://github.com/abo-abo/swiper][Ivy and Counsel]] are completion and narrowing frameworks that allow you to use the minibuffer more comfortably.

#+begin_src emacs-lisp
  ;; Ivy
  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
           :map swiper-map
           ("M-g" . swiper-avy)
           :map ivy-minibuffer-map
           ("TAB" . ivy-partial-or-done)
           ("C-l" . ivy-immediate-done)
           ("C-SPC" . lps/ivy-toggle-current-mark)
           ("<mouse-3>" . nil)
           ("<mouse-1>" . nil)
           ("<down-mouse-1>" . nil))
    :custom
    (ivy-count-format "(%d/%d)")
    (enable-recursive-minibuffers t)
    (ivy-initial-inputs-alist nil)
    (ivy-extra-directories nil)

    :config
    (ivy-mode 1)

    (defun lps/ivy-toggle-current-mark ()
      (interactive)
      "Toggle mark for current candidate and move forwards."
      (if (ivy--marked-p)
          (ivy-unmark)
        (ivy-mark))))

  ;; Adds things to Ivy
  (use-package ivy-rich
    :after ivy
    :init (ivy-rich-mode 1))

  ;; Counsel. Adds things to Ivy
  (use-package counsel
    :diminish
    :hook (ivy-mode . counsel-mode)
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-switch-buffer) ;; counsel-ibuffer is a fancier option
           ("C-x C-f" . counsel-find-file)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history)))

#+end_src

And there is a way to go even faster for completion. Indeed, when in doubt, why not suggest recent or popular completions ? That is exactly what ~prescient~ does, by sorting the suggestions according to their frequency or how recently we used them.

This goes beyond commands, but can also be used for any kind of documentation lookup, with =describe-function= or =describe-variable= for example.

#+begin_src emacs-lisp
  ;; Generic Prescient configuration
  (use-package prescient
    :defer t
    :custom
    (prescient-history-length 200)
    (prescient-sort-length-enable nil)
    :config
    (prescient-persist-mode 1))

  (use-package ivy-prescient
    :after counsel
    :custom
    (ivy-prescient-retain-classic-highlighting t)
    :config
    (ivy-prescient-mode 1)
    (setq ivy-prescient-sort-commands
          (append ivy-prescient-sort-commands
                  '(counsel-minibuffer-history
                    counsel-shell-history))))
#+end_src

** Buffer and windows
*** Buffer management
Emacs is sometimes all over the place, opening buffers at seemingly random places, switching your focus only in some circumstances ... We will customize this behaviour so that we have a better control on what Emacs is doing when we open new buffers

#+begin_src emacs-lisp
  ;; Automatically reload a file if it has been modified
  (global-auto-revert-mode t)

  ;;Buffer management
  (setq display-buffer-base-action
        '((display-buffer-reuse-window)
          (display-buffer-reuse-mode-window)
          (display-buffer-same-window)
          (display-buffer-in-previous-window)))

  ;; Can even have further control with
  ;; display-buffer-alist, or using extra-parameters

#+end_src

Another annoying thing is that we tend to have /a lot/ of open buffers at the same time, and there will invariably be some conflicts in their names. We want to be able to quickly distinguish which file is buffer is visiting.

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-after-kill-buffer-p t)
#+end_src

We also improve the appearance (and functionalities) of the buffer that we get when we want to list all the buffers that are currently opened.

#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :after ibuffer
    :init (all-the-icons-ibuffer-mode 1))

  (use-package ibuffer
    :defer t
    :bind ("C-x C-b" . ibuffer)
    :custom
    (ibuffer-saved-filter-groups
     '(("default"
        ("Dired" (mode . dired-mode))
        ("Emacs" (or
                  (name . "^\\*scratch\\*$")
                  (name . "^\\*Messages\\*$")))
        ("Help" (or
                 (mode . helpful-mode)
                 (mode . Info-mode)
                 (mode . help-mode)))
        ("Special" (or
                    (name . "^\\*.*\\*$")
                    (mode . special-mode)))
        ("Images/PDF" (or
                       (file-extension . "pdf")
                       (mode . image-mode)))
        ("Programming" (and
                        (derived-mode . prog-mode)
                        (not (mode . fundamental-mode)))))))
    :config
    (add-to-list 'ibuffer-help-buffer-modes 'helpful-mode)
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-switch-to-saved-filter-groups "default"))))

#+end_src

A cool function to rename both a buffer and the file that it is visiting, while being careful e.g. not to override anything

#+begin_src emacs-lisp
  ;; From Magnars, from emacsrocks.com
  (defun rename-current-buffer-file ()
      "Renames current buffer and file it is visiting."
      (interactive)
      (let* ((name (buffer-name))
            (filename (buffer-file-name))
            (basename (file-name-nondirectory filename)))
        (if (not (and filename (file-exists-p filename)))
            (error "Buffer '%s' is not visiting a file!" name)
          (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
            (if (get-buffer new-name)
                (error "A buffer named '%s' already exists!" new-name)
              (rename-file filename new-name 1)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)
              (message "File '%s' successfully renamed to '%s'"
                       name (file-name-nondirectory new-name)))))))
#+end_src

*** Window management

Because window management can be a bit tedious with the basic Emacs functionalities, we improve it a bit. First of all, we enable =winner-mode=, which allows us to "undo" and "redo" changes in the Windows' configuration.

#+begin_src emacs-lisp
  (use-package winner
    :ensure nil
    :commands (winner-undo winner-redo)
    :hook (after-init . winner-mode)
    :init (setq winner-boring-buffers '("*Completions*"
                                        "*Compile-Log*"
                                        "*Fuzzy Completions*"
                                        "*Apropos*"
                                        "*Help*"
                                        "*Buffer List*"
                                        "*Ibuffer*")))

#+end_src

To facilitate window management, we use an hydra, binding most of the commands that we might ever need.

First of all, we use a few helper functions, defined in [[https://github.com/abo-abo/hydra/blob/master/hydra-examples.el][hydra-examples.el]]

#+begin_src emacs-lisp
  ;;* Helpers
  (use-package windmove
    ;; Make windmove work in Org mode:
    :hook
    (org-shiftup-final . windmove-up)
    (org-shiftleft-final . windmove-left)
    (org-shiftdown-final . windmove-down)
    (org-shiftright-final . windmove-right)

    :init (windmove-default-keybindings)

    :config
    (defun hydra-move-splitter-left (arg)
      "Move window splitter left."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (shrink-window-horizontally arg)
        (enlarge-window-horizontally arg)))

    (defun hydra-move-splitter-right (arg)
      "Move window splitter right."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (enlarge-window-horizontally arg)
        (shrink-window-horizontally arg)))

    (defun hydra-move-splitter-up (arg)
      "Move window splitter up."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (enlarge-window arg)
        (shrink-window arg)))

    (defun hydra-move-splitter-down (arg)
      "Move window splitter down."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (shrink-window arg)
        (enlarge-window arg))))
#+end_src

Now, we wrap everything up into a nice hydra

#+begin_src emacs-lisp
  (global-set-key
   (kbd "C-c h w") ; w for window
   (defhydra hydra-window (:color red
                                  :hint nil)
     "
      ^Focus^           ^Resize^       ^Split^                 ^Delete^          ^Other
      ^^^^^^^^^-------------------------------------------------------------------------------
      _b_move left      _B_left        _V_split-vert-move      _o_del-other      _c_new-frame
      _n_move down      _N_down        _H_split-horiz-move     _da_ace-del       _u_winner-undo
      _p_move up        _P_up          _v_split-vert           _dw_del-window    _r_winner-redo
      _f_move right     _F_right       _h_split-horiz          _df_del-frame
      _q_uit
      "
     ;; Move the focus around
     ("b" windmove-left)
     ("n" windmove-down)
     ("p" windmove-up)
     ("f" windmove-right)

     ;; Changes the size of the current window
     ("B" hydra-move-splitter-left)
     ("N" hydra-move-splitter-down)
     ("P" hydra-move-splitter-up)
     ("F" hydra-move-splitter-right)

     ;; Split and move (or not)
     ("V" (lambda ()
            (interactive)
            (split-window-right)
            (windmove-right)))
     ("H" (lambda ()
            (interactive)
            (split-window-below)
            (windmove-down)))
     ("v" split-window-right)
     ("h" split-window-below)

     ;; winner-mode must be enabled
     ("u" winner-undo)
     ("r" winner-redo) ;;Fixme, not working?

     ;; Delete windows
     ("o" delete-other-windows :exit t)
     ("da" ace-delete-window)
     ("dw" delete-window)
     ("db" kill-this-buffer)
     ("df" delete-frame :exit t)

     ;; Other stuff
     ("a" ace-window :exit t)
     ("c" new-frame :exit t)
     ("s" ace-swap-window)
     ("q" nil)))
#+end_src

Sometimes, we also want some very specific buffer to be associated to a certain window. As there is probably no general rule that would decide this for us, it is not possible to modify ~display-buffer-alist~ or other similar variables to get the desired behaviour. Hence, we will simply create a function that binds - or unbinds - the current buffer to the current window.

#+begin_src emacs-lisp
  ;; Taken from https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows

  (defun lps/toggle-window-dedicated ()
    "Control whether or not Emacs is allowed to display another
  buffer in current window."
    (interactive)
    (message
     (if (let (window (get-buffer-window (current-buffer)))
           (set-window-dedicated-p window (not (window-dedicated-p window))))
         "%s: Can't touch this!"
       "%s is up for grabs.")
     (current-buffer)))

  (global-set-key (kbd "C-c t") 'lps/toggle-window-dedicated)

#+end_src

** Help !

Emacs already has a /great/ documentation system, but it is still possible to improve it ! [[https://github.com/Wilfred/helpful][helpful]] makes things easier to remember and to use without having to search for documentation in multiple places.

It will condense all the available information about something within a single Help buffer, and will add some documentation to the commands you are currently typing.

#+begin_src emacs-lisp
  ;; Helpful. Extra documentation when calling for help
  (use-package helpful
    :custom
    (counsel-describe-symbol-function   #'helpful-symbol)
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-symbol]   . counsel-describe-symbol)
    ([remap describe-key]      . helpful-key)
    ("C-h u"                   . helpful-at-point)) ;; Help "<u>nder" cursor

#+end_src
* Commands
** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] is a package that is used to group several related commands into a family of bindings, all starting with the same prefix (= "hydra"). Whenever this common prefix is entered in a suitable mode, a panel shows up, showing all the user-defined commands that can now be invoked with a single keystroke instead of repeatedly using the same long prefix.

#+begin_src emacs-lisp
(use-package hydra
  :defer t)
#+end_src

All the hydras will now be defined after the package to which they correspond, or in the appropriate section. Most of them are modifications of hydras that can be found on the [[https://github.com/abo-abo/hydra/wiki][hydra wiki]].

Some hydras will be called less frequently and for other purposes than getting a "quick-and-dirty" access to commonly used functions. Hence, we will make them prettier (the compromise being that they are less minimalistic and take much more space visually)

*MANUAL* This is not a MELPA package. It can be found [[https://github.com/Ladicle/hydra-posframe][here]]. Install it and change the loading path according to your configuration.

#+begin_src emacs-lisp
  (use-package posframe
    :defer t)

  ;; Manual load and config of Hydra Posframe
  ;; To fix: find a way to override parameters ...
  ;; (load-file "~/.emacs.d/extra-packages/hydra-posframe.el")
  ;; (setq hydra-posframe-border-width 5)

  ;Pretty Hydra
  (use-package pretty-hydra
    :defer t
    :after hydra)
#+end_src
** Disable

We want to use the full Emacs power. However, if you find yourself using repeatedly a dangerous command by mistake, you might want to disable it

#+begin_src emacs-lisp
  ;; Don't disable any command
  ;; BE CAREFUL
  ;; If you are a new user, you might to comment out this line
  (setq disabled-command-function nil)

#+end_src

There is, however, one really annoying binding, especially for new users or people used to ... computers, calling the =suspend-frame= command. For people who are using it, do not worry, it is still available on =C-x C-z= anyway.

#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
#+end_src

** Command log mode

This mode allows you to display a small panel on the right of the screen which shows which keys you are pressing, and what commands they are associated to, all of this in real time !

As of now, you need to enable the mode by using the =command-log-mode= command (or =global-command-log-mode= if you want to record everything, in all the buffers of the current session), and to use the =C-c o= keybinding (which calls the =clm/toggle-command-log-buffer= function) to open a new buffer in which you will see both the keybindings you are currently using and the commands to which they are bound.

If you want =command-log-mode= to be activated by default in certain minor (or even major) modes, simply add a hook. You will still need to explicitly open the buffer, but this could also be dealt with by using other, straightforward hooks.

#+begin_src emacs-lisp
  (use-package command-log-mode
    :defer t)
#+end_src

** Confirmation

Typing "yes" and "no" might be a bit too tiring

#+begin_src emacs-lisp
  ;; Type "y" instead of "yes RET" for confirmation
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Help

Because there are a lot of similar commands, it is quite easy to get lost. [[https://github.com/justbur/emacs-which-key][which-key]] is a package that shows all the available commands after having typed some prefix, meaning that knowing the beginning of a key sequence is enough to get the rest of the information.

For example, if you press =C-c=, then a panel will appear at the bottom of the screen to show how you can currently continue this command, depending on which buffer you are in.


#+begin_src emacs-lisp
  ;; which-key. Shows all the available key sequences after a prefix
  (use-package which-key
    :init (which-key-mode)
    :diminish
    :custom (which-key-idle-delay 1))
#+end_src

** Some macros

In this section, we define some useful macros to write code in Emacs Lisp.

#+begin_src emacs-lisp
  ;; Macro to use "python-style" affectation in lexical bindings
  (defmacro multi-let (vars values body)
    "Binds each symbol of VARS to its corresponding expression in VALUES,
    in order.
    multi-let (a b) (e1 e2) body is thus equivalent to
    (let ((a e1)) (let ((b e2)) body))
    Expressions at position k in VALUES might depend on symbol from
    VARS at position strictly less than k, as with let*"
    (defun rec-expand-let (vars values body)
      (if (= (length vars) (length values))
          (if (and vars (symbolp (car vars)))
              `(let ((,(car vars) ,(car values)))
                 ,(rec-expand-let (cdr vars)
                                  (cdr values)
                                  body))
            body)
        (message
         (format "Trying to bind %d symbols to %d values"
                 (length vars)
                 (length values)))))

    (rec-expand-let vars values body))
#+end_src

** Useful commands
*** Open file
We often want to visit links. If the point is on a file path, for example, it is often useful to be able to quicky navigate to this file.

#+begin_src emacs-lisp
  (use-package ffap
    :ensure nil
    :init (ffap-bindings))
#+end_src
* Editing

   Emacs is fundamentally a text editor. It provides a lot of functions to deal with text, and a way to create macros, to automate things, to repeat something multiple times ... easily. However, because there are /so many/ available functions, we might need some help to navigate around and do fancy things.
** Multiple cursors

A first improvement is the addition of multiple cursors. The "rectangle region" already gives a way to insert text simultaneously at several places, and to perform some easy operations on a rectangular area, but the [[https://github.com/magnars/multiple-cursors.el][multiple cursor]] package really increases the possibilities.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
    (("C-c m SPC"   . mc/vertical-align-with-space)
     ("C-c m a"     . mc/vertical-align)
     ("C-c m m"     . mc/mark-more-like-this-extended)
     ("C-c m h"     . mc/mark-all-like-this-dwim)
     ("C-c m l"     . mc/edit-lines)
     ("C-c m n"     . mc/mark-next-like-this)
     ("C-c m p"     . mc/mark-previous-like-this)
     ("C-c m C-,"   . mc/mark-all-like-this)
     ("C-c m C-a"   . mc/edit-beginnings-of-lines)
     ("C-c m C-e"   . mc/edit-ends-of-lines)
     ("C-c m r"     . mc/mark-all-in-region)))
#+end_src

The webpage specifies that the commands provided by this package are best invoked when bound to key sequence rather than by =M-x <mc/command-name>=, although some testing on my part seems to show that it still works relatively well most of the time.

** Navigation

Because movement keys are the most frequently used ones, it might be useful to create an Hydra helping us navigate around a document.

#+begin_src emacs-lisp
  (global-set-key
   (kbd "C-c h m")
   (defhydra hydra-move ()
     "Movement" ; m as in movement
     ("n" next-line)
     ("p" previous-line)
     ("f" forward-char)
     ("b" backward-char)
     ("a" beginning-of-line)
     ("e" move-end-of-line)
     ("v" scroll-up-command)
     ;; Converting M-v to V here by analogy.
     ("V" scroll-down-command)
     ("l" recenter-top-bottom)))
#+end_src

We also want to be able to move faster in large documents. To do this, we use imenu, or more precisely its counsel-enhanced counterpart

#+begin_src emacs-lisp
  (use-package counsel
    :bind ("C-c i" . counsel-imenu))
#+end_src

Furthermore, we change a variable that makes sense for American writers, but not so much according to French conventions. The Emacs Manual recommends against it, as we are no longer able to distinguish a sentence ending from an abbreviation, but I do not use this type of abbreviation very often anyway (notable counterexamples nonetheless: /i.e./ and /e.g./).

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom (sentence-end-double-space nil))
#+end_src

Final touch: we often use the "search" functions to move the point around, because it is often easier than mashing the ~C-f~ and ~C-n~ keys. In a previous section we bound ~C-s~ to ~Swiper~, which provides a fancy UI but can be slow for simply moving the point to a nearby location.

Hence, we add a few bindings to an already existing keymap, to make them easily accessible again.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :bind (:map search-map
                ("s" . isearch-forward)
                ("M-s" . isearch-forward) ;; avoids early/late release of Meta
                ("r" . isearch-backward)
                ("x" . isearch-forward-regexp)))
#+end_src

** Rectangles

Manipulating rectangles is a cool Emacs feature. You can select a region with the shape of a rectangle, copy and yank it, insert strings at the beginning of each line of the selection, and several other features.

Because the functions operating on rectangles are not always the easier to remember, we simply define a new Hydra referencing the most useful ones.

#+begin_src emacs-lisp
  (global-set-key
   (kbd "C-c h r") ; r as rectangle
   (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                        :color pink
                                        :hint nil
                                        :post (deactivate-mark))
     "
    ^_p_^       _w_ copy      _o_pen       _N_umber-lines                   |\\     -,,,--,,_
  _b_   _f_     _y_ank        _t_ype       _e_xchange-point                 /,`.-'`'   ..  \-;;,_
    ^_n_^       _d_ kill      _c_lear      _r_eset-region-mark             |,4-  ) )_   .;.(  `'-'
  ^^^^          _u_ndo        _q_ quit     _i_nsert-string-rectangle      '---''(./..)-'(_\_)
  "
     ("p" rectangle-previous-line)
     ("n" rectangle-next-line)
     ("b" rectangle-backward-char)
     ("f" rectangle-forward-char)
     ("d" kill-rectangle)                    ;; C-x r k
     ("y" yank-rectangle)                    ;; C-x r y
     ("w" copy-rectangle-as-kill)            ;; C-x r M-w
     ("o" open-rectangle)                    ;; C-x r o
     ("t" string-rectangle)                  ;; C-x r t
     ("c" clear-rectangle)                   ;; C-x r c
     ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
     ("N" rectangle-number-lines)            ;; C-x r N
     ("r" (if (region-active-p)
              (deactivate-mark)
            (rectangle-mark-mode 1)))        ;; C-x SPC
     ("i" string-insert-rectangle)
     ("u" undo nil)
     ("q" nil)))
#+end_src

** Selection

A useful tool to manipulate text and even source code is the [[https://github.com/magnars/expand-region.el][expand-region]] package, as it allows us to increase the selected region to match larger and larger /semantic/ units. For example, by using it repeatedly, you could select in this order a character, a word, a string containing this word, a sexp containing this string, and the function in this sexp is used.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

We also define functions that Emacs is surprinsingly lacking.

The first one is used to copy without deleting the current line (internally, it uses =kill-ring-save=, and so it can be used in a read-only context, unlike a sequence like =C-a C-k C-y=). It is also much quicker than variations on the sequence  =C-e C-SPC C-a M-w=.

#+begin_src emacs-lisp
   (defun lps/copy-line-at-point (arg)
     "Copy ARG lines in the kill ring, starting from the line at point and copying subsequent ones if ARG > 1"
     (interactive "p")
     (kill-ring-save (line-beginning-position)
                     (line-end-position arg)))

  ; Note that this keybinding overrides other functions
  ; By default, M-k is kill-sentence, which I never use
  ; I bound it this way to mirror the C-w/M-w symmetry

  ;; Might want to find a more clever way to use personal
  ;; keybindings, such as defining a minor mode ...
  (global-set-key (kbd "M-k") 'lps/copy-line-at-point)
#+end_src

The next one is used to select the current line. Once a line is marked, we can move it, delete it, copy it and so on easily. Having it on a single key binding is quicker than having to do something like =C-a C-SPC C-e=

#+begin_src emacs-lisp
  (defun lps/select-line ()
  "Select the current line. If the region is already active, extends the current selection by line."
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))

  ;; makes sense on Keyboard
  ;; Remember that M-@ is bound to mark-word
  (global-set-key (kbd "M-à") 'lps/select-line)
#+end_src

** Moving stuff around

A big part of editing text consists in moving already written lines, words or paragraphs around. Emacs provides a set of basic functions to do, with ~transpose-<chars/lines/sexps>~ and so on, but they are not very intuitive and a bit clumsy to use. This is why we use another package, which will allow us to move entire blocks of text much more naturally

#+begin_src emacs-lisp
  (use-package drag-stuff
    :init
    (drag-stuff-global-mode 1)
    (drag-stuff-define-keys))
#+end_src

** Undo

Another very useful package is undo-tree, which allows you to visualize the previous "Undos" and navigate them.

It can act as a small, local version control system due to how Undos are managed by Emacs.

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (setq undo-tree-visualizer-timestamps t)
    (global-undo-tree-mode)
    :diminish (undo-tree-mode))

#+end_src

** Regexp

#+begin_src emacs-lisp
  (defun lps/find-delete-forward-all-regexp (re &optional beg)
    "Searches for all the matches of the regexp RE after the point, or after the optional position BEG.
    Returns a list of strings containing the matches in order, or nil if none was found.
    Deletes (rather than kill) those matches from the buffer"
    (save-excursion
      (let (matches)
        (goto-char (or beg (point)))
        (while (re-search-forward re nil t)
          (push (match-string 0) matches)
          (delete-region (match-beginning 0) (match-end 0)))
        matches)))

  (defun lps/move-all-regexp-pos-buffer (re &optional beg move split)
    "Moves all the string matching the regexp RE after the point (or after BEG) to the end of the buffer
  (or to the position MOVE if provided)
    If SPLIT is provided, it will be inserted before each match, including the first one.
    The initial strings are destroyed, and the kill-ring is not modified"
    (save-excursion
      (let ((matches (lps/find-delete-forward-all-regexp re beg)))
        (prin1 matches)
        (goto-char (or move (point-max)))
        (while matches
          (insert (or split ""))
          (insert (pop matches))))))
#+end_src

* Programming
** Projectile

    [[https://projectile.mx/][Projectile]] is an Emacs package that makes project management easier. It allows us /e.g./ to navigate between files of the same project, search/replace within files of the same project, and integrates very well with other tools, such as =lsp-mode= or ~counsel~.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    ;; (when (file-directory-p "path/to/project/dir")
    ;; (setq projectile-project-search-path '("path/to/project/dir")))
    (setq projectile-switch-project-action #'projectile-dired)

    :config
    (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map))

  (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode))

#+end_src

** Git
*** Magit
[[https://magit.vc/][Magit]] is a serious contender for the first place in the long list of "Reasons you should use Emacs", along with Org Mode.

It is a Text User Interface to Git, which integrates most of Git commands, even the most advanced ones, while making it easy to use even for beginners.

#+begin_src emacs-lisp
  (use-package magit
    :defer t
    ;; :custom (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    ;; uncomment previous line to have magit open itself within the same buffer
    ;; instead of in another buffer
    :bind ("C-x g" . magit-status))
#+end_src

*** Git-timemachine

Another useful package is [[https://github.com/emacsmirror/git-timemachine][git-timemachine]], which allows to easily navigate the history of a git-controlled file with a few key presses.

Although Magit is more or less able to do the same thing, the interface there is cleaner and you are less likely to get lost than in the fully-featured super-package that Magit is.

#+begin_src emacs-lisp
  (use-package git-timemachine
    :defer t)
#+end_src
*** Forge
We will probably want to work with distant repositories, /e.g./ stored on a distant GitHub or GitLab host.

In order to integrate more tightly with those tools, and have access to more complex features than the basic ones provided by Git itself, we use a package called [[https://magit.vc/manual/forge/][Forge]]. For example, it will allow us to do pull-requests, or edit issues, directly from Emacs, rather than having to connect to the online GitHub website or to use another API provided by some other software.

*MANUAL* In order to use this package, you need to have a personal "token", so that the server knows who you are ! To setup everything, follow the instructions in the Forge manual.

#+begin_src emacs-lisp
  (use-package forge
    :after magit)
#+end_src
** Parenthesis

First of all, we want to easily be able to tell with a quick glance which parenthesis are matching

#+begin_src emacs-lisp
  ;; Always highlight matching parenthesis
  (use-package paren
    :ensure nil
    :init
    (show-paren-mode t)
    :custom
    ;; (show-paren-style 'mixed) ; Too invasive
    (show-paren-when-point-inside-paren t)
    (show-paren-when-point-in-periphery t))

  ;; rainbow-delimiters. Hightlights with the same colour matching parenthesis
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Now, in order to work with structured text, such as source code, we want to be able to directly manipulate "expressions" rather than lines or words. This is why we use the following packages, as they provide a lot of functionalities to navigate and edit those expressions.

#+begin_src emacs-lisp
  ;; Smartparens is currently bugged
  (use-package smartparens
    :disabled t
    :custom (sp-highlight-pair-overlay nil)
    :hook (smartparens-mode . show-smartparens-mode)
    :bind
    ("C-M-f" . sp-forward-sexp)
    ("C-M-b" . sp-backward-sexp)

    ;; Define those as in paredit
    ("C-M-n" . sp-up-sexp)
    ("C-M-d" . sp-down-sexp)
    ("C-M-u" . sp-backward-up-sexp)
    ("C-M-p" . sp-backward-down-sexp)

    ("C-S-a" . sp-beginning-of-sexp)
    ("C-S-e" . sp-end-of-sexp)

    ("C-M-t" . sp-transpose-sexp)

    ("C-M-k" . sp-kill-sexp)
    ("C-M-w" . sp-copy-sexp)

    ("M-<delete>" . sp-unwrap-sexp)
    ("M-<backspace>" . sp-backward-unwrap-sexp)

    ("C-<right>" . sp-forward-slurp-sexp)
    ("C-<left>" . sp-forward-barf-sexp)
    ("C-M-<left>" . sp-backward-slurp-sexp) ; kbd ghosting ?
    ("C-M-<right>" . sp-backward-barf-sexp) ; kbd ghosting ?

    ("M-s" . sp-splice-sexp) ; unbinds "occur"
    ;; ("C-M-<delete>" . sp-splice-sexp-killing-forward)
    ;; ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
    ;; ("C-S-<backspace>" . sp-splice-sexp-killing-around)

    ("M-F" . sp-forward-symbol)
    ("M-B" . sp-backward-symbol))


  (use-package paredit
    :hook ((sly-mrepl-mode
            eshell-mode
            ielm-mode
            eval-expression-minibuffer-setup
            emacs-lisp-mode
            lisp-mode
            lisp-interaction-mode) . paredit-mode))

  (use-package elec-pair
    :hook ((prog-mode org-mode) . electric-pair-local-mode)) ;; needed for org-babel
#+end_src

** Auto-completion
**** YASnippet

     A first useful package is YASnippet, which makes it easy to define and automatically insert snippets of code in various languages.

#+begin_src emacs-lisp
  ;;YASnippet
  (use-package yasnippet
    :diminish
    :config
    (setq yas-verbosity 1)
    :hook ((prog-mode LaTeX-mode) . yas-minor-mode)
    :bind (:map yas-minor-mode-map
                ("TAB" . nil)
                ("<tab>" . nil)
                ("<C-tab>" . yas-expand)))
#+end_src

It is even possible to define your own snippets. The following package contains a lot of useful snippets for various programming languages or tools, such a C++, Clojure, various Makefiles, Emacs' Org-Mode ...

#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :after yasnippet)
#+end_src

**** Company

     Several packages are available to make auto-completion more efficient and intuitive than the built-in =completion-at-point= function. We use [[https://company-mode.github.io/][Company]] (stands for "comp[lete] any[thing]") as it integrates nicely with other packages that we use, is well-maintained and has a more modern interface than most of its counterparts such as =auto-complete=.

#+begin_src emacs-lisp
  ;; Company. Auto-completion package
  (use-package company
    :diminish

    :init (global-company-mode t)

    :bind (:map company-active-map
                ("<tab>" . company-complete)
                ("TAB" . company-complete)
                ("RET" . nil)
                ("<return>" . nil)
                ("C-l" . company-complete-selection))

    :custom
    ;; Generic company settings
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0)
    (company-selection-wrap-around t)
    (company-show-numbers t)
    (company-tooltip-align-annotations t)
    (company-tooltip-flip-when-above t)

    ;; More specific ones
    ;; company-dabbrev look only for buffers in the same major mode
    (company-dabbrev-other-buffers t)

    :config
    (setq-default company-backends '((company-capf company-files company-dabbrev company-yasnippet)
                                     (company-dabbrev-code company-gtags company-etags company-keywords company-clang)
                                     company-oddmuse)))
#+end_src

To have a cleaner interface and also a bit of documentation added to the suggested completions, we use two extra packages.

#+begin_src emacs-lisp
  (use-package company-box
    :after company
    :diminish
    :hook (company-mode . company-box-mode)
    :config
    (setq company-box-backends-colors '((company-yasnippet :all "dark turquoise"
                                                           :selected
                                                           (:background "slate blue" :foreground "white")))))

  (use-package company-quickhelp
    :after company
    :hook (company-mode . company-quickhelp-mode)
    :diminish
    :custom (company-quickhelp-delay 0.2))

#+end_src

***** Company backends

A first backend that we want to consider is the one using snippets provided by ~yasnippet~

#+begin_src emacs-lisp
  (use-package company-yasnippet
    :ensure nil
    :after company)
#+end_src

We install another backend specifically for LaTeX

#+begin_src emacs-lisp
  (use-package company-math
    :after company)
#+end_src

We add another backend to support completion in shell and terminal-modes
#+begin_src emacs-lisp
  (use-package company-shell
    :disabled t
    :after eshell
    :hook (eshell-mode . my-company-shell-modes)
    :config
    (defun my-company-shell-modes ()
      ;; Not satisfying: duplicates from company-capf and company-shell, so we disable the 2nd one but we lose some documentation ...
      (setq-local company-backends '((company-shell-env company-fish-shell company-capf company-files company-dabbrev company-shell)))
      (push 'elisp-completion-at-point completion-at-point-functions)))
#+end_src
***** Company prescient
There is a way to be even faster, and it simply consists in ordering completions so that we can press ~TAB~ as fast as possible to complete of what we are typing.

To do so, we use the same package that we used for Ivy, which is called [[https://github.com/raxod502/prescient.el][Prescient]].

#+begin_src emacs-lisp
  (use-package company-prescient
    :after company
    :config
    (company-prescient-mode 1))
#+end_src
** Language Server Protocol
*** LSP-mode

    The [[https://en.wikipedia.org/wiki/Language_Server_Protocol][Language Server Protocol]] is a protocol which facilitates the use of several languages with various IDE. Instead of specifying a syntax, ..., for each pair "IDE/Language", it aims at abstracting the specifities of each language, so that each IDE will need to communicate with a server that will give back the information needed to do IDE-y things such as highlighting or auto-completion in an unified manner.

#+begin_src emacs-lisp

  ;; LSP mode. Useful IDE-like features
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :init
    ;; Sometimes, we don't want to start a full server just to check a file
    ;; or make a few edits to it. In my use, this mostly depends on the session:
    ;; In a quick session, I might not want to start a server for one or two files,
    ;; however, once I start using LSP, there is no reason not to assume that I
    ;; also want to use it by default for other files in the same session
    (defvar lps/--default-lsp-mode 0)
    (defun lps/lsp-by-default-in-session ()
      (if (> lps/--default-lsp-mode 0)
          (lsp)
        (if (and (= lps/--default-lsp-mode 0) (y-or-n-p "Automatically use lsp-mode in the current session ?"))
            (progn
              (setq lps/--default-lsp-mode 1)
              (lsp))
          (setq lps/--default-lsp-mode -1))))
    :custom
    (lsp-diagnostics-provider :flycheck) ;:none if none wanted

    :config
    (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
    (lsp-enable-which-key-integration t)
    (setq lsp-prefer-flymake nil)
    (setq lsp-enable-on-type-formatting nil)

    (defun lps/toggle-lsp-by-default-session ()
      (interactive)
      (setq lps/--default-lsp-mode (not lps/--default-lsp-mode)))

    :hook ((python-mode c-mode c++-mode) . lps/lsp-by-default-in-session))

  (use-package lsp-ui
    :after lsp-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-delay 1)
    (lsp-ui-sideline-show-code-actions nil))

  (use-package lsp-treemacs
    :after lsp-mode
    :config (lsp-treemacs-sync-mode 1))

  (use-package lsp-ivy
    :after (lsp-mode ivy))
#+end_src

*** Eglot

There exists another implementation of the Language Server Protocol in Emacs, called [[https://github.com/joaotavora/eglot][eglot]]. It is much more integrated within "core" Emacs, as it only uses built-in packages, such as =project.el= instead of ~projectile~, or ~flymake~ rather than ~flycheck~.

#+begin_src emacs-lisp
  ;; Might not work, recommended to use package-install instead
  ;; Dependencies might not be the correct ones

  (use-package eglot
    ;;:hook ((python-mode c-mode c++-mode) . eglot-ensure)
    :ensure nil
    :bind-keymap ("C-c l" . eglot-mode-map)
    :bind (:map eglot-mode-map
                ("r" . eglot-rename)
                ("g g" . xref-find-definitions)
                ("g r" . xref-find-references)
                ("h" . eldoc)))
#+end_src

** Real-time syntax checking

    [[https://www.flycheck.org/en/latest/][Flycheck]] is a modern on-the-fly syntax checking extension to Emacs, working for several languages, showing different level of errors (warnings, errors ...), and which has a natural integration to =lsp-mode=.

#+begin_src emacs-lisp
  ;; Flycheck
  (use-package flycheck
    :defer t
    :config
    ;(setq flycheck-relevant-error-other-file-show nil) ;might be useful
    (setq flycheck-indication-mode 'left-margin)
    :diminish)

#+end_src

** Programming languages
    In this section, we fine-tune our editing tools for various programming languages.
*** Python

     We need to specify which server LSP will use. Several packages are available.

     *MANUAL* Before using LSP, use the following command to install a server:

     =pip install --user python-language-server[all]=

     The command ~pyls~ needs to be available on the ~PATH~ environment variable.

#+begin_src emacs-lisp

  ;; Python
  ;; Before using LPS, make sure that the server has been installed !
  ;; pip install --user python-language-server[all]
  ;; Should be able to use the pyls command

  (use-package python
    :ensure nil
    :defer t
    :custom
    (python-shell-interpreter "python3")
    :config (require 'lsp-pyright))

     #+end_src

I will use another server, based on [[https://github.com/microsoft/pyright][Pyright]]

#+begin_src emacs-lisp
  (use-package lsp-pyright
    :defer t)
#+end_src

*** OCaml

For OCaml, we do not use LSP mode, and we instead choose to work with a specific minor mode called [[https://github.com/ocaml/tuareg][Tuareg]].

#+begin_src emacs-lisp
  ;; Tuareg (for OCaml and ML like languages)
  (use-package tuareg
    :defer t
    :config
    (setq tuareg-indent-align-with-first-arg t)
    (setq tuareg-match-patterns-aligned t))

#+end_src

*** C/C++

For C and C++ (and ObjectiveC), as for Python, we need to install a server for LSP to use. We use the one called [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]].

*MANUAL* To use the ccls server, follow the instruction [[https://github.com/MaskRay/ccls/][here]].

#+begin_src emacs-lisp
  ;; C/C++
  ;; See https://github.com/MaskRay/ccls/wiki/lsp-mode
  (use-package ccls
    :defer t
    :config
    (setq ccls-executable (executable-find "ccls")))
#+end_src
*** LISP
**** Emacs Lisp

Although Emacs comes with pretty good built-in functionalities, there is still room for improvement.

[[https://github.com/Fanael/highlight-defined][highlight defined]] highlights defined Emacs Lisp symbols (functions, variable names, macros ...) in source code.

#+begin_src emacs-lisp
  (use-package highlight-defined
    :hook (emacs-lisp-mode . highlight-defined-mode))

#+end_src

[[https://github.com/Silex/elmacro][elmacro]] shows keyboard macros and interactive commands as Emacs Lisp, meaning that if you know /how/ to do something using advanced keyboard shortcuts or interactive commands, you can get for free an elisp code snippet that does exactly the same thing that you can reuse /e.g./ in a configuration file or in another function.

Because it might be useful everywhere, we do not use it simply in =emacs-lisp-mode= and we activate it everywhere.

#+begin_src emacs-lisp
  (use-package elmacro
    :defer t)
#+end_src

We define a useful macro to evaluate an expression, and replace it with the result. This, in conjunction with macros and multiple cursors, is a great tool to automate otherwise boring tasks.

#+begin_src emacs-lisp
  (defun lps/eval-and-replace-last-sexp ()
    "Evaluate the last s-expression, and replace it with the result"
    (interactive)
    (let ((value (eval (preceding-sexp))))
        (kill-sexp -1)
        (insert (format "%S" value))))

  (global-set-key (kbd "C-c C-e") 'lps/eval-and-replace-last-sexp)
#+end_src

**** Common Lisp

We could, of course, use LSP to write Common Lisp code. However, Emacs already provides nice editing functionalities for programming in Lisp-like languages, and CL is no exception. On top of the built-in Emacs functions, we use another minor mode, specifically designed to write Common Lisp: [[https://common-lisp.net/project/slime/][SLIME]]. More precisely, we use a /fork/ of SLIME, known as [[https://github.com/joaotavora/sly][SLY]].

*MANUAL* It is likely that ~sbcl~ is not already installed. Hence, in order to run the following code, you will need to install it. If you install it manuallyby compiling the source code, make sure that the ~sbcl~ command is available on the PATH, or modify  =:custom (inferior-lisp-program "<path/to/sbcl>")= accordingly in the following block.

#+begin_src emacs-lisp
;; Make sure that sbcl is available on PATH
(use-package sly
  :hook (lisp-mode . sly-editing-mode)
  :custom (inferior-lisp-program "sbcl") ; Clisp makes SLY crash
  :config
  (add-hook 'sly-mode-hook
            (lambda ()
               (unless (sly-connected-p)
                 (save-excursion (sly))))))
#+end_src

** Debug
*** GUD
Emacs already provides a large number of debuggers, under the name "Grand Unified Debugger".

#+begin_src emacs-lisp
  (use-package gdb-mi
    :ensure nil
    :defer t
    :hook (gdb-mode . gdb-many-windows))
#+end_src

*** TODO Dap-mode

** Other tools
*** ANTLR
[[https://fr.wikipedia.org/wiki/ANTLR][ANTLR]] is a tool that is used to write compilers and interpreters, by producing a lexer and a parser (and potentially several other things) from a grammar.

#+begin_src emacs-lisp
  (use-package antlr-mode
    :mode ("\\.g4\\'" . antlr-mode))

#+end_src

* Org Mode

   [[https://orgmode.org/][Org Mode]] is one of the best reasons to use Emacs.

   It acts as a markup language, can deal with planning, manage spreadsheets, do project planning, run code blocks to do literate programming ...

** Basic configuration

     We change the general feel of Org Mode documents by using other indentation rules, by changing the headers appearance, and a few other minor changes.

#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

  (use-package org
    :defer t
    :hook (org-mode . my-org-mode-setup)
    :custom
    ;; Coding in blocks
    (org-src-fontify-natively t)
    (org-src-tab-acts-natively t)
    (org-imenu-depth 4)

    :config
    (defun my-org-mode-setup ()
      (my-org-font-setup)
      (org-indent-mode 1)
      (variable-pitch-mode 1)
      (visual-line-mode 1))

    (add-hook 'org-mode-hook (lambda () (drag-stuff-mode -1)))
    (setq org-ellipsis " ▾")

#+end_src

Take care when copying this block of code: the ~use-package~ declaration continues.

** Font faces

     In order for Org Mode to feel like a document instead of code, we use a different font.

#+begin_src emacs-lisp
  ;; Use the right font according to what is installed on the system

  (let ((my-temp-org-font "Cantarell"))
    (if (member my-temp-org-font (font-family-list))
        (setq my-org-mode-font my-temp-org-font)
      (setq my-org-mode-font "Ubuntu Mono")))

  (defun my-org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    ;; For non-headers: org-default

    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font my-org-mode-font :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+end_src
** Org Babel

Org babel is what allows us to write code and execute it, all within the same document.

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)
     (latex . t)))

  ;; (setq org-confirm-babel-evaluate nil) ; Take care if executing someone
                                           ; else code

#+end_src

We also add templates to insert code blocks with a few key presses

#+begin_src emacs-lisp

  (if (version<= "9.2" org-version)
      ;; This is needed as of Org 9.2
      (progn
        (require 'org-tempo)

        (let ((bound-key-templates
               (mapcar #'car org-structure-template-alist)))
          (dolist (key-template '(("sh" . "src shell")
                                  ("el" . "src emacs-lisp")
                                  ("py" . "src python")
                                  ("latex" . "src latex")))

            (unless
                (member (car key-template) bound-key-templates)
              (push key-template org-structure-template-alist))))))

#+end_src

** Auto-tangle configuration files

     In order to concatenate all the code blocks that are written in this document to an external file, we need to "tangle" it.

     The following code makes it so that each time this file is saved, it generates the corresponding init.el file.

#+begin_src emacs-lisp
  ;; Automatically tangles this emacs-config config file when we save it
  (defun lps/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/.emacs.d/emacs-config.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'lps/org-babel-tangle-config)))
#+end_src

Moreover, while we are configuring how Emacs treats this very file, we also want to be able to use a good Elisp completion system, as this file is mainly composed of Elisp code.

#+begin_src emacs-lisp
  (defun lps/elisp-completion-in-user-init ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/.emacs.d/emacs-config.org"))
      (setq-local completion-at-point-functions '(pcomplete-completions-at-point elisp-completion-at-point t))))

  (add-hook 'org-mode-hook #'lps/elisp-completion-in-user-init)
#+end_src

** Org Agenda

Not only is Org Mode great to write structured documents that can be exported to pretty much anything we want - including tangled to produce source code using literate programming -, it is also a powerful to ... *org*anize things. A built-in functionality is the agenda, where you can schedule tasks, set deadlines, configure reminders, the frequency at which you will need to repeat a given task, and so on.

#+begin_src emacs-lisp
  (setq org-agenda-files '("~/Documents/OrgFiles/Tasks.org"))
  (setq org-log-into-drawer t)
  (setq org-log-done 'time)
  (setq org-agenda-start-with-log-mode t)

  (setq org-tag-alist
        '((:startgroup)
          ;; Put mutually exclusive tags here
          (:endgroup)
          ("@home" . ?H)
          ("@work" . ?W)
          ("agenda" . ?a)
          ("plan" . ?p)
          ("note" . ?n)
          ("idea" . ?i)
          ("read" . ?r))))

#+end_src

* LaTeX and PDF
*** PDF viewer

Rather than =doc-view=, we  use [[https://github.com/politza/pdf-tools][PDF Tools]].

*MANUAL* This package might require some external libraries to be installed. Please refer to the linked page to see exactly what you need to do on your system.

#+begin_src emacs-lisp
  ;; Might require extra libs to work, see https://github.com/politza/pdf-tools

  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward))
    :config
    (pdf-tools-install :no-query)
    (add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode))
#+end_src

*** LaTeX

It is also possible to configure Emacs to comfortably write and edit LaTeX documents

#+begin_src emacs-lisp
  ;; AUCTeX initialization
  (use-package tex-site
    :ensure auctex
    :defer t)

  (use-package tex
    :ensure auctex
    :defer t
    :custom
    ;; Automatically insert closing brackets
    (LaTeX-electric-left-right-brace t)
    ;; Parse documents to provide completion
    (TeX-parse-self t)
    ;; Automatically save style information
    (TeX-auto-save t)
    ;; Don't ask permission to save before compiling
    (TeX-save-query nil)
    ;; Automatically insert braces after sub- and superscripts in math mode
    (TeX-electric-sub-and-superscript t)
    ;; Don't insert magic quotes right away.
    (TeX-quote-after-quote t)
    ;; But do insert closing $ when inserting the first one
    (TeX-electric-math '("$" . "$"))
    ;; Also change the key to access LaTeX-math-mode
    (LaTeX-math-abbrev-prefix "°")
    ;; Don't ask for confirmation when cleaning
    (TeX-clean-confirm nil)

    (TeX-source-correlate-method 'synctex)
    (TeX-source-correlate-start-server t)
    (TeX-view-program-selection '((output-pdf "PDF tools")))

    :config
    (setq TeX-master nil) ; Ask for the master file & don't assume anything

    (setq TeX-source-correlate-mode t ; SyncTeX forward and inverse search
          ;; Produce a PDF by default
          TeX-PDF-mode t)

    (unless (assoc "PDF tools" TeX-view-program-list-builtin)
      (push '("PDF tools" TeX-pdf-tools-sync-view) TeX-view-program-list))

    ;; Update PDF buffers after successful LaTeX runs
    (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

    ;; Insert math symbols quickly
    (add-hook 'LaTeX-mode-hook #'LaTeX-math-mode)

    ;; Add environment for auto. insertion with C-c C-e
    (defun lps/latex-add-environments ()
      (LaTeX-add-environments '("tikzpicture" LaTeX-env-label)))

    (add-hook 'LaTeX-mode-hook 'lps/latex-add-environments)

    ;; Better completion functions
    (defun lps/latex-company-setup () ;; TO FIX !
      (setq-local company-backends '((company-math-symbols-unicode company-math-symbols-latex company-latex-commands company-capf company-dabbrev company-yasnippet))))

    (add-hook 'LaTeX-mode-hook 'lps/latex-company-setup))

#+end_src

We also configure BibTeX

#+begin_src emacs-lisp
  (use-package bibtex
    :defer t
    :config
    ;; Use a modern BibTeX dialect
    ; (bibtex-set-dialect 'biblatex) ; Useful esp. in social sci.
)
#+end_src

Another useful package to deal with references, bibliography, citations and so on, is [[https://www.gnu.org/software/emacs/manual/html_mono/reftex.html][RefTeX]].

#+begin_src emacs-lisp
  (use-package reftex
    :diminish
    :hook (LaTeX-mode . reftex-mode)
    :config
    ;; Plug into AUCTeX
    (setq reftex-plug-into-AUCTeX t
          ;; Provide basic RefTeX support for biblatex
          ;; (unless (assq 'biblatex reftex-cite-format-builtin)
          ;;   (add-to-list 'reftex-cite-format-builtin
          ;;                '(biblatex "The biblatex package"
          ;;                           ((?\C-m . "\\cite[]{%l}")
          ;;                            (?t . "\\textcite{%l}")
          ;;                            (?a . "\\autocite[]{%l}")
          ;;                            (?p . "\\parencite{%l}")
          ;;                            (?f . "\\footcite[][]{%l}")
          ;;                            (?F . "\\fullcite[]{%l}")
          ;;                            (?x . "[]{%l}")
          ;;                            (?X . "{%l}"))))
          ;;   (setq reftex-cite-format 'biblatex))
          ))
#+end_src

* System
** Eshell
*** Visual

Contrary to ~term~ and ~shell~ (respectively invoked by =M-x <term/shell>=), [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][eshell]] is not /emulating/ anything: it is, on its own, a shell-like command interpreter implemented in Emacs Lisp. As such, it provides (most of) the usual commands such as ~grep~, ~ls~ and so on, as well as an extra binding to Emacs (for example, you can redirect the output of any command to an Emacs buffer). For this reason, you can use ~eshell~ on any system that is able to run Emacs, as there is no external dependency.

In fact, some of those commands are reimplemented in Emacs Lisp (/e.g./ ~cat~), some of them are using the Emacs tools (for example ~grep~), and unknown commands are passed to the /real/ commandline.

A more in-depth guide can be found [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][here]].

We install a few packages which make eshell easier to use.

#+begin_src emacs-lisp
  ;; eshell

  (setq eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t)

  (use-package eshell-did-you-mean
    :commands eshell
    :config (eshell-did-you-mean-setup))

  (use-package eshell-syntax-highlighting
    :hook (eshell-mode . eshell-syntax-highlighting-mode))

  (use-package eshell
    :ensure nil
    :defer t
    :hook (eshell-mode . (lambda ()
                           (bind-key "C-l" 'eshell/clear eshell-mode-map)))
    :config
    ;; From https://blog.liangzan.net/blog/2012/12/12/customizing-your-emacs-eshell-prompt/
    (defun lps/pwd-repl-home (pwd)
      (interactive)
      (let* ((home (expand-file-name (getenv "HOME")))
             (home-len (length home)))
        (if (and
             (>= (length pwd) home-len)
             (equal home (substring pwd 0 home-len)))
            (concat "~" (substring pwd home-len))
          pwd)))

    ;; See the possible colours: M-x list-colors-display
    (defun lps/curr-dir-git-branch-string (pwd)
      "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
      (interactive)
      (when (and (eshell-search-path "git")
                 (locate-dominating-file pwd ".git"))
        (let ((git-output (shell-command-to-string (concat "cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
          (propertize (concat "["
                              (if (> (length git-output) 0)
                                  (substring git-output 0 -1)
                                "(no branch)")
                              "]") 'face `(:foreground "green3")))))

    (defun lps/eshell-prompt-function ()
      (concat
       (propertize ((lambda (p-lst)
                      (if (> (length p-lst) 3)
                          (concat
                           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                                      (substring elm 0 1)))
                                      (butlast p-lst 3)
                                      "/")
                           "/"
                           (mapconcat (lambda (elm) elm)
                                      (last p-lst 3)
                                      "/"))
                        (mapconcat (lambda (elm) elm)
                                   p-lst
                                   "/")))
                    (split-string (lps/pwd-repl-home (eshell/pwd)) "/")) 'face `(:foreground "DeepSkyBlue1"))
       (or (lps/curr-dir-git-branch-string (eshell/pwd)))
       (propertize " # " 'face 'default)))

    ;; Change according to eshell-prompt-function
    (setq eshell-prompt-function 'lps/eshell-prompt-function)
    (setq eshell-prompt-regexp "^[^#$\n]* [#$] ")
    (setq eshell-highlight-prompt t))

  ;; (use-package eshell-git-prompt
  ;;   :config (eshell-git-prompt-use-theme 'powerline)) ;; Visually buggy
#+end_src
*** Bash/Fish completion
We use two packages to have a more powerful completion system in ~eshell~. The UI is akin to the one used by vanilla Emacs - it opens another buffer whenever you try to complete and there are more than one candidates - but it is still usable.

*MANUAL*  The second package, =fish-completion=, needs ~fish~ to be installed on the system (and that a ~fish~ executable can be found on the path).
#+begin_src emacs-lisp
  (use-package bash-completion
    :disabled t
    :after eshell
    :config
    (bash-completion-setup))

  (use-package fish-completion
    :disabled t
    :after eshell
    :config
    (when (executable-find "fish")
      (fish-completion-mode 1)
      (setq fish-completion-fallback-on-bash-p t)))
#+end_src

Another method, which tries to simulate the completion mechanism of ~fish~ shells, and which also provides suggestions based on history:

#+begin_src emacs-lisp
  ;; Straight from Centaur Emacs
  (use-package esh-autosuggest
    :after eshell
    :bind (:map eshell-mode-map
                ([remap eshell-pcomplete] . completion-at-point))
    :hook ((eshell-mode . esh-autosuggest-mode)
           (eshell-mode . eshell-setup-ivy-completion))
    :config (defun eshell-setup-ivy-completion ()
              "Setup `ivy' completion in `eshell'."
              (setq-local ivy-display-functions-alist
                          (remq (assoc 'ivy-completion-in-region
                                       ivy-display-functions-alist)
                                ivy-display-functions-alist))))
#+end_src

*** Aliases and commands
**** Aliases from .bashrc
*MANUAL* One thing that we might want to do is to be able to use aliases defined in =.bashrc= in ~eshell~. There are [[https://www.emacswiki.org/emacs/EshellAlias][several solutions]] to this problem, and the one I use only allows us to use bash aliases in ~eshell~ and not the contrary, for example.

We do this by adding the following line at the end of the =.bashrc= file:

#+begin_src sh
  alias | sed -E "s/^alias ([^=]+)='(.*)'$/alias \1 \2 \$*/g; s/'\\\''/'/g;" >~/.emacs.d/eshell/alias
#+end_src

It will simply go through the =.bashrc= file whenever you open a bash terminal, and each time it sees a line starting with ~alias~, it will generate the corresponding alias in an appropriate syntax and put it in the =eshell/alias= file where ~eshell~ reads its aliases.

Another solution is to parse the aliases each time we start ~eshell~. We do this by running the shell command =alias=, and we modify its ouput using temporary buffers.
For the moment, this solution is kind of broken, as the output of =(shell-command "alias")= is empty, because no aliases are "loaded" by Emacs unless we run the command in an actual shell (as run with =M-x shell=, for example).

#+begin_src emacs-lisp
    ;; From https://www.emacswiki.org/emacs/EshellAlias

    (defun lps/eshell-load-bash-aliases ()
      "Reads bash aliases from Bash and inserts
        them into the list of eshell aliases."
      (interactive)
      (progn
        (message "Parsing aliases")
        (shell-command "alias" "bash-aliases" "bash-errors")
        (switch-to-buffer "bash-aliases")
        (replace-string "alias " "")
        (goto-char 1)
        (replace-string "='" " ")
        (goto-char 1)
        (replace-string "'\n" "\n")
        (goto-char 1)
        (let ((alias-name) (command-string) (alias-list))
          (while (not (eobp))
            (while (not (char-equal (char-after) 32))
              (forward-char 1))
            (setq alias-name
                  (buffer-substring-no-properties (line-beginning-position) (point)))
            (forward-char 1)
            (setq command-string
                  (buffer-substring-no-properties (point) (line-end-position)))
            (setq alias-list (cons (list alias-name command-string) alias-list))
            (forward-line 1))
          (setq eshell-command-aliases-list (append alias-list eshell-command-aliases-list)))
        (if (get-buffer "bash-aliases")(kill-buffer "bash-aliases"))
        (if (get-buffer "bash-errors")(kill-buffer "bash-errors"))
  ))

    (add-hook 'eshell-mode-hook 'lps/eshell-load-bash-aliases)
#+end_src

**** Specific to Eshell
Some of our aliases will come from =.bashrc=. However, we still want to add aliases that make sense in ~eshell~.
#+begin_src emacs-lisp
  (use-package em-alias
    :ensure nil
    :after eshell
    :config
    (eshell/alias "f" "find-file $1")
    (eshell/alias "fo" "find-file-other-window $1")
    (eshell/alias "d" "dired $1"))
#+end_src

** Dired

Now, we try to add things on top of the built-in file manager, Dired.

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :defer t
    ;; Prevents dired from opening thousands of buffers
    :bind (:map dired-mode-map
                ("RET" . dired-find-alternate-file)
                ("^"   . (lambda () (interactive) (find-alternate-file ".."))))
    :custom
    ;; Delete and copy directories recursively
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always)
    (dired-auto-revert-buffer t)
    (dired-listing-switches "-alFh"))

  ;; Make things prettier
  (use-package all-the-icons-dired
    :diminish
    :hook (dired-mode . all-the-icons-dired-mode))

  ;; Extra functionalities
  (use-package dired-x
    :ensure nil
    :after dired)
#+end_src
* Email
** mbsync

We already configured Emacs to be our main Git client, and to be a PDF Viewer. We can go one step further, and use Emacs as a mail client.

There are already built-in tools to do this, for example [[https://www.gnus.org/][Gnus]]. However, they tend to be slow, and there are better alternatives. The one we use is combines several tools.

First of all, ~mbsync~. It synchronizes a local database to a distant one. It can be configured using the =~/.mbsyncrc= file. It is an alternative to ~offlineimap~, which is apparently slower and tends to crash a bit more.

*MANUAL* ~mbsync~ needs to be installed separately. It might be available in the ~isync~ package.

** mu4e

The actual mail client that we use is a frontend to =mu=, called [[https://github.com/djcb/mu/tree/master/mu4e][mu4e]]. Depending on your Linux distribution, you might encounter some troubles with the following code, as the syntax might have changed between the versions =1.2= and =1.3=.

*MANUAL* You need to install ~mu4e~ separately, either from the standard repositories of your distribution or directly from source. Once installed, you will need to execute a few commands to initialize everything, so please refer to the package documentation.

#+begin_src emacs-lisp
  (use-package smtpmail
    :ensure nil
    :after mu4e
    :config
    (setq message-send-mail-function 'smtpmail-send-it)
    ;; Default SMTP configuration
    (setq smtpmail-debug-info t)
    (setq smtpmail-smtp-user "lpaviets")
    (setq smtpmail-smtp-server "smtp.ens-lyon.fr")
    (setq smtpmail-smtp-service 587)
    (setq smtpmail-stream-type 'starttls))

  (use-package mu4e
    :ensure nil
    :load-path "/usr/local/share/emacs/site-lisp/mu4e" ;; Might be needed.
    :commands mu4e
    :bind (("C-c e" . mu4e)
           :map mu4e-compose-mode-map
           ("C-c C-h" . lps/org-mime-htmlize-preserve-secure-and-attach))
    :config
    (setq mu4e-completing-read-function 'ivy-completing-read)

    ;; Might avoid unwanted drafts
    (add-hook 'mu4e-compose-mode-hook #'(lambda () (auto-save-mode -1)))

    ;; Convenience functions
    (setq mu4e-compose-context-policy 'ask-if-none)
    (setq mu4e-context-policy 'ask-if-none)
    (setq message-kill-buffer-on-exit t)
    (setq mu4e-confirm-quit nil)

    ;; View images
    (setq mu4e-view-show-images t)
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    ;; ASCII-only time is over
    (setq mu4e-use-fancy-chars t)

    ;; Unless we want to send mail to very old clients
    (setq mu4e-compose-format-flowed t)

    ;; Avoid mail syncing issues with mbsync
    (setq mu4e-change-filenames-when-moving t)

    ;; Refresh mail every 5 minutes
    (setq mu4e-update-interval (* 5 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-index-update-in-background t)
    (setq mu4e-hide-index-messages t)

    ;; Always show full date and time
    (setq mu4e-headers-date-format "%d-%m-%Y %H:%M")

    ;; Less redundant information
    (setq mu4e-headers-include-related nil)
    (setq mu4e-headers-show-threads nil)

    ;; Keep one mail per line
    ;; Todo: fix so that it updates when window is resized
    (setq mu4e-headers-fields '((:human-date . 20)
                                (:flags . 6)
                                (:mailing-list . 10)
                                (:from-or-to . 22)
                                (:subject . 100)))

    (defun lps/resize-headers-fields ()
      (if (eq major-mode 'mu4e-headers-mode)
          (let ((width (window-body-width)))
            (setq-local mu4e-headers-fields `((:human-date . 20)
                                              (:flags . 6)
                                              (:mailing-list . 10)
                                              (:from-or-to . 22)
                                              (:subject . ,(- width (+ 20 6 10 22 15))))))))

    (add-hook 'mu4e-headers-mode-hook #'lps/resize-headers-fields)

    ;; Change: obsolete variable
    (setq mu4e-maildir "~/Mail")

    ;; Adapted from https://jherrlin.github.io/posts/emacs-mu4e/
    ;; See also https://etienne.depar.is/emacs.d/mu4e.html
    (setq mml-secure-cache-passphrase nil)
    (setq password-cache nil)
    ;;(setq mml-secure-openpgp-sign-with-sender t)
    (setq mml-secure-openpgp-encrypt-to-self t)
    ;;(setq mml-secure-smime-sign-with-sender t)
    (setq mml-smime-encrypt-to-self t) ;; encryption is not ready yet

    (setq mm-sign-option 'guided)

    (defun lps/sign-or-encrypt-message ()
      (let ((answer (read-from-minibuffer (concat "Sign or encrypt?\n"
                                                  "Empty to do nothing.\n[s/e]: "))))
        (cond
         ((string-equal answer "s") (progn
                                      (message "Sign this message.")
                                      ;; Why doesn't mml-secure-message-sign-pgpmime work ... ?
                                      (mml-secure-message-sign-pgpmime) ;;Works but only signs a part of the message.
                                      (message "Done trying to sign the message")))
         ((string-equal answer "e") (progn
                                      (message "Encrypt and sign this message.")
                                      (mml-secure-message-encrypt-pgpmime)
                                      (message "Done trying to encrypt the message")))
         (t (progn
              (message "Not signing or encrypting this message.")
              nil)))))

    (add-hook 'message-send-hook 'lps/sign-or-encrypt-message)


    ;; Before making a new context:
    ;; - Make sure that the [sent/trash/drafts] folders are correctly named, to avoid duplicates
    ;; - Don't forget to modify .mbsyncrc and .authinfo.gpg to correctly authenticate against
    ;; the IMAP and SMTP servers
    ;; - Make sure that your smpt-user ID, the port (smtp-service), etc, are the right ones; different
    ;; SMTP servers have different expectations, and there is no universal configuration
    (setq mu4e-contexts
          (list
           ;; School account
           (make-mu4e-context
            :name "ENS_Lyon"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/ENS_Lyon" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address  . "leo.paviet-salomon@ens-lyon.fr")
                    (user-full-name     . "Leo Paviet Salomon")
                    (mu4e-drafts-folder . "/ENS_Lyon/Brouillons")
                    (mu4e-sent-folder   . "/ENS_Lyon/Elements_envoyes")
                    ;;(mu4e-sent-messages-behavior . 'delete) ;; Not sure yet, better be safe
                    (mu4e-refile-folder . "/ENS_Lyon/Archive")
                    (mu4e-trash-folder  . "/ENS_Lyon/Corbeille")
                    (smtpmail-smtp-user    . "lpaviets")
                    (smtpmail-smtp-server  . "smtp.ens-lyon.fr")
                    (smtpmail-smtp-service . 587)
                    (smtpmail-stream-type  . starttls)))

           (make-mu4e-context
            :name "Unicaen"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/Unicaen" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address  . "leo.paviet-salomon@unicaen.fr")
                    (user-full-name     . "Leo Paviet Salomon")
                    (mu4e-drafts-folder . "/Unicaen/Drafts")
                    (mu4e-sent-folder   . "/Unicaen/Sent")
                    (mu4e-refile-folder . "/Unicaen/Archive")
                    (mu4e-trash-folder  . "/Unicaen/Trash")
                    (smtpmail-smtp-user    . "paviets201")
                    (smtpmail-smtp-server  . "smtp.unicaen.fr")
                    (smtpmail-smtp-service . 465)
                    (smtpmail-stream-type  . ssl)))

           (make-mu4e-context
            :name "Orange"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/Orange" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address  . "leo.paviet.salomon@orange.fr")
                    (user-full-name     . "Leo Paviet Salomon")
                    (mu4e-drafts-folder . "/Orange/DRAFT")
                    (mu4e-sent-folder   . "/Orange/OUTBOX")
                    ;; (mu4e-sent-messages-behavior . 'delete) ;; Not sure yet, better be safe
                    (mu4e-refile-folder . "/Orange/Archive")
                    (mu4e-trash-folder  . "/Orange/TRASH")
                    (smtpmail-smtp-user    . "leo.paviet.salomon@orange.fr")
                    (smtpmail-smtp-server  . "smtp.orange.fr")
                    (smtpmail-smtp-service . 465)
                    (smtpmail-stream-type  . ssl))))))
#+end_src

Because it might be a bit tedious to constantly open and quit the ~mu4e~ buffers to check for incoming messages, we use another package to get notifications informing us when we receive a new message.
This package might also be used to generate desktop notifications, although I do not use this functionality.

#+begin_src emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :config
    (mu4e-alert-enable-mode-line-display))
#+end_src

  One point that is a bit infuriating with the current state of ~mu4e~ is how you are supposed to manage attachments. In particular, you have to navigate in a whole filetree, everytime you want to attach a file. To my knowledge, there is no "easy and immediate" way to /e.g./ attach several files at once.

  To patch this, we use a few tricks, with ~ivy~ and ~gnus-dired~

  #+begin_src emacs-lisp
    ;; From https://github.com/iqbalansari/dotEmacs/blob/master/config/mail.org
    (use-package gnus-dired
      :ensure nil
      :after mu4e
      :hook (dired-mode . turn-on-gnus-dired-mode)
      :config
      ;; This overrides a function !
      (defun gnus-dired-mail-buffers ()
        "Return a list of active message buffers."
        (let (buffers)
          (save-current-buffer
            (dolist (buffer (buffer-list t))
              (set-buffer buffer)
              (when (and (derived-mode-p 'message-mode)
                         (null message-sent-message-via))
                (push (buffer-name buffer) buffers))))
          (nreverse buffers)))

      (setq gnus-dired-mail-mode 'mu4e-user-agent))


    (use-package dired
      :ensure nil
      :after gnus-dired
      :bind (:map dired-mode-map
                  ("E" . lps/mu4e-file-attach-marked-files))
      :config
      (defun lps/mu4e-file-attach-marked-files ()
        (interactive)
        (gnus-dired-attach (dired-map-over-marks (dired-get-file-for-visit) nil))))
#+end_src

** Org MIME

~mu4e~ in itself is not really able to send HTML e-mails. However, it is nowadays a given that people you are sending e-mails too are going to be able to visualize HTML-ized content, and they might even /assume/ that this is the case - meaning that a plain text e-mail will loo strange and/or unprofessional.

To deal with this problem, we use a ~org~ package, called [[https://github.com/org-mime/org-mime][Org MIME]], which uses the MIME protocol to encode the content of our email. Moreover, it allows us to write e-mails with the full power of ~org-mode~'s syntax and editing tools, and directly export them in HTML.

#+begin_src emacs-lisp
  (use-package org-mime
    :after mu4e
    :config
    ;; Make sure that this hook is added AFTER lps/sign-or-encrypt-message
    ;; so that it is executed BEFORE it.
    ;; We want to htmlize, then sign/encrypt, not the other way around !
    (add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)
    (setq org-mime-export-options'(:section-numbers nil
                                                    :with-author nil
                                                    :with-toc nil))

    ;; Hacky function to avoid big formatting problems when calling org-mime-htmlize
    ;; after having linked attachments, or signing/encrypting the message
    (defun lps/org-mime-htmlize-preserve-secure-and-attach ()
      (interactive)
      (let ((re-secure "<#secure method=[a-z]+ mode=[a-z]+>\n?")
            (re-attachment "<#part type=.* disposition=attachment.*>\n?<#/part>\n?")) ;; make sure that \n needs no escaping/formatting
        (let ((secure (lps/find-delete-forward-all-regexp re-secure (point-min)))
              (attachments (lps/find-delete-forward-all-regexp re-attachment (point-min))))
          (org-mime-htmlize)
          (save-excursion
            (goto-char (point-max))
            (while attachments
              (insert (pop attachments)))
            (message-goto-body)
            (while secure
              (insert (pop secure))))))))
#+end_src
* Web
** Gemini
An alternative to the traditional HTTP-world wide web, using a simpler protocol. See what [[https://drewdevault.com/][Drew DeVault]] has to say about it on his blog !
#+begin_src emacs-lisp
  (use-package elpher)
#+end_src
* Fun
As we tend to spend a lot of time in Emacs, isn't it natural to install fun and distracting packages ?
** XKCD
We /love/ [[https://xkcd.com][XKCD]], and so do most of Emacs users. Hence, someone has written a package to read his favourite web-comic directly within Emacs !

#+begin_src emacs-lisp
  (use-package xkcd
    :defer t)
#+end_src
** Keyboard games
*** Speed-typing
This package can help you benchmark how fast you are able to write text within Emacs, by using random text samples that you have to copy. It is even possible to add some other books from which to generate those samples.

#+begin_src emacs-lisp
  (use-package speed-type
    :defer t
    :custom (speed-type-default-lang 'French)) ; Todo: fix bad behaviour !
#+end_src
*** Key Quiz

Another cool thing to do if you want to learn keybindings in a very inefficient way is to simply pick a command at random and try to remember the associated keybinding ! This is exactly what the following package tries to do

#+begin_src emacs-lisp
  (use-package key-quiz
    :defer t)
#+end_src
* TODO Small things to do next
** Eshell and .bashrc
Use two different files that are "loaded" by eshell. The first one contains the .bashrc aliases, the other one contains the usual eshell aliases, and at startup, we momentarily merge the two.
** LaTeX
- Fix the fact the Tikz keywords incorrectly highlighted (they are "unknown") [[https://tex.stackexchange.com/questions/113970/emacs-auctex-customization-of-keyword-highlight-syntax][Syntax highlighting]]
- Try to fix company. See e.g. [[https://tex.stackexchange.com/questions/58998/does-auctex-autocomplete][this post]] Want to have both math-symbols and capf, because TeX-complete-symbol uses it.
- Fix the fact that commands defined by \newcommand are not properly highlighted (as TikZ commands)
