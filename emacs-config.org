
#+title: Emacs Configuration
#+author: LÃ©o Paviet Salomon
#+STARTUP: content
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Organization of this file

  This file contains a Emacs configuration, written in a Org Mode document. It is largely based on [[https://github.com/daviwil/emacs-from-scratch/][Emacs From Scratch]].

  It is able to automatically generate a init.el file, loaded by Emacs at startup.

  If this file is on the path "~/.emacs.d/emacs-config.org" then it will automatically generate an output. To modify this behaviour, see the "Org Mode/Auto-tangle configuration files" subsection and modify it as you need.

  If this file is named differently on your system, or simply located in another directory, you can still generate an output without changing anything by invoking the =org-babel-tangle= command (=C-c C-v t=).

  Because I use a version system on those files, I don't mind conflicts with the currently loaded configuration file, and so the the generated file is actually called  =init.el=. By default, Emacs reads (and loads) file such as "~/.emacs" or "~/.emacs.d/init.el" at startup, so the output of =org-babel-tangle= is automatically replacing the previous configuration file. If you want to avoid those conflicts, you might need to rename it.

  To modify the name of the output, you can change it in the second line of this document, after the =:tangle= keyword.

  Some commands have to be run manually whenever the generated =init.el= file is loaded for the first time.

  Whenever this is the case, it is explicitly signaled by the presence of the *MANUAL* keyword in front of those commands.

  If the init.el cannot be properly loaded at startup, try to search for such keywords in this file and execute the corresponding commands.

* Initialization
** Emacs performance

First, we set things up so that Emacs starts /fast/.

#+begin_src emacs-lisp
(setq gc-cons-threshold 100000000) ; 1e8 = 100 MB (default: 800kB)
#+end_src

Another thing that might be of interest is to know how long it took for Emacs to start. Although there is already a built-in function to do this (try to call =emacs-init-time= in any Emacs session), we want it to be automatically displayed anytime we start Emacs

#+begin_src emacs-lisp
  (defun my-display-startup-time ()
    (message "Emacs started in %s seconds"
             (format "%.2f"
                     (float-time
                      (time-subtract after-init-time before-init-time)))))

  (defun my-display-garbage-collection ()
    (message "Emacs performed %d garbage collection"
             gcs-done))

  (defun my-restore-gc-cons ()
    ;; After startup, we restore gc-cons-threshold to a more reasonable value
    (setq gc-cons-threshold 10000000)) ; 1e7 = 10 MB

  (add-hook 'emacs-startup-hook #'my-display-startup-time)
  (add-hook 'emacs-startup-hook #'my-display-garbage-collection)
  (add-hook 'emacs-startup-hook #'my-restore-gc-cons)

#+end_src

** Package management

Then, we need to configure how we will install packages. We use another package manager that the default one: =use-package=.

It makes both installation and customization easier, and the code is also simpler to read.

*MANUAL* You might want to configure =use-package= differently, as it is the tool used everywhere else in this configuration file to install and setup other packages. For example, the line
=(setq use-package-always-ensure t)= is used to install all the packages mentioned in this file automatically if you do not already have them. Depending on your environment, you might want to consider another, more appropriate behaviour (/e.g./  if you lack space, time, if you use another OS, if you are already compiling some of those packages by yourself, and so on).

#+begin_src emacs-lisp
  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)

  (unless package-archive-contents
   (package-refresh-contents))

  ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
     (package-install 'use-package))

  ;; Other packages
  (add-to-list 'load-path "~/.emacs.d/extra-packages")

  (require 'use-package)
  ;; Comment this line if you don't want to automatically install
  ;; all the packages that you are missing
  (setq use-package-always-ensure t)

#+end_src

** Quick restart

In order to test things more rapidly and to be able to apply configuration changes without ever leaving Emacs, we also install another package to restart Emacs with a simple command.

#+begin_src emacs-lisp
  (use-package restart-emacs
    :commands (restart-emacs restart-emacs-start-new-emacs))
#+end_src

** Custom file

We do not want Emacs to mess with our own =init.el= file, and so we tell it where to store all its precious customizations

#+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(load custom-file 'noerror)
#+end_src

* UI Configuration
** Visual interface changes

We remove all the unnecessary elements from the interface, /e.g./ menus, scroll bar and so on.

You can remove or partially modify this block of code if you are a beginner and want to keep some of elements available, especially to be able to navigate with the mouse.

All the variable names are pretty explicit, so you should be able to customize this to your taste easily.

*** Startup

Who wants to be told the same thing over and over again each time they start Emacs ?
#+begin_src emacs-lisp
  ;; Disable the annoying startup message and Emacs logo
  (setq inhibit-startup-message t)

  ;; Disable the message on top of the Scratch buffer
  (setq initial-scratch-message nil)
#+end_src

However, we would like to see Emacs in full-screen if we are to use it

#+begin_src emacs-lisp
  ;; Maximize the Emacs frame at startup
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Because we tend to use =eshell= for everything that is shell-related (see the Eshell section later in this file), we also start it whenever we start Emacs.
#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook (lambda () (eshell) (previous-buffer)))
#+end_src

*** Menus and toolbars

Emacs is very much keyboard-oriented. As such, we have little-to-no use of the various menus, toolbars and scrollbars that Emacs provides.

#+begin_src emacs-lisp
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)          ; Disable the menu bar
#+end_src

*** Lines and columns

Because we now have plenty of free space on our screen, we can sacrifice a bit of it to put useful information there, such as line numbers. We also want to see the current line and column in the modeline.

#+begin_src emacs-lisp
  ;; Global line/column numbering mode
  ;; Modes in which we might want to disable it:

  (column-number-mode t)
  (global-display-line-numbers-mode t)

  (defun my-disable-line-numbers ()
    (display-line-numbers-mode 0))

  (dolist (mode '(org-mode-hook
                 ; Term & Shells
                  eshell-mode-hook
                  comint-mode-hook
                  ; PDF viewers
                  pdf-view-mode-hook
                  doc-view-mode-hook
                  ; Help modes
                  helpful-mode-hook
                  help-mode-hook
                  apropos-mode-hook
                  ; Extra modes
                  undo-tree-visualizer-mode-hook
                  treemacs-mode-hook
                  dired-mode-hook))

  (add-hook mode #'my-disable-line-numbers))
#+end_src

While we are at it, we also want Emacs to wrap our lines, so that we never have to scroll horizontally to see the end of a long line (besides, how would we do it, now that we don't have a scrollbar anymore ?!)

#+begin_src emacs-lisp
(global-visual-line-mode 1)
#+end_src

*** Theme

This is simply a way to change how Emacs looks. Some themes are more complete than other (they will modify how other packages look, like Magit, or even the minibuffer)

#+begin_src emacs-lisp
  ;; Themes
  (use-package solarized-theme)
  (use-package kaolin-themes)
  (use-package doom-themes
    :init (load-theme 'doom-Iosvkem t))
#+end_src

There used to be a package called [[https://github.com/toroidal-code/cycle-themes.el][cycle-themes]] that would allow you to cycle through all (or a predefined list of) your themes, but it seems that it no longer works due to some other packages becoming deprecated. Here is a small function that does the same thing.

#+begin_src emacs-lisp
  ;; Use this to store your favourite themes
  ;; Save your usual, default theme in first position
  ;; so that you can easily switch back to it with
  ;; (load-theme (car lps/rotate-themes-list) t)
  (setq lps/rotate-themes-list
        '(doom-Iosvkem kaolin-ocean kaolin-aurora doom-monokai-pro doom-palenight tsdh-dark solarized-dark))

  ;; Try to save the current theme
  ;; Be careful ! Some visual changes are NOT stored in
  ;; a theme, and will not be retrieved by the restoring
  ;; functions. For example, any font configuration might
  ;; be "lost" for this session
  (setq lps/initial-enabled-themes custom-enabled-themes)

  (setq lps/rotate-theme-index 0)

  (defun lps/rotate-through-themes ()
    "Cycles through the next theme in the `lps/rotate-themes-list'.
  If this list is empty or does not exist, cycle through all the
  installed themes instead."
    (interactive)
    (mapc #'disable-theme lps/initial-enabled-themes)
    (let* ((themes-list (or (and (boundp 'lps/rotate-themes-list) lps/rotate-themes-list)
                            (custom-available-themes)))
           (next-index (mod (+ lps/rotate-theme-index 1) (length themes-list)))
           (current-theme (nth lps/rotate-theme-index themes-list))
           (next-theme (nth next-index themes-list)))
      (setq lps/rotate-theme-index next-index)
      (disable-theme current-theme)
      (load-theme next-theme t)))

  (defun lps/restore-initial-themes ()
    (interactive)
    (mapc #'disable-theme custom-enabled-themes)
    (mapc (lambda (theme) (funcall #'load-theme theme t)) lps/initial-enabled-themes))
#+end_src

*** Modeline and icons

This modifies how the [[https://www.emacswiki.org/emacs/ModeLine][modeline]] looks.

*MANUAL* If this is your first time running the init.el file, please run the following command:

=M-x all-the-icons-install-fonts=

#+begin_src emacs-lisp
  ;; First time used: run M-x all-the-icons-install-fonts
  (use-package all-the-icons
    :config
    ;; Avoid unnecessary warnings
    (declare-function all-the-icons-faicon 'all-the-icons)
    (declare-function all-the-icons-fileicon 'all-the-icons)
    (declare-function all-the-icons-material 'all-the-icons)
    (declare-function all-the-icons-octicon 'all-the-icons)

    ;;define an icon function with all-the-icons-faicon
    ;;to use filecon, etc, define same function with icon set
    (defun with-faicon (icon str &rest height v-adjust)
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))
    ;; filecon
    (defun with-fileicon (icon str &rest height v-adjust)
      (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))

  (use-package doom-modeline
    :after all-the-icons
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))
#+end_src

*** Interactively change the UI

This is one moment where a pretty hydra could help us change general UI parameters, such as the text size, some highlighting options and so on.

#+begin_src emacs-lisp
  (with-eval-after-load 'hydra
    ;; define a title function
    (defvar appearance-title (with-faicon "desktop" "Appearance"))

    ;; Other idea:
    ;; (defvar appearance-title (with-faicon "toggle-on" "Toggles" 1 -0.05))

    ;; generate hydra

    (pretty-hydra-define hydra-appearance (:title appearance-title
                                           :quit-key "q"
                                          ;:pre (hydra-posframe-mode t)
                                          ;:post (hydra-posframe-mode 0) ; dirty hack
                                                  )
      ("Theme"
       (
        ;;     ("o" olivetti-mode "Olivetti" :toggle t)
        ;;     ("t" toggle-window-transparency "Transparency" :toggle t )
        ("c" cycle-themes-mode "Cycle Themes" )
        ("+" text-scale-increase "Zoom In")
        ("-" text-scale-decrease "Zoom Out")
        ("x" toggle-frame-maximized "Maximize Frame" :toggle t )
        ("X" toggle-frame-fullscreen "Fullscreen Frame" :toggle t))
       "Highlighting"
       (("d" rainbow-delimiters-mode "Rainbow Delimiters" :toggle t )
        ("r" rainbow-mode "Show Hex Colours" :toggle t )
        ;;    ("n" highlight-numbers-mode "Highlight Code Numbers" :toggle t )
        ("l" display-line-numbers-mode "Show Line Numbers" :toggle t )
        ("_" global-hl-line-mode "Highlight Current Line" :toggle t )
        ;;    ("I" rainbow-identifiers-mode "Rainbow Identifiers" :toggle t )
        ("b" beacon-mode "Show Cursor Trailer" :toggle t )
        ("w" whitespace-mode "whitespace" :toggle t))
      "Miscellaneous"
      (("j" visual-line-mode "Wrap Line Window"  :toggle t)
       ("m" visual-fill-column-mode "Wrap Line Column"  :toggle t)
       ;;    ("a" adaptive-wrap-prefix-mode "Indent Wrapped Lines" :toggle t )
       ;;   ("i" highlight-indent-guides-mode  "Show Indent Guides" :toggle t )
       ("g" fci-mode "Show Fill Column" :toggle t )
       ("<SPC>" nil "Quit" :color blue )))))

  (global-set-key (kbd "C-c h a") 'hydra-appearance/body)

#+end_src
*** Extra packages

Some packages are used lated in the configuration, and we want to be able to use those comfortable modes.

#+begin_src emacs-lisp
  ;; Generic UI modes

  (use-package beacon
    :init (beacon-mode))
  (use-package rainbow-mode
    :defer t)
  (use-package fill-column-indicator
    :defer t)
  (use-package visual-fill-column
    :defer t)
#+end_src

** Whitespaces

First of all, we never want "TAB" to insert actual tab characters.

#+begin_src emacs-lisp
  ;; Tab behaviour and whitespaces
  (setq-default indent-tabs-mode nil)
  (setq tab-width 4)
#+end_src

Then, we do not want to repeatedly spam the =<DEL>= key in order to delete a long sequence of whitespaces.

#+begin_src emacs-lisp
(use-package hungry-delete
  :ensure t
  :defer t
  :init
  (global-hungry-delete-mode 1))
#+end_src

** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] is a package that is used to group several related commands into a family of bindings, all starting with the same prefix (= "hydra"). Whenever this common prefix is entered in a suitable mode, a panel shows up, showing all the user-defined commands that can now be invoked with a single keystroke instead of repeatedly using the same long prefix.

#+begin_src emacs-lisp
(use-package hydra
  :defer t)
#+end_src

All the hydras will now be defined after the package to which they correspond, or in the appropriate section. Most of them are modifications of hydras that can be found on the [[https://github.com/abo-abo/hydra/wiki][hydra wiki]].

Some hydras will be called less frequently and for other purposes than getting a "quick-and-dirty" access to commonly used functions. Hence, we will make them prettier (the compromise being that they are less minimalistic and take much more space visually)


*MANUAL* This is not a MELPA package. It can be found [[https://github.com/Ladicle/hydra-posframe][here]]. Install it and change the loading path according to your configuration.

#+begin_src emacs-lisp
  (use-package posframe
    :defer t)

  ;; Manual load and config of Hydra Posframe
  ;; To fix: find a way to override parameters ...
  ;; (load-file "~/.emacs.d/extra-packages/hydra-posframe.el")
  ;; (setq hydra-posframe-border-width 5)

  ;Pretty Hydra
  (use-package pretty-hydra
    :defer t
    :after hydra)
#+end_src

** Font and encoding

Even if most of the time, you should be working with UTF-8, we still want to make sure that this is the default and that Emacs assumes that we are using UTF-8

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-clipboard-coding-system 'utf-8)
  (set-file-name-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src

** Commands
*** Disable

We want to use the full Emacs power. However, if you find yourself using repeatedly a dangerous command by mistake, you might want to disable it

#+begin_src emacs-lisp
  ;; Don't disable any command
  ;; BE CAREFUL
  ;; If you are a new user, you might to comment out this line
  (setq disabled-command-function nil)

#+end_src

There is, however, one really annoying binding, especially for new users or people used to ... computers, calling the =suspend-frame= command. For people who are using it, do not worry, it is still available on =C-x C-z= anyway.

#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
#+end_src

*** Command log mode

This mode allows you to display a small panel on the right of the screen which shows which keys you are pressing, and what commands they are associated to, all of this in real time !

As of now, you need to enable the mode by using the =command-log-mode= command (or =global-command-log-mode= if you want to record everything, in all the buffers of the current session), and to use the =C-c o= keybinding (which calls the =clm/toggle-command-log-buffer= function) to open a new buffer in which you will see both the keybindings you are currently using and the commands to which they are bound.

If you want =command-log-mode= to be activated by default in certain minor (or even major) modes, simply add a hook. You will still need to explicitly open the buffer, but this could also be dealt with by using other, straightforward hooks.

#+begin_src emacs-lisp
(use-package command-log-mode
;; :hook (<your-favourite-mode> . command-log-mode) ; Add here modes in which you want to run the command-log-mode
  :commands command-log-mode
)
#+end_src

*** Confirmation

Typing "yes" and "no" might be a bit too tiring

#+begin_src emacs-lisp
  ;; Type "y" instead of "yes RET" for confirmation
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Help

Because there are a lot of similar commands, it is quite easy to get lost. [[https://github.com/justbur/emacs-which-key][which-key]] is a package that shows all the available commands after having typed some prefix, meaning that knowing the beginning of a key sequence is enough to get the rest of the information.

For example, if you press =C-c=, then a panel will appear at the bottom of the screen to show how you can currently continue this command, depending on which buffer you are in.


#+begin_src emacs-lisp
  ;; which-key. Shows all the available key sequences after a prefix
  (use-package which-key
    :init (which-key-mode)
    :diminish
    :custom (which-key-idle-delay 1))
#+end_src

*** Some macros

In this section, we define some useful macros to write code in Emacs Lisp.

#+begin_src emacs-lisp
  ;; Macro to use "python-style" affectation in lexical bindings
  (defmacro multi-let (vars values body)
    "Binds each symbol of VARS to its corresponding expression in VALUES,
    in order.
    multi-let (a b) (e1 e2) body is thus equivalent to
    (let ((a e1)) (let ((b e2)) body))
    Expressions at position k in VALUES might depend on symbol from
    VARS at position strictly less than k, as with let*"
    (defun rec-expand-let (vars values body)
      (if (= (length vars) (length values))
          (if (and vars (symbolp (car vars)))
              `(let ((,(car vars) ,(car values)))
                 ,(rec-expand-let (cdr vars)
                                  (cdr values)
                                  body))
            body)
        (message
         (format "Trying to bind %d symbols to %d values"
                 (length vars)
                 (length values)))))

    (rec-expand-let vars values body))
#+end_src

** Minibuffer

Although emacs provides a number of commands to navigate within a file, to find documentation and so on, the following packages will make the general UI easier to use.

[[https://github.com/abo-abo/swiper][Ivy and Counsel]] are completion and narrowing frameworks that allow you to use the minibuffer more comfortably.

#+begin_src emacs-lisp
  ;; Ivy
  (use-package ivy
    :diminish 
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-partial-or-done)
           ("C-l" . my-ivy-alt-done-t) ; Small hack
           :map ivy-switch-buffer-map
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    ;; Todo: check if ivy-use-selectable-prompt does the trick
    (defun my-ivy-alt-done-t ()
      (interactive)
      (ivy-alt-done t))

    :init (ivy-mode 1))

  ;; Adds things to Ivy
  (use-package ivy-rich
    :after ivy
    :init (ivy-rich-mode 1))

  ;; Counsel. Adds things to Ivy
  (use-package counsel
    :init (counsel-mode 1)
    :diminish
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-ibuffer)
           ("C-x C-f" . counsel-find-file)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history)))

#+end_src

Because we often find ourselves repeating the same command  (or variants of it) in the minibuffer, we might want to have a quick access to the history

#+begin_src emacs-lisp
  (use-package amx
     :init (setq amx-history-length 10))
#+end_src

** Buffer and windows
*** Buffer management
Emacs is sometimes all over the place, opening buffers at seemingly random places, switching your focus only in some circumstances ... We will customize this behaviour so that we have a better control on what Emacs is doing when we open new buffers

#+begin_src emacs-lisp
  ;; Automatically reload a file if it has been modified
  (global-auto-revert-mode t)

  ;;Buffer management
  (setq display-buffer-base-action
        '((display-buffer-reuse-window)
          (display-buffer-reuse-mode-window)
          (display-buffer-same-window)
          (display-buffer-in-previous-window)))

  ;; Can even have further control with
  ;; display-buffer-alist, or using extra-parameters

#+end_src

Another annoying thing is that we tend to have /a lot/ of open buffers at the same time, and there will invariably be some conflicts in their names. We want to be able to quickly distinguish which file is buffer is visiting.

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-after-kill-buffer-p t)
#+end_src

We also improve the appearance (and functionalities) of the buffer that we get when we want to list all the buffers that are currently opened.

#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :after ibuffer counsel
    :init (all-the-icons-ibuffer-mode 1))

  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))

#+end_src

A cool function to rename both a buffer and the file that it is visiting, while being careful e.g. not to override anything

#+begin_src emacs-lisp
  ;; From Magnars, from emacsrocks.com
  (defun rename-current-buffer-file ()
      "Renames current buffer and file it is visiting."
      (interactive)
      (let* ((name (buffer-name))
            (filename (buffer-file-name))
            (basename (file-name-nondirectory filename)))
        (if (not (and filename (file-exists-p filename)))
            (error "Buffer '%s' is not visiting a file!" name)
          (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
            (if (get-buffer new-name)
                (error "A buffer named '%s' already exists!" new-name)
              (rename-file filename new-name 1)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)
              (message "File '%s' successfully renamed to '%s'"
                       name (file-name-nondirectory new-name)))))))
#+end_src

*** Window management

Because window management can be a bit tedious with the basic Emacs functionalities, we improve it a bit. First of all, we enable =winner-mode=, which allows us to "undo" and "redo" changes in the Windows' configuration.

#+begin_src emacs-lisp
(winner-mode 1)

#+end_src

To facilitate window management, we use an hydra, binding most of the commands that we might ever need.

First of all, we use a few helper functions, defined in [[https://github.com/abo-abo/hydra/blob/master/hydra-examples.el][hydra-examples.el]]

#+begin_src emacs-lisp
;;* Helpers
(use-package windmove
  :defer t)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))
#+end_src

Now, we wrap everything up into a nice hydra

#+begin_src emacs-lisp
(global-set-key
(kbd "C-c h w") ; w for window
(defhydra hydra-window (:color red
                        :hint nil)
"
^Focus^           ^Resize^       ^Split^                 ^Delete^          ^Other
^^^^^^^^^-------------------------------------------------------------------------------
_b_move left      _B_left        _V_split-vert-move      _o_del-other      _nf_new-frame
_n_move down      _N_down        _H_split-horiz-move     _da_ace-del       _u_winner-undo
_p_move up        _P_up          _v_split-vert           _dw_del-window    _r_winner-redo
_f_move right     _F_right       _h_split-horiz          _df_del-frame
_q_uit
"
  ; Move the focus around
  ("b" windmove-left)
  ("n" windmove-down)
  ("p" windmove-up)
  ("f" windmove-right)
  ; Changes the size of the current window
  ("B" hydra-move-splitter-left)
  ("N" hydra-move-splitter-down)
  ("P" hydra-move-splitter-up)
  ("F" hydra-move-splitter-right)
  ; Split and move (or not)
  ("V" (lambda ()
         (interactive)
         (split-window-right)
         (windmove-right)))
  ("H" (lambda ()
         (interactive)
         (split-window-below)
         (windmove-down)))
  ("v" split-window-right)
  ("h" split-window-below)
  ;("t" transpose-frame "'")
  ;; winner-mode must be enabled
  ("u" winner-undo)
  ("r" winner-redo) ;;Fixme, not working?
  ; Delete windows
  ("o" delete-other-windows :exit t)
  ("da" ace-delete-window)
  ("dw" delete-window)
  ("db" kill-this-buffer)
  ("df" delete-frame :exit t)
  ; Other stuff
  ("a" ace-window :exit t)
  ("nf" new-frame :exit t)
  ("s" ace-swap-window)
  ("q" nil)
  ;("i" ace-maximize-window "ace-one" :color blue)
  ;("b" ido-switch-buffer "buf")
  ("m" headlong-bookmark-jump)))
#+end_src
** Help !

Emacs already has a /great/ documentation system, but it is still possible to improve it ! [[https://github.com/Wilfred/helpful][helpful]] makes things easier to remember and to use without having to search for documentation in multiple places.

It will condense all the available information about something within a single Help buffer, and will add some documentation to the commands you are currently typing.

#+begin_src emacs-lisp
  ;; Helpful. Extra documentation when calling for help
  (use-package helpful
    :after counsel
    :custom
    (counsel-describe-symbol-function   #'helpful-symbol) 
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-symbol]   . counsel-describe-symbol)
    ([remap describe-key]      . helpful-key)
    ("C-h u"                   . helpful-at-point)) ;; Help "<u>nder" cursor

#+end_src

* Editing

   Emacs is fundamentally a text editor. It provides a lot of functions to deal with text, and a way to create macros, to automate things, to repeat something multiple times ... easily. However, because there are /so many/ available functions, we might need some help to navigate around and do fancy things.
** Multiple cursors

A first improvement is the addition of multiple cursors. The "rectangle region" already gives a way to insert text simultaneously at several places, and to perform some easy operations on a rectangular area, but the [[https://github.com/magnars/multiple-cursors.el][multiple cursor]] package really increases the possibilities.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
    (("C-c o <SPC>" . mc/vertical-align-with-space)
     ("C-c o a"     . mc/vertical-align)
     ("C-c o m"     . mc/mark-more-like-this-extended)
     ("C-c o h"     . mc/mark-all-like-this-dwim)
     ("C-c o l"     . mc/edit-lines)
     ("C-c o n"     . mc/mark-next-like-this)
     ("C-c o p"     . mc/mark-previous-like-this)
     ("C-c o C-,"   . mc/mark-all-like-this)
     ("C-c o C-a"   . mc/edit-beginnings-of-lines)
     ("C-c o C-e"   . mc/edit-ends-of-lines)
     ("C-c o r"     . mc/mark-all-in-region)))
#+end_src

The webpage specifies that the commands provided by this package are best invoked when bound to key sequence rather than by =M-x <mc/command-name>=, although some testing on my part seems to show that it still works relatively well most of the time.

** Movement

Because movement keys are the most frequently used ones, it might be useful to create an Hydra helping us navigate around a document.

#+begin_src emacs-lisp
(global-set-key
 (kbd "C-c h m")
 (defhydra hydra-move ()
   "Movement" ; m as in movement
   ("n" next-line)
   ("p" previous-line)
   ("f" forward-char)
   ("b" backward-char)
   ("a" beginning-of-line)
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)))
#+end_src

** Rectangles

Manipulating rectangles is a cool Emacs feature. You can select a region with the shape of a rectangle, copy and yank it, insert strings at the beginning of each line of the selection, and several other features.

Because the functions operating on rectangles are not always the easier to remember, we simply define a new Hydra referencing the most useful ones.

#+begin_src emacs-lisp
(global-set-key
(kbd "C-c h r") ; r as rectangle
(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :hint nil
                                     :post (deactivate-mark))
  "
  ^_p_^       _w_ copy      _o_pen       _N_umber-lines                   |\\     -,,,--,,_
_b_   _f_     _y_ank        _t_ype       _e_xchange-point                 /,`.-'`'   ..  \-;;,_
  ^_n_^       _d_ kill      _c_lear      _r_eset-region-mark             |,4-  ) )_   .;.(  `'-'
^^^^          _u_ndo        _q_ quit     _i_nsert-string-rectangle      '---''(./..)-'(_\_)
"
  ("p" rectangle-previous-line)
  ("n" rectangle-next-line)
  ("b" rectangle-backward-char)
  ("f" rectangle-forward-char)
  ("d" kill-rectangle)                    ;; C-x r k
  ("y" yank-rectangle)                    ;; C-x r y
  ("w" copy-rectangle-as-kill)            ;; C-x r M-w
  ("o" open-rectangle)                    ;; C-x r o
  ("t" string-rectangle)                  ;; C-x r t
  ("c" clear-rectangle)                   ;; C-x r c
  ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
  ("N" rectangle-number-lines)            ;; C-x r N
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)))        ;; C-x SPC
  ("i" string-insert-rectangle)
  ("u" undo nil)
  ("q" nil)))
#+end_src

** Selection

A useful tool to manipulate text and even source code is the [[https://github.com/magnars/expand-region.el][expand-region]] package, as it allows us to increase the selected region to match larger and larger /semantic/ units. For example, by using it repeatedly, you could select in this order a character, a word, a string containing this word, a sexp containing this string, and the function in this sexp is used.

#+begin_src emacs-lisp
(use-package expand-region
:bind ("C-=" . er/expand-region))
#+end_src

We also define functions that Emacs is surprinsingly lacking.

The first one is used to copy without deleting the current line (internally, it uses =kill-ring-save=, and so it can be used in a read-only context, unlike a sequence like =C-a C-k C-y=). It is also much quicker than variations on the sequence  =C-e C-SPC C-a M-w=.

#+begin_src emacs-lisp
   (defun lps/copy-line-at-point (arg)
     "Copy ARG lines in the kill ring, starting from the line at point and copying subsequent ones if ARG > 1"
     (interactive "p")
     (kill-ring-save (line-beginning-position)
                     (line-end-position arg)))

  ; Note that this keybinding overrides other functions
  ; By default, M-k is kill-sentence, which I never use
  ; I bound it this way to mirror the C-w/M-w symmetry 

  ;; Might want to find a more clever way to use personal
  ;; keybindings, such as defining a minor mode ...
  (global-set-key (kbd "M-k") 'lps/copy-line-at-point)
#+end_src

** Undo

Another very useful package is undo-tree, which allows you to visualize the previous "Undos" and navigate them.

It can act as a small, local version control system due to how Undos are managed by Emacs.

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (setq undo-tree-visualizer-timestamps t)
    (global-undo-tree-mode)
    :diminish (undo-tree-mode))

#+end_src

* Programming
** Projectile

    [[https://projectile.mx/][Projectile]] is an Emacs package that makes project management easier. It allows us /e.g./ to navigate between files of the same project, search/replace within files of the same project, and integrates very well with other tools, such as =lsp-mode= or =counsel=.

#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :init
  ;; NOTE: Set this to the folder where you keep your Git repos!
  ;; (when (file-directory-p "path/to/project/dir")
  ;; (setq projectile-project-search-path '("path/to/project/dir")))
  (setq projectile-switch-project-action #'projectile-dired)

  :config
  (projectile-mode)
  :custom ((projectile-completion-system 'ivy))
  :bind-keymap
  ("C-c p" . projectile-command-map))

(use-package counsel-projectile
  :after (counsel projectile)
  :config (counsel-projectile-mode))

#+end_src

** Git
*** Magit
[[https://magit.vc/][Magit]] is a serious contender for the first place in the long list of "Reasons you should use Emacs", along with Org Mode.

It is a Text User Interface to Git, which integrates most of Git commands, even the most advanced ones, while making it easy to use even for beginners.

#+begin_src emacs-lisp
  (use-package magit
    ;; :custom (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    ;; uncomment previous line to have magit open itself within the same buffer
    ;; instead of in another buffer
    :bind ("C-x g" . magit-status))
#+end_src

*** Git-timemachine

Another useful package is [[https://github.com/emacsmirror/git-timemachine][git-timemachine]], which allows to easily navigate the history of a git-controlled file with a few key presses.

Although Magit is more or less able to do the same thing, the interface there is cleaner and you are less likely to get lost than in the fully-featured super-package that Magit is.

#+begin_src emacs-lisp
  (use-package git-timemachine
    :defer t)
#+end_src
** Parenthesis

First of all, we want to easily be able to tell with a quick glance which parenthesis are matching

#+begin_src emacs-lisp
  ;; Always highlight matching parenthesis
  (show-paren-mode t)

  ;; rainbow-delimiters. Hightlights with the same colour matching parenthesis
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Now, in order to work with structured text, such as source code, we want to be able to directly manipulate "expressions" rather than lines or words. This is why we use the following packages, as they provide a lot of functionalities to navigate and edit those expressions.

#+begin_src emacs-lisp
  ;; Smartparens is currently bugged
  (use-package smartparens
    :disabled t
    :custom (sp-highlight-pair-overlay nil)
    :hook (smartparens-mode . show-smartparens-mode)
    :bind
    ("C-M-f" . sp-forward-sexp)
    ("C-M-b" . sp-backward-sexp)

    ;; Define those as in paredit
    ("C-M-n" . sp-up-sexp)
    ("C-M-d" . sp-down-sexp)
    ("C-M-u" . sp-backward-up-sexp)
    ("C-M-p" . sp-backward-down-sexp)

    ("C-S-a" . sp-beginning-of-sexp)
    ("C-S-e" . sp-end-of-sexp)

    ("C-M-t" . sp-transpose-sexp)

    ("C-M-k" . sp-kill-sexp)
    ("C-M-w" . sp-copy-sexp)

    ("M-<delete>" . sp-unwrap-sexp)
    ("M-<backspace>" . sp-backward-unwrap-sexp)

    ("C-<right>" . sp-forward-slurp-sexp)
    ("C-<left>" . sp-forward-barf-sexp)
    ("C-M-<left>" . sp-backward-slurp-sexp) ; kbd ghosting ?
    ("C-M-<right>" . sp-backward-barf-sexp) ; kbd ghosting ?

    ("M-s" . sp-splice-sexp) ; unbinds "occur"
    ;; ("C-M-<delete>" . sp-splice-sexp-killing-forward)
    ;; ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
    ;; ("C-S-<backspace>" . sp-splice-sexp-killing-around)

    ("M-F" . sp-forward-symbol)
    ("M-B" . sp-backward-symbol))


  (use-package paredit
    :hook ((mrepl-mode
            eshell-mode
            ielm-mode
            eval-expression-minibuffer-setup
            emacs-lisp-mode
            lisp-mode
            lisp-interaction-mode) . paredit-mode))
#+end_src

** Auto-completion
**** YASnippet

     A first useful package is YASnippet, which makes it easy to define and automatically insert snippets of code in various languages.

#+begin_src emacs-lisp
  ;;YASnippet
  (use-package yasnippet
    :diminish
    :init (yas-global-mode 1)
    :bind (:map yas-minor-mode-map
                ("<tab>" . nil)
                ("C-<tab>" . yas-expand)))
#+end_src

It is even possible to define your own snippets. The following package contains a lot of useful snippets for various programming languages or tools, such a C++, Clojure, various Makefiles, Emacs' Org-Mode ...

#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :after yasnippet)
#+end_src

**** Company

     Several packages are available to make auto-completion more efficient and intuitive than the built-in =completion-at-point= function. We use [[https://company-mode.github.io/][Company]] (stands for "comp[lete] any[thing]") as it integrates nicely with other packages that we use, is well-maintained and has a more modern interface than most of its counterparts such as =auto-complete=.

#+begin_src emacs-lisp
  ;; Company. Auto-completion package
  (use-package company
    :diminish

    :init (global-company-mode t)

    :bind (
       :map company-active-map
          ("<tab>" . company-complete-selection)
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous)
          ("M-n" . nil)
          ("M-p" . nil)
       :map company-search-map
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous))

    :custom
       (company-minimum-prefix-length 1)
       (company-idle-delay 0.0)
       (company-selection-wrap-around t)
       (company-show-numbers t)
       (company-tooltip-align-annotations t)
       (company-tooltip-flip-when-above t))

#+end_src

To have a cleaner interface and also a bit of documentation added to the suggested completions, we use two extra packages.

#+begin_src emacs-lisp
  (use-package company-box
    :after company
    :hook (company-mode . company-box-mode)
    :diminish)

  (use-package company-quickhelp
    :after company
    :hook (company-mode . company-quickhelp-mode)
    :diminish
    :custom (company-quickhelp-delay 0.2))

#+end_src

***** Company backends

A first backend that we want to consider is the one using snippets provided by =yasnippet=

#+begin_src emacs-lisp
;; (add-to-list 'company-backends 'company-yasnippet)
#+end_src

We install another backend specifically for LaTeX

#+begin_src emacs-lisp
  (use-package company-math
    :after company
    :config
    (add-to-list 'company-backends 'company-math-symbols-unicode)
    (add-to-list 'company-backends 'company-math-symbols-latex))
#+end_src

We add another backend to support completion in shell and terminal-modes
#+begin_src emacs-lisp
  (use-package company-shell
    :defer t
    :config
  (defun my-company-shell-modes ()
    (setq-local company-backends '((company-capf company-shell company-shell-env company-files company-dabbrev)))

    (add-hook 'eshell-mode-hook #'my-company-shell-modes)))
#+end_src

***** TODO Yasnippet, Company and LSP
Fix Company-Yasnippet in LSP-mode, doesn't seem to work as completions from LSP are no longer shown.

** Language Server Protocol

*** LSP-mode

    The [[https://en.wikipedia.org/wiki/Language_Server_Protocol][Language Server Protocol]] is a protocol which facilitates the use of several languages with various IDE. Instead of specifying a syntax, ..., for each pair "IDE/Language", it aims at abstracting the specifities of each language, so that each IDE will need to communicate with a server that will give back the information needed to do IDE-y things such as highlighting or auto-completion in an unified manner.

#+begin_src emacs-lisp

  ;; LSP mode. Useful IDE-like features
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :config
    (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
    (lsp-enable-which-key-integration t)
    (setq lsp-prefer-flymake nil)
    (setq lsp-diagnostics-provider :flycheck) ;:none if none wanted
    (setq read-process-output-max (* 2 1024 1024)) ;; 2mb
    :hook
    ((python-mode c-mode c++-mode) . lsp))

  (use-package lsp-ui
    :after lsp-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-delay 1)
    (lsp-ui-sideline-show-code-actions nil)
    ;(lsp-ui-sideline-enable nil)
   )

  (use-package lsp-treemacs
    :after lsp-mode
    :config (lsp-treemacs-sync-mode 1))

  (use-package lsp-ivy
    :after (lsp-mode ivy))

#+end_src

*** Eglot

There exists another implementation of the Language Server Protocol in Emacs, called [[https://github.com/joaotavora/eglot][eglot]]. It is much more integrated within "core" Emacs, as it only uses built-in packages, such as =project.el= instead of =projectile=, or =flymake= rather than =flycheck=.

#+begin_src emacs-lisp
  ;; Might not work, recommended to use package-install instead
  ;; Dependencies might not be the correct ones

  (use-package eglot
    ;;:hook ((python-mode c-mode c++-mode) . eglot-ensure)
    :bind-keymap ("C-c l" . eglot-mode-map)
    :bind (:map eglot-mode-map
                ("r" . eglot-rename)
                ("g g" . xref-find-definitions)
                ("g r" . xref-find-references)
                ("h" . eldoc)))
#+end_src

** Real-time syntax checking

    [[https://www.flycheck.org/en/latest/][Flycheck]] is a modern on-the-fly syntax checking extension to Emacs, working for several languages, showing different level of errors (warnings, errors ...), and which has a natural integration to =lsp-mode=.

#+begin_src emacs-lisp
;; Flycheck
(use-package flycheck
  :defer t
  :config
  ;(setq flycheck-relevant-error-other-file-show nil) ;might be useful
  (setq flycheck-indication-mode 'left-margin)
  :diminish
  ;; :hook (python-mode . flycheck-mode)
  ) ; Temporary to avoid noise ...

#+end_src

Another package doing more or less the same thing but in a different way:

#+begin_src emacs-lisp
;; Semantic
(use-package semantic
;; (require 'semantic/ia)
;; (require 'semantic/bovine/gcc)

;; (defun my-semantic-hook ()
;;   (imenu-add-to-menubar "TAGS"))
;; (add-hook 'semantic-init-hooks 'my-semantic-hook)
  :defer t
  :config
  (semantic-mode t)
  (global-semanticdb-minor-mode t)
  (global-semantic-idle-scheduler-mode t))

#+end_src

** Programming languages

    In this section, we fine-tune our tools to specific programming languages.
*** Python

     We need to specify which server LSP will use. Several packages are available.

     *MANUAL* Before using LSP, use the following command to install a server:

     =pip install --user python-language-server[all]=

     The command =pyls= needs to be available on the =PATH= environment variable.

     #+begin_src emacs-lisp
  ;; Python
  ;; Before using LPS, make sure that the server has been installed !
  ;; pip install --user python-language-server[all]
  ;; Should be able to use the pyls command
  
  (use-package python
    :ensure nil
    :custom
    (tab-width 4)
    (python-indent-offset 4)
    (python-shell-interpreter "python3"))

     #+end_src

*** OCaml

For OCaml, we do not use LSP mode, and we instead choose to work with a specific minor mode called [[https://github.com/ocaml/tuareg][Tuareg]].

#+begin_src emacs-lisp
  ;; Tuareg (for OCaml and ML like languages)
  (use-package tuareg
    :defer t
    :config
    (setq tuareg-indent-align-with-first-arg t)
    (setq tuareg-match-patterns-aligned t))

#+end_src

*** C/C++

For C and C++ (and ObjectiveC), as for Python, we need to install a server for LSP to use. We use the one called [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]].

*MANUAL* To use the ccls server, follow the instruction [[https://github.com/MaskRay/ccls/][here]].

#+begin_src emacs-lisp
;; C/C++
;; See https://github.com/MaskRay/ccls/wiki/lsp-mode
(use-package ccls
  :defer t
  :config
  (setq ccls-executable (executable-find "ccls")))
#+end_src
*** LISP
***** Emacs Lisp

Although Emacs comes with pretty good built-in functionalities, there is still room for improvement.

[[https://github.com/Fanael/highlight-defined][highlight defined]] highlights defined Emacs Lisp symbols (functions, variable names, macros ...) in source code.

#+begin_src emacs-lisp
(use-package highlight-defined
:hook (emacs-lisp-mode . highlight-defined-mode))

#+end_src

[[https://github.com/Silex/elmacro][elmacro]] shows keyboard macros and interactive commands as Emacs Lisp, meaning that you know /how to do/ something using advanced keyboard shortcuts or interactive commands, you can get for free an elisp code snippet that does exactly the same thing that you can reuse /e.g./ in a configuration file or in another function.

Because it might be useful everywhere, we do not use it simply in =emacs-lisp-mode= and we activate it everywhere.

#+begin_src emacs-lisp
(use-package elmacro
:init (elmacro-mode t))
#+end_src

We define a useful macro to evaluate an expression, and replace it with the result. This, in conjunction with macros and multiple cursors, is a great tool to automate otherwise boring tasks.

#+begin_src emacs-lisp
  (defun lps/eval-and-replace-last-sexp ()
    "Evaluate the last s-expression, and replace it with the result"
    (interactive)
    (let ((value (eval (preceding-sexp))))
        (kill-sexp -1)
        (insert (format "%S" value))))

  (global-set-key (kbd "C-c C-e") 'lps/eval-and-replace-last-sexp)
#+end_src

***** Common Lisp

We could, of course, use LSP to write Common Lisp code. However, Emacs already provides nice editing functionalities for programming in Lisp-like languages, and CL is no exception. On top of the built-in Emacs functions, we use another minor mode, specifically designed to write Common Lisp: [[https://common-lisp.net/project/slime/][SLIME]]. More precisely, we use a /fork/ of SLIME, known as [[https://github.com/joaotavora/sly][SLY]].

*MANUAL* It is likely that =sbcl= is not already installed. Hence, in order to run the following code, you will need to install it. If you install it manuallyby compiling the source code, make sure that the =sbcl= command is available on the PATH, or modify  =:custom (inferior-lisp-program "<path/to/sbcl>")= accordingly in the following block.

#+begin_src emacs-lisp
;; Make sure that sbcl is available on PATH
(use-package sly
  :hook (lisp-mode . sly-editing-mode)
  :custom (inferior-lisp-program "sbcl") ; Clisp makes SLY crash
  :config
  (add-hook 'sly-mode-hook
            (lambda ()
               (unless (sly-connected-p)
                 (save-excursion (sly))))))
#+end_src
* Org Mode

   [[https://orgmode.org/][Org Mode]] is one of the best reasons to use Emacs.

   It acts as a markup language, can deal with planning, manage spreadsheets, do project planning, run code blocks to do literate programming ...

** Font faces

     In order for Org Mode to feel like a document instead of code, we use a different font.

#+begin_src emacs-lisp
(let ((my-temp-org-font "Cantarell"))
    (if (member my-temp-org-font (font-family-list))
        (setq my-org-mode-font my-temp-org-font)
      (setq my-org-mode-font "Ubuntu Mono")))

(defun my-org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â¢"))))))

  ;; Set faces for heading levels
  ;; For non-headers: org-default

  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font my-org-mode-font :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+end_src
** Basic configuration

     We change the general feel of Org Mode documents by using other indentation rules, by changing the headers appearance, and a few other minor changes.

#+begin_src emacs-lisp
  (defun my-org-mode-setup ()
    (my-org-font-setup)
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :config
    (setq org-ellipsis " â¾")

    ;; Coding in blocks
    (setq org-src-fontify-natively t
          org-src-tab-acts-natively t)

    :hook (org-mode . my-org-mode-setup))

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("â" "â" "â" "â" "â" "â" "â")))

#+end_src

** Org Babel

Org babel is what allows us to write code and execute it, all within the same document.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t))))

  ;; (setq org-confirm-babel-evaluate nil) ; Take care if executing someone
                                           ; else code

#+end_src

We also add templates to insert code blocks with a few key presses

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (if (version<= "9.2" org-version)
        ;; This is needed as of Org 9.2
      (progn
        (require 'org-tempo)

        (let ((bound-key-templates
               (mapcar #'car org-structure-template-alist)))
          (dolist (key-template '(("sh" . "src shell")
                                  ("el" . "src emacs-lisp")
                                  ("py" . "src python")))

            (unless
                (member (car key-template) bound-key-templates)
              (push key-template org-structure-template-alist)))))))

#+end_src

** Auto-tangle configuration files

     In order to concatenate all the code blocks that are written in this document to an external file, we need to "tangle" it.

     The following code makes it so that each time this file is saved, it generates the corresponding init.el file.

#+begin_src emacs-lisp
;; Automatically tangles this emacs-config config file when we save it
(defun my-org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "~/.emacs.d/emacs-config.org"))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'my-org-babel-tangle-config)))
#+end_src

* LaTeX and PDF
*** PDF viewer

Rather than =doc-view=, we  use [[https://github.com/politza/pdf-tools][PDF Tools]].

*MANUAL* This package might require some external libraries to be installed. Please refer to the linked page to see exactly what you need to do on your system.

#+begin_src emacs-lisp
  ;; Might require extra libs to work, see https://github.com/politza/pdf-tools

  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward))
    :config
    (pdf-tools-install :no-query)
    (add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode))
#+end_src

*** LaTeX

It is also possible to configure Emacs to comfortably write and edit LaTeX documents

#+begin_src emacs-lisp
  (use-package tex-site                   ; AUCTeX initialization
    :ensure auctex)

  (use-package tex
    :ensure auctex
    :custom ;; Automatically insert closing brackets
    (LaTeX-electric-left-right-brace t)
    (TeX-parse-self t)                ; Parse documents to provide completion
    (TeX-auto-save t)                 ; Automatically save style information
    (TeX-electric-sub-and-superscript t)  ; Automatically insert braces after
                                          ; sub- and superscripts in math mode
    ;; Don't insert magic quotes right away.
    (TeX-quote-after-quote t)
    ;; But do insert closing $ when inserting the first one
    (TeX-electric-math '("$" . "$"))

    ;; Don't ask for confirmation when cleaning
    (TeX-clean-confirm nil)

    (TeX-source-correlate-method 'synctex)
    (TeX-source-correlate-start-server t)
    (TeX-view-program-selection '((output-pdf "PDF tools")))

    :config
    (setq TeX-master nil) ; Ask for the master file & don't assume anything

    (setq TeX-source-correlate-mode t ; SyncTeX forward and inverse search
          ;; Produce a PDF by default
          TeX-PDF-mode t)

    (unless (assoc "PDF tools" TeX-view-program-list-builtin)
      (push '("PDF tools" TeX-pdf-tools-sync-view) TeX-view-program-list))

    ;; Update PDF buffers after successful LaTeX runs
    (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

    ;; Insert math symbols quickly
    (add-hook 'LaTeX-mode-hook #'LaTeX-math-mode))

#+end_src

We also configure BibTeX

#+begin_src emacs-lisp
  (use-package bibtex                     ; BibTeX editing
    :defer t
    :config
    ;; Use a modern BibTeX dialect
    ; (bibtex-set-dialect 'biblatex) ; Useful esp. in social sci.
)
#+end_src

Another useful package to deal with references, bibliography, citations and so on, is [[https://www.gnu.org/software/emacs/manual/html_mono/reftex.html][RefTeX]].

#+begin_src emacs-lisp
  (use-package reftex                     ; TeX/BibTeX cross-reference management
    :diminish
    :hook (LaTeX-mode . reftex-mode)
    :config
    ;; Plug into AUCTeX
    (setq reftex-plug-into-AUCTeX t
          ;; Provide basic RefTeX support for biblatex
          ;; (unless (assq 'biblatex reftex-cite-format-builtin)
          ;;   (add-to-list 'reftex-cite-format-builtin
          ;;                '(biblatex "The biblatex package"
          ;;                           ((?\C-m . "\\cite[]{%l}")
          ;;                            (?t . "\\textcite{%l}")
          ;;                            (?a . "\\autocite[]{%l}")
          ;;                            (?p . "\\parencite{%l}")
          ;;                            (?f . "\\footcite[][]{%l}")
          ;;                            (?F . "\\fullcite[]{%l}")
          ;;                            (?x . "[]{%l}")
          ;;                            (?X . "{%l}"))))
          ;;   (setq reftex-cite-format 'biblatex))
          ))
#+end_src

* System
** Eshell
*** Visual

Contrary to =term= and =shell= (respectively invoked by =M-x <term/shell>=), [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][eshell]] is not /emulating/ anything: it is, on its own, a shell-like command interpreter implemented in Emacs Lisp. As such, it provides (most of) the usual commands such as =grep=, =ls= and so on, as well as an extra binding to Emacs (for example, you can redirect the output of any command to an Emacs buffer). For this reason, you can use =eshell= on any system that is able to run Emacs, as there is no external dependency.

In fact, some of those commands are reimplemented in Emacs Lisp (/e.g./ =cat=), some of them are using the Emacs tools (for example =grep=), and unknown commands are passed to the /real/ commandline.

A more in-depth guide can be found [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][here]].

We install a few packages which make eshell easier to use.

#+begin_src emacs-lisp
  ;; eshell

  (setq eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t)

  (use-package eshell-did-you-mean
    :commands eshell
    :config (eshell-did-you-mean-setup))

  (use-package eshell-syntax-highlighting
    :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+end_src

*** Binding with .bashrc
*MANUAL* One thing that we might want to do is to be able to use aliases defined in =.bashrc= in =eshell=. There are [[https://www.emacswiki.org/emacs/EshellAlias][several solutions]] to this problem, and the one I use only allows us to use bash aliases in =eshell= and not the contrary, for example.

We do this by adding the following line at the end of the =.bashrc= file:

#+begin_src sh
alias | sed -E "s/^alias ([^=]+)='(.*)'$/alias \1 \2 \$*/g; s/'\\\''/'/g;" >~/.emacs.d/eshell/alias
#+end_src

It will simply go through the =.bashrc= file whenever you open a bash terminal, and each time it sees a line starting with =alias=, it will generate the corresponding alias in an appropriate syntax and put it in the =eshell/alias= file where =eshell= reads its aliases.

**** TODO Rewrite this, using two different files that are "loaded" by eshell.
** Dired

Now, we try to add things on top of the built-in file manager, Dired.

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :config
    ;; Delete and copy directories recursively
    (setq dired-recursive-deletes 'always
          dired-recursive-copies 'always)

    (setq dired-auto-revert-buffer t))

  ;; Make things prettier 
  (use-package all-the-icons-dired
    :diminish
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-x
    :ensure nil
    :after dired)
#+end_src
* Fun
As we tend to spend a lot of time in Emacs, isn't it natural to install fun and distracting packages ?
** XKCD
We /love/ [[https://xkcd.com][XKCD]], and so do most of Emacs users. Hence, someone has written a package to read his favourite web-comic directly within Emacs !

#+begin_src emacs-lisp
  (use-package xkcd
    :defer t)
#+end_src
** Keyboard games
*** Speed-typing
This package can help you benchmark how fast you are able to write text within Emacs, by using random text samples that you have to copy. It is even possible to add some other books from which to generate those samples.

#+begin_src emacs-lisp
  (use-package speed-type
    :defer t
    :custom (speed-type-default-lang 'French)) ; Todo: fix bad behaviour !
#+end_src
*** Key Quiz

Another cool thing to do if you want to learn keybindings in a very inefficient way is to simply pick a command at random and try to remember the associated keybinding ! This is exactly what the following package tries to do

#+begin_src emacs-lisp
  (use-package key-quiz
    :defer t)
#+end_src
